{"version":3,"sources":["webpack:///src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","webpack:///webpack/bootstrap f038bf6ca8a680c37458","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/config.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/index.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/initSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/resetSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/updateSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","webpack:///./~/fuse.js/dist/fuse.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","SELECTORS","CLASSES","ATTRIBUTES","PP_CHOOSER","PP_SEARCH_FIELD","PP_SEARCH_ITEM","PP_SEARCH_RESET","PP_SEARCH_ITEM_HIDDEN","PP_TYPES","PP_NAME","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0__config__","__WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","PagePartChooser","this","pagePartChoosers","arguments","undefined","window","document","querySelectorAll","forEach","pagePartChooser","initSearch","ppChooser","searchHandler","searchField","trim","searchResults","fuse","search","__WEBPACK_IMPORTED_MODULE_3__updateSearch__","ppList","__WEBPACK_IMPORTED_MODULE_2__resetSearch__","resetHandler","ppTypes","JSON","parse","getAttribute","__WEBPACK_IMPORTED_MODULE_1__config__","ppTypesSearchData","makePagePartDataSearchable","initFuse","querySelector","addEventListener","map","_ref","className","extractClassNameFromNamespace","class","ppClass","lastBackSlashIndex","lastIndexOf","substring","replace","ppSearchData","__WEBPACK_IMPORTED_MODULE_0_fuse_js___default","a","keys","weight","id","threshold","shouldSort","__WEBPACK_IMPORTED_MODULE_0_fuse_js__","resetSearch","searchItems","item","classList","remove","updateSearch","ppName","includes","add","init","__WEBPACK_IMPORTED_MODULE_0__PagePartChooser__","readyState","root","factory","obj","toString","bitapRegexSearch","bitapSearch","patternAlphabet","Bitap","pattern","_ref$location","location","_ref$distance","distance","_ref$threshold","_ref$maxPatternLength","maxPatternLength","_ref$isCaseSensitive","isCaseSensitive","_ref$tokenSeparator","tokenSeparator","_ref$findAllMatches","findAllMatches","_ref$minMatchCharLeng","minMatchCharLength","options","toLowerCase","text","isMatch","score","matchedIndices","_options","_options2","deepValue","path","list","dotIndex","indexOf","firstSegment","remaining","slice","len","push","matchmask","start","end","match","mask","charAt","_i","SPECIAL_CHARS_REGEX","regex","RegExp","matches","matchesLen","_ref$errors","errors","_ref$currentLocation","currentLocation","_ref$expectedLocation","expectedLocation","accuracy","proximity","Math","abs","bitapScore","textLen","currentThreshold","bestLocation","patternLen","matchMask","min","_score","lastBitArr","finalScore","binMax","binMin","binMid","floor","max","finish","bitArr","j","charMatch","Fuse","_ref$caseSensitive","caseSensitive","_ref$id","_ref$keys","_ref$shouldSort","_ref$getFn","getFn","_ref$sortFn","sortFn","b","_ref$tokenize","tokenize","_ref$matchAllTokens","matchAllTokens","_ref$includeMatches","includeMatches","_ref$includeScore","includeScore","_ref$verbose","verbose","setCollection","_log","_prepareSearchers2","_prepareSearchers","tokenSearchers","fullSearcher","_search2","_search","weights","results","_computeScore","_sort","_format","tokens","split","resultMap","_analyze","record","index","_len","keysLen","Error","_ref2","_ref3","_ref2$arrayIndex","arrayIndex","_ref3$tokenSearchers","_ref3$fullSearcher","_ref3$resultMap","_ref3$results","exists","averageScore","numTextMatches","mainSearchResult","words","scores","tokenSearcher","hasMatchInText","word","tokenSearchResult","scoresLen","_i2","checkTextMatches","existingResult","output","_i3","scoreLen","currScore","bestScore","nScore","sort","finalOutput","stringify","transformers","result","data","indices","_len2","_console","console","log","apply"],"mappings":"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","file":"./src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SELECTORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CLASSES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ATTRIBUTES; });\nvar SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nvar CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nvar ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__ = __webpack_require__(2);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar PagePartChooser = function () {\n    function PagePartChooser() {\n        _classCallCheck(this, PagePartChooser);\n    }\n\n    _createClass(PagePartChooser, null, [{\n        key: 'init',\n        value: function init() {\n            var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;\n\n            var pagePartChoosers = [].concat(_toConsumableArray(container.querySelectorAll(__WEBPACK_IMPORTED_MODULE_0__config__[\"a\" /* SELECTORS */].PP_CHOOSER)));\n\n            pagePartChoosers.forEach(function (pagePartChooser) {\n                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__[\"a\" /* initSearch */])(pagePartChooser);\n            });\n        }\n    }]);\n\n    return PagePartChooser;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PagePartChooser);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = initSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fuse_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resetSearch__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__updateSearch__ = __webpack_require__(4);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\nfunction initSearch(ppChooser) {\n    var ppTypes = JSON.parse(ppChooser.getAttribute(__WEBPACK_IMPORTED_MODULE_1__config__[\"b\" /* ATTRIBUTES */].PP_TYPES));\n\n    var ppTypesSearchData = makePagePartDataSearchable(ppTypes);\n\n    var ppList = [].concat(_toConsumableArray(ppChooser.querySelectorAll(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_ITEM)));\n    var fuse = initFuse(ppTypesSearchData);\n\n    var searchField = ppChooser.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_FIELD);\n    searchField.addEventListener('keyup', searchHandler);\n\n    var searchResetButton = ppChooser.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_RESET);\n    searchResetButton.addEventListener('click', resetHandler);\n\n    function searchHandler() {\n        if (searchField.value.trim().length > 0) {\n            var searchResults = fuse.search(searchField.value);\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__updateSearch__[\"a\" /* updateSearch */])(ppList, searchResults);\n        } else {\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__resetSearch__[\"a\" /* resetSearch */])(ppList);\n        }\n    }\n\n    function resetHandler() {\n        searchField.value = '';\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__resetSearch__[\"a\" /* resetSearch */])(ppList);\n    }\n}\n\nfunction makePagePartDataSearchable(ppTypes) {\n    return ppTypes.map(function (_ref) {\n        var name = _ref.name,\n            className = _ref.class;\n        return {\n            name: name,\n            className: extractClassNameFromNamespace(className)\n        };\n    });\n}\n\nfunction extractClassNameFromNamespace(ppClass) {\n    var className = ppClass;\n\n    var lastBackSlashIndex = className.lastIndexOf('\\\\');\n    if (lastBackSlashIndex !== -1) {\n        className = className.substring(lastBackSlashIndex + 1);\n    }\n\n    return className.replace('PagePart', '');\n}\n\nfunction initFuse(ppSearchData) {\n    return new __WEBPACK_IMPORTED_MODULE_0_fuse_js___default.a(ppSearchData, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'className',\n            weight: 0.3 // The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = resetSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n\n\nfunction resetSearch(searchItems) {\n    searchItems.forEach(function (item) {\n        item.classList.remove(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = updateSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n\n\nfunction updateSearch(searchItems, searchResults) {\n    searchItems.forEach(function (item) {\n        var ppName = item.getAttribute(__WEBPACK_IMPORTED_MODULE_0__config__[\"b\" /* ATTRIBUTES */].PP_NAME);\n\n        if (searchResults.includes(ppName)) {\n            item.classList.remove(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PagePartChooser__ = __webpack_require__(1);\n\n\nfunction init() {\n    __WEBPACK_IMPORTED_MODULE_0__PagePartChooser__[\"a\" /* default */].init();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        init();\n    });\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Fuse.js v3.2.1 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    // console.log('score', score, finalScore)\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // console.log('FINAL SCORE', finalScore)\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var currScore = 1;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            currScore *= nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? currScore : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      if (this.options.verbose) {\n        this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results));\n      }\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f038bf6ca8a680c37458","export const SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nexport const CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nexport const ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/config.js","import {SELECTORS} from './config';\nimport {initSearch} from './pagepart-search/initSearch';\n\nexport default class PagePartChooser {\n    static init(container = window.document) {\n        const pagePartChoosers = [...container.querySelectorAll(SELECTORS.PP_CHOOSER)];\n\n        pagePartChoosers.forEach((pagePartChooser) => {\n            initSearch(pagePartChooser);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/index.js","import Fuse from 'fuse.js';\nimport {ATTRIBUTES, SELECTORS} from '../config';\nimport {resetSearch} from './resetSearch';\nimport {updateSearch} from './updateSearch';\n\nexport function initSearch(ppChooser) {\n    const ppTypes = JSON.parse(ppChooser.getAttribute(ATTRIBUTES.PP_TYPES));\n\n    const ppTypesSearchData = makePagePartDataSearchable(ppTypes);\n\n    const ppList = [...ppChooser.querySelectorAll(SELECTORS.PP_SEARCH_ITEM)];\n    const fuse = initFuse(ppTypesSearchData);\n\n    const searchField = ppChooser.querySelector(SELECTORS.PP_SEARCH_FIELD);\n    searchField.addEventListener('keyup', searchHandler);\n\n    const searchResetButton = ppChooser.querySelector(SELECTORS.PP_SEARCH_RESET);\n    searchResetButton.addEventListener('click', resetHandler);\n\n    function searchHandler() {\n        if (searchField.value.trim().length > 0) {\n            const searchResults = fuse.search(searchField.value);\n            updateSearch(ppList, searchResults);\n        } else {\n            resetSearch(ppList);\n        }\n    }\n\n    function resetHandler() {\n        searchField.value = '';\n        resetSearch(ppList);\n    }\n}\n\nfunction makePagePartDataSearchable(ppTypes) {\n    return ppTypes.map(({name, class: className}) => ({\n        name,\n        className: extractClassNameFromNamespace(className)\n    }));\n}\n\nfunction extractClassNameFromNamespace(ppClass) {\n    let className = ppClass;\n\n    const lastBackSlashIndex = className.lastIndexOf('\\\\');\n    if (lastBackSlashIndex !== -1) {\n        className = className.substring(lastBackSlashIndex + 1);\n    }\n\n    return className.replace('PagePart', '');\n}\n\nfunction initFuse(ppSearchData) {\n    return new Fuse(ppSearchData, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'className',\n            weight: 0.3 // The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/initSearch.js","import {CLASSES} from '../config';\n\nexport function resetSearch(searchItems) {\n    searchItems.forEach((item) => {\n        item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/resetSearch.js","import {CLASSES, ATTRIBUTES} from '../config';\n\nexport function updateSearch(searchItems, searchResults) {\n    searchItems.forEach((item) => {\n        const ppName = item.getAttribute(ATTRIBUTES.PP_NAME);\n\n        if (searchResults.includes(ppName)) {\n            item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/updateSearch.js","import PagePartChooser from './PagePartChooser';\n\nfunction init() {\n    PagePartChooser.init();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', () => {\n        init();\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","/*!\n * Fuse.js v3.2.1 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    // console.log('score', score, finalScore)\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // console.log('FINAL SCORE', finalScore)\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var currScore = 1;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            currScore *= nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? currScore : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      if (this.options.verbose) {\n        this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results));\n      }\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fuse.js/dist/fuse.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}