{"version":3,"sources":["webpack:///src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","webpack:///webpack/bootstrap d0e60ac6dc1756d0403e","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/config.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/config.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/index.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/index.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/polyfills.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/MediaCropper.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/renderViewSelectOptions.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/initSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/resetSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/updateSearch.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","webpack:///./~/cropperjs/dist/cropper.js","webpack:///./~/fuse.js/dist/fuse.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","SELECTORS","CLASSES","ATTRIBUTES","PP_CHOOSER","PP_SEARCH_FIELD","PP_SEARCH_ITEM","PP_SEARCH_RESET","PP_SEARCH_ITEM_HIDDEN","PP_TYPES","PP_NAME","MODIFIERS","CROP_BOX_THRESHOLD","META_KEYS","CROPPER_CONFIG","HOOK","CONTAINER","IMAGE","META_CONTAINER","META_ITEM","VIEW_SELECT","SAVE","CROP_BOX_SMALL_CROPPED_AREA","viewMode","movable","rotatable","scalable","zoomable","zoomOnTouch","zoomOnWheel","_toConsumableArray","arr","Array","isArray","arr2","length","from","initMediaCroppers","container","arguments","undefined","window","document","PREVIEW_BTNS","querySelectorAll","addEventListener","e","targetModal","detail","node","querySelector","hasAttribute","MediaCropper","__WEBPACK_IMPORTED_MODULE_0__config__","__WEBPACK_IMPORTED_MODULE_1__MediaCropper__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","PagePartChooser","this","pagePartChoosers","forEach","pagePartChooser","initSearch","console","log","entries","obj","ownProps","keys","resArray","CustomEvent","event","params","bubbles","cancelable","evt","createEvent","initCustomEvent","Event","__WEBPACK_IMPORTED_MODULE_0_cropperjs__","__WEBPACK_IMPORTED_MODULE_0_cropperjs___default","__WEBPACK_IMPORTED_MODULE_1__config__","__WEBPACK_IMPORTED_MODULE_2__renderViewSelectOptions__","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","image","imagePath","dataset","path","metaContainer","viewSelect","save","input","inputId","metaValueNodes","cropper","viewData","cropData","savedCropData","JSON","parse","initialized","init","_this","_ref","x","y","width","height","small_crop_box_area","textContent","Math","ceil","classList","add","remove","currentView","start","size","_this2","data","getData","updateValue","destroy","initCropper","preventDefault","stringify","config","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_step$value","return","savedValues","Cropper","_this3","getValueNodes","croppingViews","view","aspectRatio","lockRatio","NaN","minCropBoxWidth","minCropBoxHeight","renderViewSelectOptions","src","addEventListeners","select","OPTION_NAMES","innerHTML","option","createElement","selected","appendChild","disabled","ppChooser","searchHandler","searchField","trim","searchResults","fuse","search","updateSearch","ppList","resetSearch","resetHandler","ppTypes","getAttribute","ppTypesSearchData","makePagePartDataSearchable","initFuse","map","className","extractClassNameFromNamespace","class","ppClass","lastBackSlashIndex","lastIndexOf","substring","replace","ppSearchData","Fuse","weight","id","threshold","shouldSort","__WEBPACK_IMPORTED_MODULE_0_fuse_js__","__WEBPACK_IMPORTED_MODULE_0_fuse_js___default","__WEBPACK_IMPORTED_MODULE_2__resetSearch__","__WEBPACK_IMPORTED_MODULE_3__updateSearch__","searchItems","item","ppName","includes","__WEBPACK_IMPORTED_MODULE_0__polyfills__","__WEBPACK_IMPORTED_MODULE_1__PagePartChooser__","__WEBPACK_IMPORTED_MODULE_2__MediaCropper__","readyState","global","factory","_typeof","constructor","_defineProperties","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread2","source","getOwnPropertyDescriptors","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","toString","isNumber","isNaN","isUndefined","isObject","isPlainObject","_constructor","error","isFunction","toArray","slice","callback","normalizeDecimalNumber","times","REGEXP_DECIMALS","test","round","setStyle","element","styles","style","REGEXP_SUFFIX","concat","hasClass","contains","indexOf","addClass","elem","removeClass","toggleClass","added","toParamCase","REGEXP_CAMEL_CASE","toLowerCase","setData","setAttribute","removeData","removeAttribute","removeListener","type","listener","options","handler","split","REGEXP_SPACES","onceSupported","listeners","removeEventListener","addListener","_handler","once","_element$listeners","_len2","args","_key2","dispatchEvent","getOffset","box","getBoundingClientRect","left","pageXOffset","documentElement","clientLeft","top","pageYOffset","clientTop","isCrossOriginURL","url","parts","match","REGEXP_ORIGINS","location","protocol","hostname","port","addTimestamp","timestamp","Date","getTime","getTransforms","rotate","scaleX","scaleY","translateX","translateY","values","transform","join","WebkitTransform","msTransform","getMaxZoomRatio","pointers","pointers2","ratios","pointer","pointerId","pointer2","x1","abs","startX","y1","startY","x2","endX","y2","endY","z1","sqrt","z2","ratio","sort","a","b","getPointer","_ref2","endOnly","pageX","pageY","end","getPointersCenter","count","_ref3","getAdjustedSizes","_ref4","isValidWidth","isPositiveNumber","isValidHeight","adjustedWidth","getRotatedSizes","_ref5","degree","arc","PI","sinArc","sin","cosArc","cos","newWidth","newHeight","getSourceCanvas","_ref6","_ref7","_ref8","imageAspectRatio","imageNaturalWidth","naturalWidth","imageNaturalHeight","naturalHeight","_ref6$rotate","_ref6$scaleX","_ref6$scaleY","_ref8$fillColor","fillColor","_ref8$imageSmoothingE","imageSmoothingEnabled","_ref8$imageSmoothingQ","imageSmoothingQuality","_ref8$maxWidth","maxWidth","Infinity","_ref8$maxHeight","maxHeight","_ref8$minWidth","minWidth","_ref8$minHeight","minHeight","canvas","context","getContext","maxSizes","minSizes","min","max","destMaxSizes","destMinSizes","destWidth","destHeight","fillStyle","fillRect","translate","scale","drawImage","param","floor","restore","getStringFromCharCode","dataView","str","fromCharCode","getUint8","dataURLToArrayBuffer","dataURL","base64","REGEXP_DATA_URL_HEAD","binary","atob","arrayBuffer","ArrayBuffer","uint8","Uint8Array","charCodeAt","arrayBufferToDataURL","mimeType","chunks","subarray","btoa","resetAndGetOrientation","orientation","DataView","littleEndian","app1Start","ifdStart","byteLength","offset","exifIDCode","tiffOffset","endianness","getUint16","firstIFDOffset","getUint32","_offset","_length","setUint16","parseOrientation","IS_BROWSER","WINDOW","IS_TOUCH_DEVICE","HAS_POINTER_EVENT","CLASS_CROP","CLASS_DISABLED","CLASS_HIDDEN","CLASS_HIDE","CLASS_INVISIBLE","CLASS_MODAL","CLASS_MOVE","DATA_ACTION","DATA_PREVIEW","EVENT_TOUCH_START","EVENT_TOUCH_MOVE","EVENT_TOUCH_END","EVENT_POINTER_DOWN","EVENT_POINTER_MOVE","EVENT_POINTER_UP","REGEXP_ACTIONS","REGEXP_DATA_URL","REGEXP_DATA_URL_JPEG","REGEXP_TAG_NAME","DEFAULTS","dragMode","initialAspectRatio","preview","responsive","checkCrossOrigin","checkOrientation","modal","guides","center","highlight","background","autoCrop","autoCropArea","wheelZoomRatio","cropBoxMovable","cropBoxResizable","toggleDragModeOnDblclick","minCanvasWidth","minCanvasHeight","minContainerWidth","minContainerHeight","ready","cropstart","cropmove","cropend","crop","zoom","Number","assign","_len","_key","arg","supported","set","String","render","initContainer","initCanvas","initCropBox","renderCanvas","cropped","renderCropBox","containerData","offsetWidth","offsetHeight","imageData","rotated","canvasWidth","canvasHeight","canvasData","oldLeft","oldTop","limited","limitCanvas","initialImageData","initialCanvasData","sizeLimited","positionLimited","cropBoxData","_getAdjustedSizes","newCanvasLeft","newCanvasTop","minLeft","minTop","maxLeft","maxTop","changed","transformed","_getRotatedSizes","renderImage","limitCropBox","output","initialCropBoxData","maxCropBoxWidth","maxCropBoxHeight","face","cropBox","initPreview","crossOrigin","crossOriginUrl","alt","viewBox","viewBoxImage","previews","ownerDocument","el","img","html","cssText","resetPreview","cropBoxWidth","cropBoxHeight","originalWidth","originalHeight","getElementsByTagName","events","bind","onCropStart","cropStart","onWheel","wheel","passive","capture","onDblclick","dblclick","onCropMove","cropMove","onCropEnd","cropEnd","onResize","resize","unbind","handlers","getCanvasData","getCropBoxData","setCanvasData","setCropBoxData","setDragMode","dragBox","delta","wheeling","setTimeout","deltaY","wheelDelta","buttons","button","pointerType","ctrlKey","action","changedTouches","touch","identifier","originalEvent","cropping","change","right","bottom","renderable","shiftKey","range","check","side","move","methods","reset","clear","hasSameSize","isImg","replaced","uncreate","load","enable","disable","originalUrl","offsetX","offsetY","_this$canvasData","moveTo","_originalEvent","zoomTo","pivot","oldRatio","rotateTo","_scaleX","_scaleY","rounded","getContainerData","getImageData","sized","widthChanged","heightChanged","getCroppedCanvas","HTMLCanvasElement","_this$getData","initialX","initialY","initialWidth","initialHeight","_options$imageSmoothi","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","sourceWidth","sourceHeight","srcX","srcY","setAspectRatio","mode","croppable","AnotherCropper","tagName","Error","reloading","sizing","toDataURL","clone","read","xhr","XMLHttpRequest","onabort","onerror","ontimeout","onprogress","getResponseHeader","abort","onload","response","onloadend","open","responseType","withCredentials","send","_parseOrientation","stop","parentNode","insertBefore","nextSibling","isIOSWebKit","navigator","userAgent","build","sizingImage","body","removeChild","template","getElementsByClassName","unbuild","root","bitapRegexSearch","bitapSearch","patternAlphabet","Bitap","pattern","_ref$location","_ref$distance","distance","_ref$threshold","_ref$maxPatternLength","maxPatternLength","_ref$isCaseSensitive","isCaseSensitive","_ref$tokenSeparator","tokenSeparator","_ref$findAllMatches","findAllMatches","_ref$minMatchCharLeng","minMatchCharLength","text","isMatch","score","matchedIndices","_options","_options2","deepValue","list","dotIndex","firstSegment","remaining","len","matchmask","mask","charAt","SPECIAL_CHARS_REGEX","regex","RegExp","matches","matchesLen","_ref$errors","errors","_ref$currentLocation","currentLocation","_ref$expectedLocation","expectedLocation","accuracy","proximity","bitapScore","textLen","currentThreshold","bestLocation","patternLen","matchMask","_score","lastBitArr","finalScore","binMax","binMin","binMid","finish","bitArr","j","charMatch","_ref$caseSensitive","caseSensitive","_ref$id","_ref$keys","_ref$shouldSort","_ref$getFn","getFn","_ref$sortFn","sortFn","_ref$tokenize","tokenize","_ref$matchAllTokens","matchAllTokens","_ref$includeMatches","includeMatches","_ref$includeScore","includeScore","_ref$verbose","verbose","setCollection","opts","limit","_log","_prepareSearchers2","_prepareSearchers","tokenSearchers","fullSearcher","_search2","_search","weights","results","_computeScore","_sort","_format","tokens","resultMap","_analyze","record","index","keysLen","_ref2$arrayIndex","arrayIndex","_ref3$tokenSearchers","_ref3$fullSearcher","_ref3$resultMap","_ref3$results","exists","averageScore","numTextMatches","mainSearchResult","words","scores","tokenSearcher","hasMatchInText","word","tokenSearchResult","scoresLen","_i2","checkTextMatches","existingResult","_i3","scoreLen","currScore","bestScore","nScore","finalOutput","cache","transformers","result","indices","_console"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAA2C,MAAAA,IAG3CV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,GAAAS,GAAAT,KAAAiB,WACA,WAA2B,MAAAjB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDvB,EAAA0B,EAAA,GAGA1B,IAAA2B,EAAA,MDMM,SAAUvB,EAAQwB,EAAqB5B,GAE7C,YExEAA,GAAAW,EAAAiB,EAAA,qBAAAC,KAAA7B,EAAAW,EAAAiB,EAAA,qBAAAE,KAAA9B,EAAAW,EAAAiB,EAAA,qBAAAG,IAAO,IAAMF,IACTG,WAAY,iBACZC,gBAAiB,gBACjBC,eAAgB,qBAChBC,gBAAiB,wBAGRL,GACTM,sBAAuB,0BAGdL,GACTM,SAAU,gBACVC,QAAS,iBFiFP,SAAUlC,EAAQwB,EAAqB5B,GAE7C,YGhGAA,GAAAW,EAAAiB,EAAA,qBAAAC,KAAA7B,EAAAW,EAAAiB,EAAA,qBAAAW,KAAAvC,EAAAW,EAAAiB,EAAA,qBAAAY,KAAAxC,EAAAW,EAAAiB,EAAA,qBAAAa,KAAAzC,EAAAW,EAAAiB,EAAA,qBAAAc,IAAA,IAAMb,IACFc,KAAM,qCACNC,UAAW,oBACXC,MAAO,0BACPC,eAAgB,yBAChBC,UAAW,+BACXC,YAAa,gCACbC,KAAM,0BAGJV,GACFW,4BAA6B,oCAG3BV,EAAqB,IAErBC,GAAa,QAAS,UAEtBC,GACFS,SAAU,EACVC,SAAS,EACTC,WAAW,EACXC,UAAU,EACVC,UAAU,EACVC,aAAa,EACbC,aAAa,IH6GX,SAAUrD,EAAQwB,EAAqB5B,GAE7C,YAIA,SAAS0D,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAItD,GAAI,EAAGyD,EAAOF,MAAMD,EAAII,QAAS1D,EAAIsD,EAAII,OAAQ1D,IAAOyD,EAAKzD,GAAKsD,EAAItD,EAAM,OAAOyD,GAAe,MAAOF,OAAMI,KAAKL,GIzI1L,QAASM,KAA+C,GAA7BC,GAA6BC,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,GAAjBE,OAAOC,YACpCC,SAAmBL,EAAUM,iBAAiB3C,IAAUc,OAE9D2B,UAASG,iBAAiB,YAAa,SAACC,GACpC,GAAMC,GAAcD,EAAEE,OAChBC,EAAOF,EAAYG,cAAcjD,IAAUe,UAE5CiC,GAAKE,aAAa,qBACnB,GAAIC,KAAaH,KJ8HE7E,EAAoBW,EAAEiB,EAAqB,IAAK,WAAa,MAAOqC,IAC9E,IAAIgB,GAAwCjF,EAAoB,GAC5DkF,EAA8ClF,EAAoB,IAyBrF,SAAUI,EAAQwB,EAAqB5B,GAE7C,YAKA,SAAS0D,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAItD,GAAI,EAAGyD,EAAOF,MAAMD,EAAII,QAAS1D,EAAIsD,EAAII,OAAQ1D,IAAOyD,EAAKzD,GAAKsD,EAAItD,EAAM,OAAOyD,GAAe,MAAOF,OAAMI,KAAKL,GAE1L,QAASwB,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAN3F,GAAIL,GAAwCjF,EAAoB,GAC5DuF,EAA4DvF,EAAoB,GACrGwF,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAItF,GAAI,EAAGA,EAAIsF,EAAM5B,OAAQ1D,IAAK,CAAE,GAAIuF,GAAaD,EAAMtF,EAAIuF,GAAW1E,WAAa0E,EAAW1E,aAAc,EAAO0E,EAAW3E,cAAe,EAAU,SAAW2E,KAAYA,EAAWC,UAAW,GAAM9E,OAAOC,eAAe0E,EAAQE,EAAWE,IAAKF,IAAiB,MAAO,UAAUP,EAAaU,EAAYC,GAAiJ,MAA9HD,IAAYN,EAAiBJ,EAAY7D,UAAWuE,GAAiBC,GAAaP,EAAiBJ,EAAaW,GAAqBX,MKtK3gBY,EL+KC,WAClB,QAASA,KACLd,EAAgBe,KAAMD,GAgB1B,MAbAT,GAAaS,EAAiB,OAC1BH,IAAK,OACLpF,MAAO,cKpLDyF,UAD+BhC,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,GAAjBE,OAAOC,UACYE,iBAAiB3C,IAAUG,cAEjDoE,QAAQ,SAACC,GACtBC,SAAWD,SL4LZJ,IKjMUA,QLwMf,SAAU7F,EAAQD,GMzMxBoG,QAAQC,IAAI,aAEX,WACQzF,OAAO0F,UAERF,QAAQC,IAAI,gCAEZzF,OAAO0F,QAAU,SAAUC,GAIzB,IAHA,GAAIC,GAAW5F,OAAO6F,KAAMF,GACxBrG,EAAIsG,EAAS5C,OACb8C,EAAW,GAAIjD,OAAMvD,GAClBA,KACLwG,EAASxG,IAAMsG,EAAStG,GAAIqG,EAAIC,EAAStG,IAE3C,OAAOwG,QAKjB,WAII,QAASC,GAAcC,EAAOC,GAC1BA,EAASA,IAAYC,SAAS,EAAOC,YAAY,EAAOtC,WAAQR,GAChE,IAAI+C,GAAM7C,SAAS8C,YAAY,cAE/B,OADAD,GAAIE,gBAAiBN,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOpC,QAC/DuC,EANX,GAAmC,kBAAvB9C,QAAOyC,YAA6B,OAAO,CASvDA,GAAYtF,UAAY6C,OAAOiD,MAAM9F,UAErC6C,OAAOyC,YAAcA,MNiNnB,SAAU1G,EAAQwB,EAAqB5B,GAE7C,YAUA,SAASmF,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCATjFtF,EAAoBW,EAAEiB,EAAqB,IAAK,WAAa,MAAOoD,IAC9E,IAAIuC,GAA0CvH,EAAoB,IAC9DwH,EAAkDxH,EAAoBoB,EAAEmG,GACxEE,EAAwCzH,EAAoB,GAC5D0H,EAAyD1H,EAAoB,GAClG2H,EAAiB,WAAc,QAASC,GAAcjE,EAAKtD,GAAK,GAAIwH,MAAeC,GAAK,EAAUC,GAAK,EAAWC,MAAK5D,EAAW,KAAM,IAAK,GAAiC6D,GAA7BC,EAAKvE,EAAIwE,OAAOC,cAAmBN,GAAMG,EAAKC,EAAGG,QAAQC,QAAoBT,EAAKU,KAAKN,EAAGvH,QAAYL,GAAKwH,EAAK9D,SAAW1D,GAA3DyH,GAAK,IAAoE,MAAOU,GAAOT,GAAK,EAAMC,EAAKQ,EAAO,QAAU,KAAWV,GAAMI,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAIH,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUlE,EAAKtD,GAAK,GAAIuD,MAAMC,QAAQF,GAAQ,MAAOA,EAAY,IAAIwE,OAAOC,WAAYrH,QAAO4C,GAAQ,MAAOiE,GAAcjE,EAAKtD,EAAa,MAAM,IAAIiF,WAAU,4DAEllBE,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAItF,GAAI,EAAGA,EAAIsF,EAAM5B,OAAQ1D,IAAK,CAAE,GAAIuF,GAAaD,EAAMtF,EAAIuF,GAAW1E,WAAa0E,EAAW1E,aAAc,EAAO0E,EAAW3E,cAAe,EAAU,SAAW2E,KAAYA,EAAWC,UAAW,GAAM9E,OAAOC,eAAe0E,EAAQE,EAAWE,IAAKF,IAAiB,MAAO,UAAUP,EAAaU,EAAYC,GAAiJ,MAA9HD,IAAYN,EAAiBJ,EAAY7D,UAAWuE,GAAiBC,GAAaP,EAAiBJ,EAAaW,GAAqBX,MOzP1hBL,EPiQa,WOhQf,QAAAA,GAAYH,GAAMM,EAAAe,KAAAlB,GACdkB,KAAKrB,KAAOA,EACZqB,KAAKuC,MAAQvC,KAAKrB,KAAKC,cAAcjD,IAAUgB,OAC/CqD,KAAKwC,YAAYxC,KAAKrB,KAAKE,aAAa,cAAemB,KAAKrB,KAAK8D,QAAQC,KACzE1C,KAAK2C,cAAgB3C,KAAKrB,KAAKC,cAAcjD,IAAUiB,gBACvDoD,KAAK4C,WAAa5C,KAAK2C,cAAc/D,cAAcjD,IAAUmB,aAC7DkD,KAAK6C,KAAO7C,KAAK2C,cAAc/D,cAAcjD,IAAUoB,MACvDiD,KAAK8C,MAAQ1E,SAASQ,cAAT,IAA2BoB,KAAKrB,KAAK8D,QAAQM,SAC1D/C,KAAKgD,kBACLhD,KAAKiD,QAAU,KACfjD,KAAKkD,YACLlD,KAAKmD,YACLnD,KAAKoD,cAAqC,KAArBpD,KAAK8C,MAAMtI,OAAe6I,KAAKC,MAAMtD,KAAK8C,MAAMtI,OACrEwF,KAAKuD,aAAc,EAEnBvD,KAAKwD,OPqZT,MA/IAlE,GAAaR,IACTc,IAAK,gBACLpF,MAAO,WOrQK,GAAAiJ,GAAAzD,IACZzD,KAAU2D,QAAQ,SAACN,GACf6D,EAAKT,eAAepD,GAAO6D,EAAKd,cAAc/D,cAAiBjD,IAAUkB,UAA9C,IAA2D+C,QP2Q1FA,IAAK,cACLpF,MAAO,SAAqBkJ,GOxQG,GAAtBC,GAAsBD,EAAtBC,EAAGC,EAAmBF,EAAnBE,EAAGC,EAAgBH,EAAhBG,MAAOC,EAASJ,EAATI,OAClBC,GAAsB,CAE1B/D,MAAKgD,eAAea,MAAMG,YAAcC,KAAKC,KAAKL,GAClD7D,KAAKgD,eAAec,OAAOE,YAAcC,KAAKC,KAAKJ,IAE9CD,GAASC,IAAWxH,MAAuByH,GAC5C/D,KAAKrB,KAAKwF,UAAUC,IAAI/H,IAAUW,6BAClC+G,GAAsB,IAEtB/D,KAAKrB,KAAKwF,UAAUE,OAAOhI,IAAUW,6BACrC+G,GAAsB,GAGtB/D,KAAKkD,UAAYlD,KAAKsE,cACjBtE,KAAKmD,SAAS5H,eAAeyE,KAAKsE,eACnCtE,KAAKmD,SAASnD,KAAKsE,iBAEvBtE,KAAKmD,SAASnD,KAAKsE,aAAaC,OAASZ,EAAGC,GAC5C5D,KAAKmD,SAASnD,KAAKsE,aAAaE,MAAQX,EAAOC,OPiRnDlE,IAAK,oBACLpF,MAAO,WO9QS,GAAAiK,GAAAzE,IAChBA,MAAKuC,MAAMhE,iBAAiB,OAAQ,WAChC,GAAMmG,GAAOD,EAAKxB,QAAQ0B,SAC1BF,GAAKG,YAAYF,KAGrB1E,KAAK4C,WAAWrE,iBAAiB,SAAU,WACvCkG,EAAKH,YAAcG,EAAK7B,WAAWpI,MACnCiK,EAAKxB,QAAQ4B,UACbJ,EAAKK,gBAGT9E,KAAK6C,KAAKtE,iBAAiB,QAAS,SAACC,GACjCA,EAAEuG,iBACFN,EAAK3B,MAAMtI,MAAQ6I,KAAK2B,UAAUP,EAAKtB,ePoR3CvD,IAAK,cACLpF,MAAO,WOhRP,GAAM+F,GAAU1F,OAAO0F,QAAQP,KAAKkD,SAASlD,KAAKsE,cAC5CW,EAASzI,IAFL0I,GAAA,EAAAC,GAAA,EAAAC,MAAAlH,EAAA,KAIV,OAAAmH,GAAAC,EAA2B/E,EAA3B0B,OAAAC,cAAAgD,GAAAG,EAAAC,EAAAnD,QAAAC,MAAA8C,GAAA,EAAoC,IAAAK,GAAA9D,EAAA4D,EAAA7K,MAAA,GAAxBoF,EAAwB2F,EAAA,GAAnB/K,EAAmB+K,EAAA,EAChCN,GAAOrF,GAAOpF,GALR,MAAA8H,GAAA6C,GAAA,EAAAC,EAAA9C,EAAA,aAAA4C,GAAAI,EAAAE,QAAAF,EAAAE,SAAA,WAAAL,EAAA,KAAAC,IAQV,GAAIpF,KAAKmD,SAAS5H,eAAeyE,KAAKsE,aAAc,CAChD,GAAMmB,GAAczF,KAAKoD,cAAcpD,KAAKsE,YAE5CW,GAAOP,MACHf,EAAG8B,EAAYlB,MAAM,GACrBX,EAAG6B,EAAYlB,MAAM,GACrBV,MAAO4B,EAAYjB,KAAK,GACxBV,OAAQ2B,EAAYjB,KAAK,QAG7BS,GAAOP,KAAO,IAGlB1E,MAAKiD,QAAU,GAAIyC,KAAQ1F,KAAKuC,MAAO0C,MP2SvCrF,IAAK,OACLpF,MAAO,WOzSJ,GAAAmL,GAAA3F,IACHA,MAAK4F,eAEL,IAAM1C,GAAWG,KAAKC,MAAMtD,KAAKrB,KAAK8D,QAAQoD,cAC1C3C,GAASrF,OAAS,IAClBqF,EAAShD,QAAQ,SAAC4F,GACdH,EAAKzC,SAAS4C,EAAKpL,SACnBiL,EAAKzC,SAAS4C,EAAKpL,MAAMqL,YAAcD,EAAKE,UAAYF,EAAKhC,OAASgC,EAAKjC,MAAQoC,IACnFN,EAAKzC,SAAS4C,EAAKpL,MAAMwL,gBAAkBJ,EAAKjC,MAAQiC,EAAKjC,MAAQ,IACrE8B,EAAKzC,SAAS4C,EAAKpL,MAAMyL,iBAAmBL,EAAKhC,OAASgC,EAAKhC,OAAS,MAE5EsC,SAAwBpG,KAAK4C,WAAY5C,KAAKkD,UAE9ClD,KAAKsE,YAActE,KAAK4C,WAAWpI,OAInCwF,KAAKwC,YACLxC,KAAKuC,MAAM8D,IAAMrG,KAAKwC,WAGtBxC,KAAKoD,gBACLpD,KAAKmD,SAAWnD,KAAKoD,eAGzBpD,KAAK8E,cACL9E,KAAKsG,oBAELtG,KAAKuD,aAAc,EACnBvD,KAAKrB,KAAK8D,QAAQc,aAAc,MP8S7BzE,MAOL,SAAU5E,EAAQwB,EAAqB5B,GAE7C,YQlbA,SAASsM,GAAwBG,EAAQ7B,GACrC,GAAM8B,GAAe3L,OAAO6F,KAAKgE,EACjC6B,GAAOE,UAAY,GAEnBD,EAAatG,QAAQ,SAACxF,EAAMP,GACxB,GAAMuM,GAAStI,SAASuI,cAAc,SACtCD,GAAOlM,MAAQE,EACfgM,EAAO1C,YAActJ,EAEX,IAANP,IACAuM,EAAOE,UAAW,GAGtBL,EAAOM,YAAYH,KAGvBH,EAAOO,SAAmC,IAAxBN,EAAa3I,OAhBnC/D,EAAAW,EAAAiB,EAAA,qBAAA0K,MR2cM,SAAUlM,EAAQwB,EAAqB5B,GAE7C,YAOA,SAAS0D,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAItD,GAAI,EAAGyD,EAAOF,MAAMD,EAAII,QAAS1D,EAAIsD,EAAII,OAAQ1D,IAAOyD,EAAKzD,GAAKsD,EAAItD,EAAM,OAAOyD,GAAe,MAAOF,OAAMI,KAAKL,GS/cnL,QAAS2C,GAAW2G,GAcvB,QAASC,KACL,GAAIC,EAAYzM,MAAM0M,OAAOrJ,OAAS,EAAG,CACrC,GAAMsJ,GAAgBC,EAAKC,OAAOJ,EAAYzM,MAC9C8M,UAAaC,EAAQJ,OAErBK,UAAYD,GAIpB,QAASE,KACLR,EAAYzM,MAAQ,GACpBgN,SAAYD,GAxBhB,GAAMG,GAAUrE,KAAKC,MAAMyD,EAAUY,aAAa9L,IAAWM,WAEvDyL,EAAoBC,EAA2BH,GAE/CH,cAAaR,EAAUzI,iBAAiB3C,IAAUK,kBAClDoL,EAAOU,EAASF,GAEhBX,EAAcF,EAAUnI,cAAcjD,IAAUI,gBACtDkL,GAAY1I,iBAAiB,QAASyI,GAEZD,EAAUnI,cAAcjD,IAAUM,iBAC1CsC,iBAAiB,QAASkJ,GAiBhD,QAASI,GAA2BH,GAChC,MAAOA,GAAQK,IAAI,SAAArE,GAAA,OACfhJ,KADegJ,EAAEhJ,KAEjBsN,UAAWC,EAFIvE,EAAQwE,UAM/B,QAASD,GAA8BE,GACnC,GAAIH,GAAYG,EAEVC,EAAqBJ,EAAUK,YAAY,KAKjD,QAJ4B,IAAxBD,IACAJ,EAAYA,EAAUM,UAAUF,EAAqB,IAGlDJ,EAAUO,QAAQ,WAAY,IAGzC,QAAST,GAASU,GACd,MAAO,IAAIC,KAAKD,GACZ9H,OACIhG,KAAM,OACNgO,OAAQ,KAERhO,KAAM,YACNgO,OAAQ,KAEZC,GAAI,OACJC,UAAW,GACXC,YAAY,IT+YanN,EAAuB,EAAI0E,CACvC,IAAI0I,GAAwChP,EAAoB,IAC5DiP,EAAgDjP,EAAoBoB,EAAE4N,GACtEvH,EAAwCzH,EAAoB,GAC5DkP,EAA6ClP,EAAoB,GACjEmP,EAA8CnP,EAAoB,IA4ErF,SAAUI,EAAQwB,EAAqB5B,GAE7C,YU/hBO,SAAS0N,GAAY0B,GACxBA,EAAYhJ,QAAQ,SAACiJ,GACjBA,EAAKhF,UAAUE,OAAOzI,IAAQM,yBAJtCR,EAAA,EAAA8L,CAAA,IAAAzI,GAAAjF,EAAA,IV8iBM,SAAUI,EAAQwB,EAAqB5B,GAE7C,YW9iBO,SAASwN,GAAa4B,EAAa/B,GACtC+B,EAAYhJ,QAAQ,SAACiJ,GACjB,GAAMC,GAASD,EAAKxB,aAAa9L,IAAWO,QAExC+K,GAAckC,SAASD,GACvBD,EAAKhF,UAAUE,OAAOzI,IAAQM,uBAE9BiN,EAAKhF,UAAUC,IAAIxI,IAAQM,yBATvCR,EAAA,EAAA4L,CAAA,IAAAvI,GAAAjF,EAAA,IXmkBM,SAAUI,EAAQwB,EAAqB5B,GAE7C,YYhkBA,SAAS0J,KACLzD,IAAgByD,OAChBzF,WAPJlD,OAAAC,eAAAY,EAAA,cAAAlB,OAAA,OAAA8O,GAAAxP,EAAA,GAAAyP,GAAAzP,EAAAoB,EAAAoO,GAAAxP,EAAA,IAAA0P,EAAA1P,EAAA,EAW4B,aAAxBsE,SAASqL,WACTjG,IAEApF,SAASG,iBAAiB,mBAAoB,WAC1CiF,OZilBF,SAAUtJ,EAAQD,EAASH,IatlBjC,SAAA4P,EAAAC,GAC8DzP,EAAAD,QAAA0P,KAG7D3J,EAAA,WAAoB,YAErB,SAAA4J,GAAApJ,GAWA,OATAoJ,EADA,kBAAA3H,SAAA,gBAAAA,QAAAC,SACA,SAAA1B,GACA,aAAAA,IAGA,SAAAA,GACA,MAAAA,IAAA,kBAAAyB,SAAAzB,EAAAqJ,cAAA5H,QAAAzB,IAAAyB,OAAA3G,UAAA,eAAAkF,KAIAA,GAGA,QAAAvB,GAAAC,EAAAC,GACA,KAAAD,YAAAC,IACA,SAAAC,WAAA,qCAIA,QAAA0K,GAAAtK,EAAAC,GACA,OAAAtF,GAAA,EAAmBA,EAAAsF,EAAA5B,OAAkB1D,IAAA,CACrC,GAAAuF,GAAAD,EAAAtF,EACAuF,GAAA1E,WAAA0E,EAAA1E,aAAA,EACA0E,EAAA3E,cAAA,EACA,SAAA2E,OAAAC,UAAA,GACA9E,OAAAC,eAAA0E,EAAAE,EAAAE,IAAAF,IAIA,QAAAJ,GAAAH,EAAAU,EAAAC,GAGA,MAFAD,IAAAiK,EAAA3K,EAAA7D,UAAAuE,GACAC,GAAAgK,EAAA3K,EAAAW,GACAX,EAGA,QAAA4K,GAAAvJ,EAAAZ,EAAApF,GAYA,MAXAoF,KAAAY,GACA3F,OAAAC,eAAA0F,EAAAZ,GACApF,QACAQ,YAAA,EACAD,cAAA,EACA4E,UAAA,IAGAa,EAAAZ,GAAApF,EAGAgG,EAGA,QAAAwJ,GAAA5O,EAAA6O,GACA,GAAAvJ,GAAA7F,OAAA6F,KAAAtF,EAEA,IAAAP,OAAAqP,sBAAA,CACA,GAAAC,GAAAtP,OAAAqP,sBAAA9O,EACA6O,KAAAE,IAAAC,OAAA,SAAAC,GACA,MAAAxP,QAAAyP,yBAAAlP,EAAAiP,GAAArP,cAEA0F,EAAA2B,KAAAkI,MAAA7J,EAAAyJ,GAGA,MAAAzJ,GAGA,QAAA8J,GAAAhL,GACA,OAAArF,GAAA,EAAmBA,EAAA8D,UAAAJ,OAAsB1D,IAAA,CACzC,GAAAsQ,GAAA,MAAAxM,UAAA9D,GAAA8D,UAAA9D,KAEAA,GAAA,EACA6P,EAAAS,GAAA,GAAAvK,QAAA,SAAAN,GACAmK,EAAAvK,EAAAI,EAAA6K,EAAA7K,MAEO/E,OAAA6P,0BACP7P,OAAA0E,iBAAAC,EAAA3E,OAAA6P,0BAAAD,IAEAT,EAAAS,GAAAvK,QAAA,SAAAN,GACA/E,OAAAC,eAAA0E,EAAAI,EAAA/E,OAAAyP,yBAAAG,EAAA7K,MAKA,MAAAJ,GAGA,QAAAhC,GAAAC,GACA,MAAAkN,GAAAlN,IAAAmN,EAAAnN,IAAAoN,IAGA,QAAAF,GAAAlN,GACA,GAAAC,MAAAC,QAAAF,GAAA,CACA,OAAAtD,GAAA,EAAAyD,EAAA,GAAAF,OAAAD,EAAAI,QAAmD1D,EAAAsD,EAAAI,OAAgB1D,IAAAyD,EAAAzD,GAAAsD,EAAAtD,EAEnE,OAAAyD,IAIA,QAAAgN,GAAAE,GACA,GAAA7I,OAAAC,WAAArH,QAAAiQ,IAAA,uBAAAjQ,OAAAS,UAAAyP,SAAA1Q,KAAAyQ,GAAA,MAAApN,OAAAI,KAAAgN,GAGA,QAAAD,KACA,SAAAzL,WAAA,mDAsJA,QAAA4L,GAAAxQ,GACA,sBAAAA,KAAAyQ,GAAAzQ,GAiBA,QAAA0Q,GAAA1Q,GACA,gBAAAA,EAQA,QAAA2Q,GAAA3Q,GACA,iBAAAoP,EAAApP,IAAA,OAAAA,EASA,QAAA4Q,GAAA5Q,GACA,IAAA2Q,EAAA3Q,GACA,QAGA,KACA,GAAA6Q,GAAA7Q,EAAAqP,YACAvO,EAAA+P,EAAA/P,SACA,OAAA+P,IAAA/P,GAAAC,GAAAlB,KAAAiB,EAAA,iBACK,MAAAgQ,GACL,UASA,QAAAC,GAAA/Q,GACA,wBAAAA,GASA,QAAAgR,GAAAhR,GACA,MAAAkD,OAAAI,KAAAJ,MAAAI,KAAAtD,GAAAiR,GAAApR,KAAAG,GASA,QAAA0F,GAAAwE,EAAAgH,GAeA,MAdAhH,IAAA6G,EAAAG,KACAhO,MAAAC,QAAA+G,IAAAsG,EAAAtG,EAAA7G,QAGA2N,EAAA9G,GAAAxE,QAAA,SAAA1F,EAAAoF,GACA8L,EAAArR,KAAAqK,EAAAlK,EAAAoF,EAAA8E,KAESyG,EAAAzG,IACT7J,OAAA6F,KAAAgE,GAAAxE,QAAA,SAAAN,GACA8L,EAAArR,KAAAqK,IAAA9E,KAAA8E,MAKAA,EAmCA,QAAAiH,GAAAnR,GACA,GAAAoR,GAAA3N,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,OACA,OAAA4N,IAAAC,KAAAtR,GAAAyJ,KAAA8H,MAAAvR,EAAAoR,KAAApR,EASA,QAAAwR,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAE,KACAjM,GAAAgM,EAAA,SAAA1R,EAAAa,GACA+Q,GAAAN,KAAAzQ,IAAA2P,EAAAxQ,KACAA,EAAA,GAAA6R,OAAA7R,EAAA,OAGA2R,EAAA9Q,GAAAb,IAUA,QAAA8R,GAAAL,EAAAzR,GACA,MAAAyR,GAAA9H,UAAA8H,EAAA9H,UAAAoI,SAAA/R,GAAAyR,EAAAjE,UAAAwE,QAAAhS,IAAA,EAQA,QAAAiS,GAAAR,EAAAzR,GACA,GAAAA,EAAA,CAIA,GAAAwQ,EAAAiB,EAAApO,QAIA,WAHAqC,GAAA+L,EAAA,SAAAS,GACAD,EAAAC,EAAAlS,IAKA,IAAAyR,EAAA9H,UAEA,WADA8H,GAAA9H,UAAAC,IAAA5J,EAIA,IAAAwN,GAAAiE,EAAAjE,UAAAd,MAEAc,GAEKA,EAAAwE,QAAAhS,GAAA,IACLyR,EAAAjE,UAAA,GAAAqE,OAAArE,EAAA,KAAAqE,OAAA7R,IAFAyR,EAAAjE,UAAAxN,GAWA,QAAAmS,GAAAV,EAAAzR,GACA,GAAAA,EAIA,MAAAwQ,GAAAiB,EAAApO,YACAqC,GAAA+L,EAAA,SAAAS,GACAC,EAAAD,EAAAlS,KAKAyR,EAAA9H,cACA8H,GAAA9H,UAAAE,OAAA7J,QAIAyR,EAAAjE,UAAAwE,QAAAhS,IAAA,IACAyR,EAAAjE,UAAAiE,EAAAjE,UAAAO,QAAA/N,EAAA,MAUA,QAAAoS,GAAAX,EAAAzR,EAAAqS,GACA,GAAArS,EAIA,MAAAwQ,GAAAiB,EAAApO,YACAqC,GAAA+L,EAAA,SAAAS,GACAE,EAAAF,EAAAlS,EAAAqS,UAMAA,EACAJ,EAAAR,EAAAzR,GAEAmS,EAAAV,EAAAzR,IAUA,QAAAsS,GAAAtS,GACA,MAAAA,GAAA+N,QAAAwE,GAAA,SAAAC,cASA,QAAArI,GAAAsH,EAAAvR,GACA,MAAAyQ,GAAAc,EAAAvR,IACAuR,EAAAvR,GAGAuR,EAAAxJ,QACAwJ,EAAAxJ,QAAA/H,GAGAuR,EAAAtE,aAAA,QAAA0E,OAAAS,EAAApS,KASA,QAAAuS,GAAAhB,EAAAvR,EAAAgK,GACAyG,EAAAzG,GACAuH,EAAAvR,GAAAgK,EACKuH,EAAAxJ,QACLwJ,EAAAxJ,QAAA/H,GAAAgK,EAEAuH,EAAAiB,aAAA,QAAAb,OAAAS,EAAApS,IAAAgK,GASA,QAAAyI,GAAAlB,EAAAvR,GACA,GAAAyQ,EAAAc,EAAAvR,IACA,UACAuR,GAAAvR,GACO,MAAA4Q,GACPW,EAAAvR,OAAAwD,OAEK,IAAA+N,EAAAxJ,QAEL,UACAwJ,GAAAxJ,QAAA/H,GACO,MAAA4Q,GACPW,EAAAxJ,QAAA/H,OAAAwD,OAGA+N,GAAAmB,gBAAA,QAAAf,OAAAS,EAAApS,KA2CA,QAAA2S,GAAApB,EAAAqB,EAAAC,GACA,GAAAC,GAAAvP,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,MACAwP,EAAAF,CACAD,GAAApG,OAAAwG,MAAAC,IAAAzN,QAAA,SAAAW,GACA,IAAA+M,GAAA,CACA,GAAAC,GAAA5B,EAAA4B,SAEAA,MAAAhN,IAAAgN,EAAAhN,GAAA0M,KACAE,EAAAI,EAAAhN,GAAA0M,SACAM,GAAAhN,GAAA0M,GAEA,IAAA1S,OAAA6F,KAAAmN,EAAAhN,IAAAhD,cACAgQ,GAAAhN,GAGA,IAAAhG,OAAA6F,KAAAmN,GAAAhQ,cACAoO,GAAA4B,WAKA5B,EAAA6B,oBAAAjN,EAAA4M,EAAAD,KAWA,QAAAO,GAAA9B,EAAAqB,EAAAC,GACA,GAAAC,GAAAvP,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,MACA+P,EAAAT,CACAD,GAAApG,OAAAwG,MAAAC,IAAAzN,QAAA,SAAAW,GACA,GAAA2M,EAAAS,OAAAL,GAAA,CACA,GAAAM,GAAAjC,EAAA4B,UACAA,MAAA,KAAAK,KAA0DA,CAE1DF,GAAA,iBACAH,GAAAhN,GAAA0M,GACAtB,EAAA6B,oBAAAjN,EAAAmN,EAAAR,EAEA,QAAAW,GAAAlQ,UAAAJ,OAAAuQ,EAAA,GAAA1Q,OAAAyQ,GAAAE,EAAA,EAAgFA,EAAAF,EAAeE,IAC/FD,EAAAC,GAAApQ,UAAAoQ,EAGAd,GAAAhD,MAAA0B,EAAAmC,IAGAP,EAAAhN,KACAgN,EAAAhN,OAGAgN,EAAAhN,GAAA0M,IACAtB,EAAA6B,oBAAAjN,EAAAgN,EAAAhN,GAAA0M,GAAAC,GAGAK,EAAAhN,GAAA0M,GAAAS,EACA/B,EAAA4B,YAGA5B,EAAA1N,iBAAAsC,EAAAmN,EAAAR,KAWA,QAAAc,GAAArC,EAAAqB,EAAA5I,GACA,GAAA7D,EAaA,OAXA0K,GAAAnK,QAAAmK,EAAA3K,aACAC,EAAA,GAAAD,aAAA0M,GACA5O,OAAAgG,EACA3D,SAAA,EACAC,YAAA,KAGAH,EAAAzC,SAAA8C,YAAA,eACAL,EAAAM,gBAAAmM,GAAA,KAAA5I,IAGAuH,EAAAqC,cAAAzN,GAQA,QAAA0N,GAAAtC,GACA,GAAAuC,GAAAvC,EAAAwC,uBACA,QACAC,KAAAF,EAAAE,MAAAvQ,OAAAwQ,YAAAvQ,SAAAwQ,gBAAAC,YACAC,IAAAN,EAAAM,KAAA3Q,OAAA4Q,YAAA3Q,SAAAwQ,gBAAAI,YAWA,QAAAC,GAAAC,GACA,GAAAC,GAAAD,EAAAE,MAAAC,GACA,eAAAF,MAAA,KAAAG,GAAAC,UAAAJ,EAAA,KAAAG,GAAAE,UAAAL,EAAA,KAAAG,GAAAG,MAQA,QAAAC,GAAAR,GACA,GAAAS,GAAA,aAAAtD,QAAA,GAAAuD,OAAAC,UACA,OAAAX,KAAA,IAAAA,EAAA1C,QAAA,cAAAmD,EAQA,QAAAG,GAAApM,GACA,GAAAqM,GAAArM,EAAAqM,OACAC,EAAAtM,EAAAsM,OACAC,EAAAvM,EAAAuM,OACAC,EAAAxM,EAAAwM,WACAC,EAAAzM,EAAAyM,WACAC,IAEApF,GAAAkF,IAAA,IAAAA,GACAE,EAAA/N,KAAA,cAAAgK,OAAA6D,EAAA,QAGAlF,EAAAmF,IAAA,IAAAA,GACAC,EAAA/N,KAAA,cAAAgK,OAAA8D,EAAA,QAIAnF,EAAA+E,IAAA,IAAAA,GACAK,EAAA/N,KAAA,UAAAgK,OAAA0D,EAAA,SAGA/E,EAAAgF,IAAA,IAAAA,GACAI,EAAA/N,KAAA,UAAAgK,OAAA2D,EAAA,MAGAhF,EAAAiF,IAAA,IAAAA,GACAG,EAAA/N,KAAA,UAAAgK,OAAA4D,EAAA,KAGA,IAAAI,GAAAD,EAAAvS,OAAAuS,EAAAE,KAAA,WACA,QACAC,gBAAAF,EACAG,YAAAH,EACAA,aASA,QAAAI,GAAAC,GACA,GAAAC,GAAAnG,KAAqCkG,GAErCE,IAiBA,OAhBA1Q,GAAAwQ,EAAA,SAAAG,EAAAC,SACAH,GAAAG,GACA5Q,EAAAyQ,EAAA,SAAAI,GACA,GAAAC,GAAA/M,KAAAgN,IAAAJ,EAAAK,OAAAH,EAAAG,QACAC,EAAAlN,KAAAgN,IAAAJ,EAAAO,OAAAL,EAAAK,QACAC,EAAApN,KAAAgN,IAAAJ,EAAAS,KAAAP,EAAAO,MACAC,EAAAtN,KAAAgN,IAAAJ,EAAAW,KAAAT,EAAAS,MACAC,EAAAxN,KAAAyN,KAAAV,IAAAG,KACAQ,EAAA1N,KAAAyN,KAAAL,IAAAE,KACAK,GAAAD,EAAAF,IACAb,GAAAvO,KAAAuP,OAGAhB,EAAAiB,KAAA,SAAAC,EAAAC,GACA,MAAA9N,MAAAgN,IAAAa,GAAA7N,KAAAgN,IAAAc,KAEAnB,EAAA,GASA,QAAAoB,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAE,MACAC,EAAAH,EAAAG,MACAC,GACAf,KAAAa,EACAX,KAAAY,EAEA,OAAAF,GAAAG,EAAA7H,GACA0G,OAAAiB,EACAf,OAAAgB,GACKC,GAQL,QAAAC,GAAA5B,GACA,GAAAyB,GAAA,EACAC,EAAA,EACAG,EAAA,CAUA,OATArS,GAAAwQ,EAAA,SAAA8B,GACA,GAAAtB,GAAAsB,EAAAtB,OACAE,EAAAoB,EAAApB,MACAe,IAAAjB,EACAkB,GAAAhB,EACAmB,GAAA,IAEAJ,GAAAI,EACAH,GAAAG,GAEAJ,QACAC,SAUA,QAAAK,GAAAC,GAEA,GAAA3M,GAAA2M,EAAA3M,YACAjC,EAAA4O,EAAA5O,OACAD,EAAA6O,EAAA7O,MACAyJ,EAAArP,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,aACA0U,EAAAC,GAAA/O,GACAgP,EAAAD,GAAA9O,EAEA,IAAA6O,GAAAE,EAAA,CACA,GAAAC,GAAAhP,EAAAiC,CAEA,aAAAuH,GAAAwF,EAAAjP,GAAA,UAAAyJ,GAAAwF,EAAAjP,EACAC,EAAAD,EAAAkC,EAEAlC,EAAAC,EAAAiC,MAEK4M,GACL7O,EAAAD,EAAAkC,EACK8M,IACLhP,EAAAC,EAAAiC,EAGA,QACAlC,QACAC,UASA,QAAAiP,GAAAC,GACA,GAAAnP,GAAAmP,EAAAnP,MACAC,EAAAkP,EAAAlP,OACAmP,EAAAD,EAAAC,MAGA,UAFAA,EAAAhP,KAAAgN,IAAAgC,GAAA,KAGA,OACApP,MAAAC,EACAA,OAAAD,EAIA,IAAAqP,GAAAD,EAAA,GAAAhP,KAAAkP,GAAA,IACAC,EAAAnP,KAAAoP,IAAAH,GACAI,EAAArP,KAAAsP,IAAAL,GACAM,EAAA3P,EAAAyP,EAAAxP,EAAAsP,EACAK,EAAA5P,EAAAuP,EAAAtP,EAAAwP,CACA,OAAAL,GAAA,IACApP,MAAA4P,EACA3P,OAAA0P,IAEA3P,MAAA2P,EACA1P,OAAA2P,GAYA,QAAAC,GAAAnR,EAAAoR,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAA5N,YACAgO,EAAAJ,EAAAK,aACAC,EAAAN,EAAAO,cACAC,EAAAR,EAAA5D,OACAA,MAAA,KAAAoE,EAAA,EAAAA,EACAC,EAAAT,EAAA3D,OACAA,MAAA,KAAAoE,EAAA,EAAAA,EACAC,EAAAV,EAAA1D,OACAA,MAAA,KAAAoE,EAAA,EAAAA,EACAtO,EAAA6N,EAAA7N,YACAiO,EAAAJ,EAAAI,aACAE,EAAAN,EAAAM,cACAI,EAAAT,EAAAU,UACAA,MAAA,KAAAD,EAAA,cAAAA,EACAE,EAAAX,EAAAY,sBACAA,MAAA,KAAAD,KACAE,EAAAb,EAAAc,sBACAA,MAAA,KAAAD,EAAA,MAAAA,EACAE,EAAAf,EAAAgB,SACAA,MAAA,KAAAD,EAAAE,IAAAF,EACAG,EAAAlB,EAAAmB,UACAA,MAAA,KAAAD,EAAAD,IAAAC,EACAE,EAAApB,EAAAqB,SACAA,MAAA,KAAAD,EAAA,EAAAA,EACAE,EAAAtB,EAAAuB,UACAA,MAAA,KAAAD,EAAA,EAAAA,EACAE,EAAAjX,SAAAuI,cAAA,UACA2O,EAAAD,EAAAE,WAAA,MACAC,EAAA/C,GACA1M,cACAlC,MAAAgR,EACA/Q,OAAAkR,IAEAS,EAAAhD,GACA1M,cACAlC,MAAAqR,EACApR,OAAAsR,GACK,SACLvR,EAAAI,KAAAyR,IAAAF,EAAA3R,MAAAI,KAAA0R,IAAAF,EAAA5R,MAAAmQ,IACAlQ,EAAAG,KAAAyR,IAAAF,EAAA1R,OAAAG,KAAA0R,IAAAF,EAAA3R,OAAAoQ,IAGA0B,EAAAnD,GACA1M,YAAA+N,EACAjQ,MAAAgR,EACA/Q,OAAAkR,IAEAa,EAAApD,GACA1M,YAAA+N,EACAjQ,MAAAqR,EACApR,OAAAsR,GACK,SACLU,EAAA7R,KAAAyR,IAAAE,EAAA/R,MAAAI,KAAA0R,IAAAE,EAAAhS,MAAAkQ,IACAgC,EAAA9R,KAAAyR,IAAAE,EAAA9R,OAAAG,KAAA0R,IAAAE,EAAA/R,OAAAmQ,IACAnT,IAAAgV,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAeA,OAdAV,GAAAxR,MAAA8H,EAAA9H,GACAwR,EAAAvR,OAAA6H,EAAA7H,GACAwR,EAAAU,UAAAzB,EACAe,EAAAW,SAAA,IAAApS,EAAAC,GACAwR,EAAAzS,OACAyS,EAAAY,UAAArS,EAAA,EAAAC,EAAA,GACAwR,EAAAvF,SAAA9L,KAAAkP,GAAA,KACAmC,EAAAa,MAAAnG,EAAAC,GACAqF,EAAAb,wBACAa,EAAAX,wBACAW,EAAAc,UAAA7L,MAAA+K,GAAA/S,GAAA8J,OAAA7O,EAAAsD,EAAAiH,IAAA,SAAAsO,GACA,MAAApS,MAAAqS,MAAA3K,EAAA0K,SAEAf,EAAAiB,UACAlB,EAWA,QAAAmB,GAAAC,EAAAlS,EAAA1G,GACA,GAAA6Y,GAAA,EACA7Y,IAAA0G,CAEA,QAAApK,GAAAoK,EAAuBpK,EAAA0D,EAAY1D,GAAA,EACnCuc,GAAAC,GAAAF,EAAAG,SAAAzc,GAGA,OAAAuc,GASA,QAAAG,GAAAC,GACA,GAAAC,GAAAD,EAAAvO,QAAAyO,GAAA,IACAC,EAAAC,KAAAH,GACAI,EAAA,GAAAC,aAAAH,EAAApZ,QACAwZ,EAAA,GAAAC,YAAAH,EAIA,OAHAjX,GAAAmX,EAAA,SAAA7c,EAAAL,GACAkd,EAAAld,GAAA8c,EAAAM,WAAApd,KAEAgd,EASA,QAAAK,GAAAL,EAAAM,GAMA,IALA,GAAAC,MAGAL,EAAA,GAAAC,YAAAH,GAEAE,EAAAxZ,OAAA,GAGA6Z,EAAArV,KAAAsU,GAAApM,MAAA,KAAAiB,EAAA6L,EAAAM,SAAA,EANA,SAOAN,IAAAM,SAPA,KAUA,eAAAtL,OAAAoL,EAAA,YAAsCpL,OAAAuL,KAAAF,EAAApH,KAAA,MAQtC,QAAAuH,GAAAV,GACA,GACAW,GADArB,EAAA,GAAAsB,UAAAZ,EAGA,KACA,GAAAa,GACAC,EACAC,CAEA,UAAAzB,EAAAG,SAAA,UAAAH,EAAAG,SAAA,GAIA,IAHA,GAAA/Y,GAAA4Y,EAAA0B,WACAC,EAAA,EAEAA,EAAA,EAAAva,GAAA,CACA,SAAA4Y,EAAAG,SAAAwB,IAAA,MAAA3B,EAAAG,SAAAwB,EAAA,IACAH,EAAAG,CACA,OAGAA,GAAA,EAIA,GAAAH,EAAA,CACA,GAAAI,GAAAJ,EAAA,EACAK,EAAAL,EAAA,EAEA,aAAAzB,EAAAC,EAAA4B,EAAA,IACA,GAAAE,GAAA9B,EAAA+B,UAAAF,EAGA,MAFAN,EAAA,QAAAO,IAEA,QAAAA,IAGA,KAAA9B,EAAA+B,UAAAF,EAAA,EAAAN,GAAA,CACA,GAAAS,GAAAhC,EAAAiC,UAAAJ,EAAA,EAAAN,EAEAS,IAAA,IACAP,EAAAI,EAAAG,KAOA,GAAAP,EAAA,CACA,GAEAS,GAEAxe,EAJAye,EAAAnC,EAAA+B,UAAAN,EAAAF,EAMA,KAAA7d,EAAA,EAAmBA,EAAAye,EAAaze,GAAA,EAGhC,GAFAwe,EAAAT,EAAA,GAAA/d,EAAA,EAEA,MAAAsc,EAAA+B,UAAAG,EAAAX,GAEA,CAEAW,GAAA,EAEAb,EAAArB,EAAA+B,UAAAG,EAAAX,GAEAvB,EAAAoC,UAAAF,EAAA,EAAAX,EACA,SAIK,MAAA1M,GACLwM,EAAA,EAGA,MAAAA,GAQA,QAAAgB,GAAAhB,GACA,GAAA/H,GAAA,EACAC,EAAA,EACAC,EAAA,CAEA,QAAA6H,GAEA,OACA9H,GAAA,CACA,MAGA,QACAD,GAAA,GACA,MAGA,QACAE,GAAA,CACA,MAGA,QACAF,EAAA,GACAE,GAAA,CACA,MAGA,QACAF,EAAA,EACA,MAGA,QACAA,EAAA,GACAC,GAAA,CACA,MAGA,QACAD,GAAA,GAMA,OACAA,SACAC,SACAC,UAnjCA,GAAA8I,GAAA,mBAAA5a,aAAA,KAAAA,OAAAC,SACA4a,EAAAD,EAAA5a,UACA8a,IAAAF,GAAA,gBAAAC,GAAA5a,SAAAwQ,gBACAsK,IAAAH,GAAA,gBAAAC,GAgBAG,EAAA,GAAA9M,OAfA,UAeA,SACA+M,EAAA,GAAA/M,OAhBA,UAgBA,aACAgN,EAAA,GAAAhN,OAjBA,UAiBA,WACAiN,EAAA,GAAAjN,OAlBA,UAkBA,SACAkN,GAAA,GAAAlN,OAnBA,UAmBA,cACAmN,GAAA,GAAAnN,OApBA,UAoBA,UACAoN,GAAA,GAAApN,OArBA,UAqBA,SAEAqN,GAAA,GAAArN,OAvBA,UAuBA,UACAsN,GAAA,GAAAtN,OAxBA,UAwBA,WAWAuN,GAAAX,EAAA,yBACAY,GAAAZ,EAAA,wBACAa,GAAAb,EAAA,iCACAc,GAAAb,EAAA,cAAAU,GACAI,GAAAd,EAAA,cAAAW,GACAI,GAAAf,EAAA,0BAAAY,GAQAI,GAAA,2CACAC,GAAA,SACAC,GAAA,4BACAC,GAAA,gBAMAC,IAEArd,SAAA,EAGAsd,SApCA,OAuCAC,mBAAAvU,IAEAF,YAAAE,IAEAvB,KAAA,KAEA+V,QAAA,GAEAC,YAAA,EAEAnE,SAAA,EAEAoE,kBAAA,EAEAC,kBAAA,EAEAC,OAAA,EAEAC,QAAA,EAEAC,QAAA,EAEAC,WAAA,EAEAC,YAAA,EAEAC,UAAA,EAEAC,aAAA,GAEAje,SAAA,EAEAC,WAAA,EAEAC,UAAA,EAEAC,UAAA,EAEAC,aAAA,EAEAC,aAAA,EAEA6d,eAAA,GAEAC,gBAAA,EAEAC,kBAAA,EAEAC,0BAAA,EAEAC,eAAA,EACAC,gBAAA,EACAvV,gBAAA,EACAC,iBAAA,EACAuV,kBAAA,IACAC,mBAAA,IAEAC,MAAA,KACAC,UAAA,KACAC,SAAA,KACAC,QAAA,KACAC,KAAA,KACAC,KAAA,MASAhR,GAAAiR,OAAAjR,OAAA+N,EAAA/N,MAgBA2H,GAAA,SAAApY,GACA,MAAAA,GAAA,GAAAA,EAAAsa,KAoBAvZ,GAAAV,OAAAS,UAAAC,eA6BAkQ,GAAA/N,MAAApC,UAAAmQ,MAyCA0Q,GAAAthB,OAAAshB,QAAA,SAAA3c,GACA,OAAA4c,GAAAne,UAAAJ,OAAAuQ,EAAA,GAAA1Q,OAAA0e,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAA0FA,EAAAD,EAAaC,IACvGjO,EAAAiO,EAAA,GAAApe,UAAAoe,EAaA,OAVAlR,GAAA3L,IAAA4O,EAAAvQ,OAAA,GACAuQ,EAAAlO,QAAA,SAAAoc,GACAnR,EAAAmR,IACAzhB,OAAA6F,KAAA4b,GAAApc,QAAA,SAAAN,GACAJ,EAAAI,GAAA0c,EAAA1c,OAMAJ,GAEAqM,GAAA,uBAaAO,GAAA,+CA+GAW,GAAA,oBAoEAY,GAAA,QAEAC,GAAA,WACA,GAAA2O,IAAA,CAEA,IAAAxD,EAAA,CACA,GAAA9K,IAAA,EAEAV,EAAA,aAEAC,EAAA3S,OAAAC,kBAA4C,QAC5CG,IAAA,WAEA,MADAshB,IAAA,EACAtO,GAQAuO,IAAA,SAAAhiB,GACAyT,EAAAzT,IAGAwe,GAAAza,iBAAA,OAAAgP,EAAAC,GACAwL,EAAAlL,oBAAA,OAAAP,EAAAC,GAGA,MAAA+O,MAkHAjN,GAAA0J,EAAA1J,SACAD,GAAA,iCA0RAsH,GAAA8F,OAAA9F,aAmBAK,GAAA,YAkLA0F,IACAA,OAAA,WACA1c,KAAA2c,gBACA3c,KAAA4c,aACA5c,KAAA6c,cACA7c,KAAA8c,eAEA9c,KAAA+c,SACA/c,KAAAgd,iBAGAL,cAAA,WACA,GAAA1Q,GAAAjM,KAAAiM,QACAuB,EAAAxN,KAAAwN,QACAxP,EAAAgC,KAAAhC,UACAiF,EAAAjD,KAAAiD,OACAwJ,GAAAxJ,EAAAoW,GACA1M,EAAAV,EAAAoN,EACA,IAAA4D,IACApZ,MAAAI,KAAA0R,IAAA3X,EAAAkf,YAAAhB,OAAA1O,EAAAkO,oBAAA,KACA5X,OAAAG,KAAA0R,IAAA3X,EAAAmf,aAAAjB,OAAA1O,EAAAmO,qBAAA,KAEA3b,MAAAid,gBACAjR,EAAA/I,GACAY,MAAAoZ,EAAApZ,MACAC,OAAAmZ,EAAAnZ,SAEA2I,EAAAR,EAAAoN,GACA1M,EAAA1J,EAAAoW,IAGAuD,WAAA,WACA,GAAAK,GAAAjd,KAAAid,cACAG,EAAApd,KAAAod,UACAngB,EAAA+C,KAAAwN,QAAAvQ,SACAogB,EAAApZ,KAAAgN,IAAAmM,EAAArN,QAAA,QACAiE,EAAAqJ,EAAAD,EAAAlJ,cAAAkJ,EAAApJ,aACAE,EAAAmJ,EAAAD,EAAApJ,aAAAoJ,EAAAlJ,cACAnO,EAAAiO,EAAAE,EACAoJ,EAAAL,EAAApZ,MACA0Z,EAAAN,EAAAnZ,MAEAmZ,GAAAnZ,OAAAiC,EAAAkX,EAAApZ,MACA,IAAA5G,EACAqgB,EAAAL,EAAAnZ,OAAAiC,EAEAwX,EAAAN,EAAApZ,MAAAkC,EAEO,IAAA9I,EACPsgB,EAAAN,EAAApZ,MAAAkC,EAEAuX,EAAAL,EAAAnZ,OAAAiC,CAGA,IAAAyX,IACAzX,cACAiO,eACAE,gBACArQ,MAAAyZ,EACAxZ,OAAAyZ,EAEAC,GAAA9O,MAAAuO,EAAApZ,MAAAyZ,GAAA,EACAE,EAAA1O,KAAAmO,EAAAnZ,OAAAyZ,GAAA,EACAC,EAAAC,QAAAD,EAAA9O,KACA8O,EAAAE,OAAAF,EAAA1O,IACA9O,KAAAwd,aACAxd,KAAA2d,QAAA,IAAA1gB,GAAA,IAAAA,EACA+C,KAAA4d,aAAA,MACA5d,KAAA6d,iBAAA1B,MAAuCiB,GACvCpd,KAAA8d,kBAAA3B,MAAwCqB,IAExCI,YAAA,SAAAG,EAAAC,GACA,GAAAxQ,GAAAxN,KAAAwN,QACAyP,EAAAjd,KAAAid,cACAO,EAAAxd,KAAAwd,WACAS,EAAAje,KAAAie,YACAhhB,EAAAuQ,EAAAvQ,SACA8I,EAAAyX,EAAAzX,YACAgX,EAAA/c,KAAA+c,SAAAkB,CAEA,IAAAF,EAAA,CACA,GAAAvC,GAAAU,OAAA1O,EAAAgO,iBAAA,EACAC,EAAAS,OAAA1O,EAAAiO,kBAAA,CAEAxe,GAAA,GACAue,EAAAvX,KAAA0R,IAAA6F,EAAAyB,EAAApZ,OACA4X,EAAAxX,KAAA0R,IAAA8F,EAAAwB,EAAAnZ,QAEA,IAAA7G,IACAwe,EAAA1V,EAAAyV,EACAA,EAAAC,EAAA1V,EAEA0V,EAAAD,EAAAzV,IAGS9I,EAAA,IACTue,EACAA,EAAAvX,KAAA0R,IAAA6F,EAAAuB,EAAAkB,EAAApa,MAAA,GACW4X,EACXA,EAAAxX,KAAA0R,IAAA8F,EAAAsB,EAAAkB,EAAAna,OAAA,GACWiZ,IACXvB,EAAAyC,EAAApa,MACA4X,EAAAwC,EAAAna,OAEA2X,EAAA1V,EAAAyV,EACAA,EAAAC,EAAA1V,EAEA0V,EAAAD,EAAAzV,GAKA,IAAAmY,GAAAzL,GACA1M,cACAlC,MAAA2X,EACA1X,OAAA2X,GAGAD,GAAA0C,EAAAra,MACA4X,EAAAyC,EAAApa,OACA0Z,EAAAtI,SAAAsG,EACAgC,EAAApI,UAAAqG,EACA+B,EAAA3I,SAAAC,IACA0I,EAAAxI,UAAAF,IAGA,GAAAkJ,EACA,GAAA/gB,GAAA8f,EAAA,MACA,GAAAoB,GAAAlB,EAAApZ,MAAA2Z,EAAA3Z,MACAua,EAAAnB,EAAAnZ,OAAA0Z,EAAA1Z,MACA0Z,GAAAa,QAAApa,KAAAyR,IAAA,EAAAyI,GACAX,EAAAc,OAAAra,KAAAyR,IAAA,EAAA0I,GACAZ,EAAAe,QAAAta,KAAA0R,IAAA,EAAAwI,GACAX,EAAAgB,OAAAva,KAAA0R,IAAA,EAAAyI,GAEArB,GAAA/c,KAAA2d,UACAH,EAAAa,QAAApa,KAAAyR,IAAAuI,EAAAvP,KAAAuP,EAAAvP,MAAAuP,EAAApa,MAAA2Z,EAAA3Z,QACA2Z,EAAAc,OAAAra,KAAAyR,IAAAuI,EAAAnP,IAAAmP,EAAAnP,KAAAmP,EAAAna,OAAA0Z,EAAA1Z,SACA0Z,EAAAe,QAAAN,EAAAvP,KACA8O,EAAAgB,OAAAP,EAAAnP,IAEA,IAAA7R,IACAugB,EAAA3Z,OAAAoZ,EAAApZ,QACA2Z,EAAAa,QAAApa,KAAAyR,IAAA,EAAAyI,GACAX,EAAAe,QAAAta,KAAA0R,IAAA,EAAAwI,IAGAX,EAAA1Z,QAAAmZ,EAAAnZ,SACA0Z,EAAAc,OAAAra,KAAAyR,IAAA,EAAA0I,GACAZ,EAAAgB,OAAAva,KAAA0R,IAAA,EAAAyI,UAKAZ,GAAAa,SAAAb,EAAA3Z,MACA2Z,EAAAc,QAAAd,EAAA1Z,OACA0Z,EAAAe,QAAAtB,EAAApZ,MACA2Z,EAAAgB,OAAAvB,EAAAnZ,QAIAgZ,aAAA,SAAA2B,EAAAC,GACA,GAAAlB,GAAAxd,KAAAwd,WACAJ,EAAApd,KAAAod,SAEA,IAAAsB,EAAA,CACA,GAAAC,GAAA5L,GACAlP,MAAAuZ,EAAApJ,aAAA/P,KAAAgN,IAAAmM,EAAApN,QAAA,GACAlM,OAAAsZ,EAAAlJ,cAAAjQ,KAAAgN,IAAAmM,EAAAnN,QAAA,GACAgD,OAAAmK,EAAArN,QAAA,IAEAiE,EAAA2K,EAAA9a,MACAqQ,EAAAyK,EAAA7a,OAEAD,EAAA2Z,EAAA3Z,OAAAmQ,EAAAwJ,EAAAxJ,cACAlQ,EAAA0Z,EAAA1Z,QAAAoQ,EAAAsJ,EAAAtJ,cACAsJ,GAAA9O,OAAA7K,EAAA2Z,EAAA3Z,OAAA,EACA2Z,EAAA1O,MAAAhL,EAAA0Z,EAAA1Z,QAAA,EACA0Z,EAAA3Z,QACA2Z,EAAA1Z,SACA0Z,EAAAzX,YAAAiO,EAAAE,EACAsJ,EAAAxJ,eACAwJ,EAAAtJ,gBACAlU,KAAA4d,aAAA,OAGAJ,EAAA3Z,MAAA2Z,EAAA3I,UAAA2I,EAAA3Z,MAAA2Z,EAAAtI,YACAsI,EAAA9O,KAAA8O,EAAAC,UAGAD,EAAA1Z,OAAA0Z,EAAAxI,WAAAwI,EAAA1Z,OAAA0Z,EAAApI,aACAoI,EAAA1O,IAAA0O,EAAAE,QAGAF,EAAA3Z,MAAAI,KAAAyR,IAAAzR,KAAA0R,IAAA6H,EAAA3Z,MAAA2Z,EAAAtI,UAAAsI,EAAA3I,UACA2I,EAAA1Z,OAAAG,KAAAyR,IAAAzR,KAAA0R,IAAA6H,EAAA1Z,OAAA0Z,EAAApI,WAAAoI,EAAAxI,WACAhV,KAAA4d,aAAA,MACAJ,EAAA9O,KAAAzK,KAAAyR,IAAAzR,KAAA0R,IAAA6H,EAAA9O,KAAA8O,EAAAa,SAAAb,EAAAe,SACAf,EAAA1O,IAAA7K,KAAAyR,IAAAzR,KAAA0R,IAAA6H,EAAA1O,IAAA0O,EAAAc,QAAAd,EAAAgB,QACAhB,EAAAC,QAAAD,EAAA9O,KACA8O,EAAAE,OAAAF,EAAA1O,IACA9C,EAAAhM,KAAAqV,OAAA8G,IACAtY,MAAA2Z,EAAA3Z,MACAC,OAAA0Z,EAAA1Z,QACOgM,GACPI,WAAAsN,EAAA9O,KACAyB,WAAAqN,EAAA1O,QAEA9O,KAAA4e,YAAAH,GAEAze,KAAA+c,SAAA/c,KAAA2d,SACA3d,KAAA6e,cAAA,OAGAD,YAAA,SAAAH,GACA,GAAAjB,GAAAxd,KAAAwd,WACAJ,EAAApd,KAAAod,UACAvZ,EAAAuZ,EAAApJ,cAAAwJ,EAAA3Z,MAAA2Z,EAAAxJ,cACAlQ,EAAAsZ,EAAAlJ,eAAAsJ,EAAA1Z,OAAA0Z,EAAAtJ,cACAiI,IAAAiB,GACAvZ,QACAC,SACA4K,MAAA8O,EAAA3Z,SAAA,EACAiL,KAAA0O,EAAA1Z,UAAA,IAEAkI,EAAAhM,KAAAuC,MAAA4Z,IACAtY,MAAAuZ,EAAAvZ,MACAC,OAAAsZ,EAAAtZ,QACOgM,EAAAqM,IACPjM,WAAAkN,EAAA1O,KACAyB,WAAAiN,EAAAtO,KACOsO,MAEPqB,GACAze,KAAA8e,UAGAjC,YAAA,WACA,GAAArP,GAAAxN,KAAAwN,QACAgQ,EAAAxd,KAAAwd,WACAzX,EAAAyH,EAAAzH,aAAAyH,EAAAgN,mBACAW,EAAAe,OAAA1O,EAAA2N,eAAA,GACA8C,GACApa,MAAA2Z,EAAA3Z,MACAC,OAAA0Z,EAAA1Z,OAGAiC,KACAyX,EAAA1Z,OAAAiC,EAAAyX,EAAA3Z,MACAoa,EAAAna,OAAAma,EAAApa,MAAAkC,EAEAkY,EAAApa,MAAAoa,EAAAna,OAAAiC,GAIA/F,KAAAie,cACAje,KAAA6e,cAAA,MAEAZ,EAAApa,MAAAI,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAApa,MAAAoa,EAAA/I,UAAA+I,EAAApJ,UACAoJ,EAAAna,OAAAG,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAAna,OAAAma,EAAA7I,WAAA6I,EAAAjJ,WAEAiJ,EAAApa,MAAAI,KAAA0R,IAAAsI,EAAA/I,SAAA+I,EAAApa,MAAAsX,GACA8C,EAAAna,OAAAG,KAAA0R,IAAAsI,EAAA7I,UAAA6I,EAAAna,OAAAqX,GACA8C,EAAAvP,KAAA8O,EAAA9O,MAAA8O,EAAA3Z,MAAAoa,EAAApa,OAAA,EACAoa,EAAAnP,IAAA0O,EAAA1O,KAAA0O,EAAA1Z,OAAAma,EAAAna,QAAA,EACAma,EAAAR,QAAAQ,EAAAvP,KACAuP,EAAAP,OAAAO,EAAAnP,IACA9O,KAAA+e,mBAAA5C,MAAyC8B,IAEzCY,aAAA,SAAAd,EAAAC,GACA,GAAAxQ,GAAAxN,KAAAwN,QACAyP,EAAAjd,KAAAid,cACAO,EAAAxd,KAAAwd,WACAS,EAAAje,KAAAie,YACAN,EAAA3d,KAAA2d,QACA5X,EAAAyH,EAAAzH,WAEA,IAAAgY,EAAA,CACA,GAAA7X,GAAAgW,OAAA1O,EAAAtH,kBAAA,EACAC,EAAA+V,OAAA1O,EAAArH,mBAAA,EACA6Y,EAAArB,EAAA1Z,KAAAyR,IAAAuH,EAAApZ,MAAA2Z,EAAA3Z,MAAA2Z,EAAA3Z,MAAA2Z,EAAA9O,KAAAuO,EAAApZ,MAAA2Z,EAAA9O,MAAAuO,EAAApZ,MACAob,EAAAtB,EAAA1Z,KAAAyR,IAAAuH,EAAAnZ,OAAA0Z,EAAA1Z,OAAA0Z,EAAA1Z,OAAA0Z,EAAA1O,IAAAmO,EAAAnZ,OAAA0Z,EAAA1O,KAAAmO,EAAAnZ,MAEAoC,GAAAjC,KAAAyR,IAAAxP,EAAA+W,EAAApZ,OACAsC,EAAAlC,KAAAyR,IAAAvP,EAAA8W,EAAAnZ,QAEAiC,IACAG,GAAAC,EACAA,EAAAJ,EAAAG,EACAC,EAAAD,EAAAH,EAEAG,EAAAC,EAAAJ,EAEWG,EACXC,EAAAD,EAAAH,EACWI,IACXD,EAAAC,EAAAJ,GAGAkZ,EAAAlZ,EAAAiZ,EACAC,EAAAD,EAAAjZ,EAEAiZ,EAAAC,EAAAlZ,GAKAkY,EAAA/I,SAAAjR,KAAAyR,IAAAxP,EAAA8Y,GACAf,EAAA7I,UAAAnR,KAAAyR,IAAAvP,EAAA8Y,GACAhB,EAAApJ,SAAAmK,EACAf,EAAAjJ,UAAAiK,EAGAjB,IACAL,GACAM,EAAAI,QAAApa,KAAA0R,IAAA,EAAA6H,EAAA9O,MACAuP,EAAAK,OAAAra,KAAA0R,IAAA,EAAA6H,EAAA1O,KACAmP,EAAAM,QAAAta,KAAAyR,IAAAuH,EAAApZ,MAAA2Z,EAAA9O,KAAA8O,EAAA3Z,OAAAoa,EAAApa,MACAoa,EAAAO,OAAAva,KAAAyR,IAAAuH,EAAAnZ,OAAA0Z,EAAA1O,IAAA0O,EAAA1Z,QAAAma,EAAAna,SAEAma,EAAAI,QAAA,EACAJ,EAAAK,OAAA,EACAL,EAAAM,QAAAtB,EAAApZ,MAAAoa,EAAApa,MACAoa,EAAAO,OAAAvB,EAAAnZ,OAAAma,EAAAna,UAIAkZ,cAAA,WACA,GAAAxP,GAAAxN,KAAAwN,QACAyP,EAAAjd,KAAAid,cACAgB,EAAAje,KAAAie,aAEAA,EAAApa,MAAAoa,EAAApJ,UAAAoJ,EAAApa,MAAAoa,EAAA/I,YACA+I,EAAAvP,KAAAuP,EAAAR,UAGAQ,EAAAna,OAAAma,EAAAjJ,WAAAiJ,EAAAna,OAAAma,EAAA7I,aACA6I,EAAAnP,IAAAmP,EAAAP,QAGAO,EAAApa,MAAAI,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAApa,MAAAoa,EAAA/I,UAAA+I,EAAApJ,UACAoJ,EAAAna,OAAAG,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAAna,OAAAma,EAAA7I,WAAA6I,EAAAjJ,WACAhV,KAAA6e,cAAA,MACAZ,EAAAvP,KAAAzK,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAAvP,KAAAuP,EAAAI,SAAAJ,EAAAM,SACAN,EAAAnP,IAAA7K,KAAAyR,IAAAzR,KAAA0R,IAAAsI,EAAAnP,IAAAmP,EAAAK,QAAAL,EAAAO,QACAP,EAAAR,QAAAQ,EAAAvP,KACAuP,EAAAP,OAAAO,EAAAnP,IAEAtB,EAAAtQ,SAAAsQ,EAAA6N,gBAEApO,EAAAjN,KAAAkf,KAAAxF,GAAAuE,EAAApa,OAAAoZ,EAAApZ,OAAAoa,EAAAna,QAAAmZ,EAAAnZ,OA74CA,OAFA,OAk5CAkI,EAAAhM,KAAAmf,QAAAhD,IACAtY,MAAAoa,EAAApa,MACAC,OAAAma,EAAAna,QACOgM,GACPI,WAAA+N,EAAAvP,KACAyB,WAAA8N,EAAAnP,QAGA9O,KAAA+c,SAAA/c,KAAA2d,SACA3d,KAAA4d,aAAA,MAGA5d,KAAA8G,UACA9G,KAAA8e,UAGAA,OAAA,WACA9e,KAAAya,UACAnM,EAAAtO,KAAAiM,QAx4CA,OAw4CAjM,KAAA2E,aAIA8V,IACA2E,YAAA,WACA,GAAAnT,GAAAjM,KAAAiM,QACAoT,EAAArf,KAAAqf,YACA5E,EAAAza,KAAAwN,QAAAiN,QACAvL,EAAAmQ,EAAArf,KAAAsf,eAAAtf,KAAAkP,IACAqQ,EAAAtT,EAAAsT,KAAA,uBACAhd,EAAAnE,SAAAuI,cAAA,MAWA,IATA0Y,IACA9c,EAAA8c,eAGA9c,EAAA8D,IAAA6I,EACA3M,EAAAgd,MACAvf,KAAAwf,QAAA3Y,YAAAtE,GACAvC,KAAAyf,aAAAld,EAEAkY,EAAA,CAIA,GAAAiF,GAAAjF,CAEA,iBAAAA,GACAiF,EAAAzT,EAAA0T,cAAArhB,iBAAAmc,GACOA,EAAA7b,gBACP8gB,GAAAjF,IAGAza,KAAA0f,WACAxf,EAAAwf,EAAA,SAAAE,GACA,GAAAC,GAAAzhB,SAAAuI,cAAA,MAEAsG,GAAA2S,EAAAjG,IACA9V,MAAA+b,EAAA1C,YACApZ,OAAA8b,EAAAzC,aACA2C,KAAAF,EAAAnZ,YAGA4Y,IACAQ,EAAAR,eAGAQ,EAAAxZ,IAAA6I,EACA2Q,EAAAN,MAQAM,EAAA1T,MAAA4T,QAAA,0KACAH,EAAAnZ,UAAA,GACAmZ,EAAA/Y,YAAAgZ,OAGAG,aAAA,WACA9f,EAAAF,KAAA0f,SAAA,SAAAzT,GACA,GAAAvH,GAAAC,EAAAsH,EAAA0N,GACA3N,GAAAC,GACApI,MAAAa,EAAAb,MACAC,OAAAY,EAAAZ,SAEAmI,EAAAxF,UAAA/B,EAAAob,KACA3S,EAAAlB,EAAA0N,OAGAc,QAAA,WACA,GAAA2C,GAAApd,KAAAod,UACAI,EAAAxd,KAAAwd,WACAS,EAAAje,KAAAie,YACAgC,EAAAhC,EAAApa,MACAqc,EAAAjC,EAAAna,OACAD,EAAAuZ,EAAAvZ,MACAC,EAAAsZ,EAAAtZ,OACA4K,EAAAuP,EAAAvP,KAAA8O,EAAA9O,KAAA0O,EAAA1O,KACAI,EAAAmP,EAAAnP,IAAA0O,EAAA1O,IAAAsO,EAAAtO,GAEA9O,MAAA+c,UAAA/c,KAAA8G,WAIAkF,EAAAhM,KAAAyf,aAAAtD,IACAtY,QACAC,UACOgM,EAAAqM,IACPjM,YAAAxB,EACAyB,YAAArB,GACOsO,MACPld,EAAAF,KAAA0f,SAAA,SAAAzT,GACA,GAAAvH,GAAAC,EAAAsH,EAAA0N,IACAwG,EAAAzb,EAAAb,MACAuc,EAAA1b,EAAAZ,OACA0P,EAAA2M,EACA1M,EAAA2M,EACAxO,EAAA,CAEAqO,KACArO,EAAAuO,EAAAF,EACAxM,EAAAyM,EAAAtO,GAGAsO,GAAAzM,EAAA2M,IACAxO,EAAAwO,EAAAF,EACA1M,EAAAyM,EAAArO,EACA6B,EAAA2M,GAGApU,EAAAC,GACApI,MAAA2P,EACA1P,OAAA2P,IAEAzH,EAAAC,EAAAoU,qBAAA,UAAAlE,IACAtY,QAAA+N,EACA9N,SAAA8N,GACS9B,EAAAqM,IACTjM,YAAAxB,EAAAkD,EACAzB,YAAArB,EAAA8C,GACSwL,WAKTkD,IACAC,KAAA,WACA,GAAAtU,GAAAjM,KAAAiM,QACAuB,EAAAxN,KAAAwN,QACAvK,EAAAjD,KAAAiD,OAEAsI,GAAAiC,EAAAqO,YACA9N,EAAA9B,EA7gDA,YA6gDAuB,EAAAqO,WAGAtQ,EAAAiC,EAAAsO,WACA/N,EAAA9B,EAlhDA,WAkhDAuB,EAAAsO,UAGAvQ,EAAAiC,EAAAuO,UACAhO,EAAA9B,EAvhDA,UAuhDAuB,EAAAuO,SAGAxQ,EAAAiC,EAAAwO,OACAjO,EAAA9B,EA5hDA,OA4hDAuB,EAAAwO,MAGAzQ,EAAAiC,EAAAyO,OACAlO,EAAA9B,EAlhDA,OAkhDAuB,EAAAyO,MAGAlO,EAAA9K,EAAA8W,GAAA/Z,KAAAwgB,YAAAxgB,KAAAygB,UAAAF,KAAAvgB,OAEAwN,EAAAnQ,UAAAmQ,EAAAjQ,aACAwQ,EAAA9K,EAzhDA,QAyhDAjD,KAAA0gB,QAAA1gB,KAAA2gB,MAAAJ,KAAAvgB,OACA4gB,SAAA,EACAC,SAAA,IAIArT,EAAA+N,0BACAxN,EAAA9K,EAziDA,WAyiDAjD,KAAA8gB,WAAA9gB,KAAA+gB,SAAAR,KAAAvgB,OAGA+N,EAAA9B,EAAA0T,cAAA3F,GAAAha,KAAAghB,WAAAhhB,KAAAihB,SAAAV,KAAAvgB,OACA+N,EAAA9B,EAAA0T,cAAA1F,GAAAja,KAAAkhB,UAAAlhB,KAAAmhB,QAAAZ,KAAAvgB,OAEAwN,EAAAkN,YACA3M,EAAA5P,OAxiDA,SAwiDA6B,KAAAohB,SAAAphB,KAAAqhB,OAAAd,KAAAvgB,QAGAshB,OAAA,WACA,GAAArV,GAAAjM,KAAAiM,QACAuB,EAAAxN,KAAAwN,QACAvK,EAAAjD,KAAAiD,OAEAsI,GAAAiC,EAAAqO,YACAxO,EAAApB,EA1jDA,YA0jDAuB,EAAAqO,WAGAtQ,EAAAiC,EAAAsO,WACAzO,EAAApB,EA/jDA,WA+jDAuB,EAAAsO,UAGAvQ,EAAAiC,EAAAuO,UACA1O,EAAApB,EApkDA,UAokDAuB,EAAAuO,SAGAxQ,EAAAiC,EAAAwO,OACA3O,EAAApB,EAzkDA,OAykDAuB,EAAAwO,MAGAzQ,EAAAiC,EAAAyO,OACA5O,EAAApB,EA/jDA,OA+jDAuB,EAAAyO,MAGA5O,EAAApK,EAAA8W,GAAA/Z,KAAAwgB,aAEAhT,EAAAnQ,UAAAmQ,EAAAjQ,aACA8P,EAAApK,EAtkDA,QAskDAjD,KAAA0gB,SACAE,SAAA,EACAC,SAAA,IAIArT,EAAA+N,0BACAlO,EAAApK,EAtlDA,WAslDAjD,KAAA8gB,YAGAzT,EAAApB,EAAA0T,cAAA3F,GAAAha,KAAAghB,YACA3T,EAAApB,EAAA0T,cAAA1F,GAAAja,KAAAkhB,WAEA1T,EAAAkN,YACArN,EAAAlP,OArlDA,SAqlDA6B,KAAAohB,YAKAG,IACAF,OAAA,WACA,GAAA7T,GAAAxN,KAAAwN,QACAxP,EAAAgC,KAAAhC,UACAif,EAAAjd,KAAAid,cACAvB,EAAAQ,OAAA1O,EAAAkO,oBAnlDA,IAolDAC,EAAAO,OAAA1O,EAAAmO,qBAnlDA,GAqlDA,MAAA3b,KAAA8G,UAAAmW,EAAApZ,OAAA6X,GAAAuB,EAAAnZ,QAAA6X,GAAA,CAIA,GAAA/J,GAAA5T,EAAAkf,YAAAD,EAAApZ,KAEA,QAAA+N,GAAA5T,EAAAmf,eAAAF,EAAAnZ,OAAA,CACA,GAAA0Z,GACAS,CAEAzQ,GAAA+I,UACAiH,EAAAxd,KAAAwhB,gBACAvD,EAAAje,KAAAyhB,kBAGAzhB,KAAA0c,SAEAlP,EAAA+I,UACAvW,KAAA0hB,cAAAxhB,EAAAsd,EAAA,SAAAtiB,EAAAf,GACAqjB,EAAArjB,GAAAe,EAAA0W,KAEA5R,KAAA2hB,eAAAzhB,EAAA+d,EAAA,SAAA/iB,EAAAf,GACA8jB,EAAA9jB,GAAAe,EAAA0W,SAKAmP,SAAA,WACA/gB,KAAA8G,UA5oDA,SA4oDA9G,KAAAwN,QAAA+M,UAIAva,KAAA4hB,YAAAtV,EAAAtM,KAAA6hB,QAAA1I,GAjpDA,OADA,SAopDAwH,MAAA,SAAA9f,GACA,GAAA4C,GAAAzD,KAEA4R,EAAAsK,OAAAlc,KAAAwN,QAAA4N,iBAAA,GACA0G,EAAA,CAEA9hB,MAAA8G,WAIAjG,EAAAkE,iBAEA/E,KAAA+hB,WAIA/hB,KAAA+hB,UAAA,EACAC,WAAA,WACAve,EAAAse,UAAA,GACO,IAEPlhB,EAAAohB,OACAH,EAAAjhB,EAAAohB,OAAA,OACOphB,EAAAqhB,WACPJ,GAAAjhB,EAAAqhB,WAAA,IACOrhB,EAAAnC,SACPojB,EAAAjhB,EAAAnC,OAAA,QAGAsB,KAAAic,MAAA6F,EAAAlQ,EAAA/Q,MAEA4f,UAAA,SAAA5f,GACA,GAAAshB,GAAAthB,EAAAshB,QACAC,EAAAvhB,EAAAuhB,MAEA,MAAApiB,KAAA8G,WACA,cAAAjG,EAAAyM,MAAA,gBAAAzM,EAAAyM,MAAA,UAAAzM,EAAAwhB,eACArX,EAAAmX,IAAA,IAAAA,GAAAnX,EAAAoX,IAAA,IAAAA,GACAvhB,EAAAyhB,UAHA,CAOA,GAEAC,GAFA/U,EAAAxN,KAAAwN,QACAkD,EAAA1Q,KAAA0Q,QAGA7P,GAAA2hB,eAEAtiB,EAAAW,EAAA2hB,eAAA,SAAAC,GACA/R,EAAA+R,EAAAC,YAAA1Q,EAAAyQ,KAIA/R,EAAA7P,EAAAiQ,WAAA,GAAAkB,EAAAnR,GAIA0hB,EADA1nB,OAAA6F,KAAAgQ,GAAA7S,OAAA,GAAA2P,EAAAnQ,UAAAmQ,EAAAlQ,YAjuDA,OAouDAqH,EAAA9D,EAAArB,OAAAka,IAGAQ,GAAApO,KAAAyW,KAOO,IAHPjU,EAAAtO,KAAAiM,QA/sDA,aAgtDA0W,cAAA9hB,EACA0hB,aAMA1hB,EAAAkE,iBACA/E,KAAAuiB,SACAviB,KAAA4iB,UAAA,EAvvDA,SAyvDAL,IACAviB,KAAA4iB,UAAA,EACAnW,EAAAzM,KAAA6hB,QAAArI,QAGAyH,SAAA,SAAApgB,GACA,GAAA0hB,GAAAviB,KAAAuiB,MAEA,KAAAviB,KAAA8G,UAAAyb,EAAA,CAIA,GAAA7R,GAAA1Q,KAAA0Q,QACA7P,GAAAkE,kBAKO,IAHPuJ,EAAAtO,KAAAiM,QA3uDA,YA4uDA0W,cAAA9hB,EACA0hB,aAKA1hB,EAAA2hB,eACAtiB,EAAAW,EAAA2hB,eAAA,SAAAC,GAEAtG,GAAAzL,EAAA+R,EAAAC,gBAAiD1Q,EAAAyQ,GAAA,MAGjDtG,GAAAzL,EAAA7P,EAAAiQ,WAAA,OAAmDkB,EAAAnR,GAAA,IAGnDb,KAAA6iB,OAAAhiB,MAEAsgB,QAAA,SAAAtgB,GACA,IAAAb,KAAA8G,SAAA,CAIA,GAAAyb,GAAAviB,KAAAuiB,OACA7R,EAAA1Q,KAAA0Q,QAEA7P,GAAA2hB,eACAtiB,EAAAW,EAAA2hB,eAAA,SAAAC,SACA/R,GAAA+R,EAAAC,oBAGAhS,GAAA7P,EAAAiQ,WAAA,GAGAyR,IAIA1hB,EAAAkE,iBAEAlK,OAAA6F,KAAAgQ,GAAA7S,SACAmC,KAAAuiB,OAAA,IAGAviB,KAAA4iB,WACA5iB,KAAA4iB,UAAA,EACAhW,EAAA5M,KAAA6hB,QAAArI,GAAAxZ,KAAA+c,SAAA/c,KAAAwN,QAAAqN,QAGAvM,EAAAtO,KAAAiM,QA7xDA,WA8xDA0W,cAAA9hB,EACA0hB,eAKAM,IACAA,OAAA,SAAAhiB,GACA,GAkBAuX,GAlBA5K,EAAAxN,KAAAwN,QACAgQ,EAAAxd,KAAAwd,WACAP,EAAAjd,KAAAid,cACAgB,EAAAje,KAAAie,YACAvN,EAAA1Q,KAAA0Q,SACA6R,EAAAviB,KAAAuiB,OACAxc,EAAAyH,EAAAzH,YACA2I,EAAAuP,EAAAvP,KACAI,EAAAmP,EAAAnP,IACAjL,EAAAoa,EAAApa,MACAC,EAAAma,EAAAna,OACAgf,EAAApU,EAAA7K,EACAkf,EAAAjU,EAAAhL,EACAua,EAAA,EACAC,EAAA,EACAzJ,EAAAoI,EAAApZ,MACAmR,EAAAiI,EAAAnZ,OACAkf,GAAA,GAGAjd,GAAAlF,EAAAoiB,WACAld,EAAAlC,GAAAC,EAAAD,EAAAC,EAAA,GAGA9D,KAAA2d,UACAU,EAAAJ,EAAAI,QACAC,EAAAL,EAAAK,OACAzJ,EAAAwJ,EAAApa,KAAAyR,IAAAuH,EAAApZ,MAAA2Z,EAAA3Z,MAAA2Z,EAAA9O,KAAA8O,EAAA3Z,OACAmR,EAAAsJ,EAAAra,KAAAyR,IAAAuH,EAAAnZ,OAAA0Z,EAAA1Z,OAAA0Z,EAAA1O,IAAA0O,EAAA1Z,QAGA,IAAA+M,GAAAH,EAAA7V,OAAA6F,KAAAgQ,GAAA,IACAwS,GACAvf,EAAAkN,EAAAS,KAAAT,EAAAK,OACAtN,EAAAiN,EAAAW,KAAAX,EAAAO,QAGA+R,EAAA,SAAAC,GACA,OAAAA,GACA,IAt2DA,IAu2DAN,EAAAI,EAAAvf,EAAAkR,IACAqO,EAAAvf,EAAAkR,EAAAiO,EAGA,MAEA,KA52DA,IA62DApU,EAAAwU,EAAAvf,EAAA0a,IACA6E,EAAAvf,EAAA0a,EAAA3P,EAGA,MAEA,KAj3DA,IAk3DAI,EAAAoU,EAAAtf,EAAA0a,IACA4E,EAAAtf,EAAA0a,EAAAxP,EAGA,MAEA,KAz3DA,IA03DAiU,EAAAG,EAAAtf,EAAAoR,IACAkO,EAAAtf,EAAAoR,EAAA+N,IASA,QAAAR,GAEA,IA54DA,MA64DA7T,GAAAwU,EAAAvf,EACAmL,GAAAoU,EAAAtf,CACA,MAGA,KA94DA,IA+4DA,GAAAsf,EAAAvf,GAAA,IAAAmf,GAAAjO,GAAA9O,IAAA+I,GAAAwP,GAAAyE,GAAA/N,IAAA,CACAgO,GAAA,CACA,OAGAG,EAp5DA,KAq5DAtf,GAAAqf,EAAAvf,EAEAE,EAAA,IACA0e,EAv5DA,IAw5DA1e,KACA6K,GAAA7K,GAGAkC,IACAjC,EAAAD,EAAAkC,EACA+I,IAAAmP,EAAAna,UAAA,EAGA,MAEA,KAj6DA,IAk6DA,GAAAof,EAAAtf,GAAA,IAAAkL,GAAAwP,GAAAvY,IAAA2I,GAAA2P,GAAAyE,GAAAjO,IAAA,CACAmO,GAAA,CACA,OAGAG,EAv6DA,KAw6DArf,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,EAEAE,EAAA,IACAye,EA76DA,IA86DAze,KACAgL,GAAAhL,GAGAiC,IACAlC,EAAAC,EAAAiC,EACA2I,IAAAuP,EAAApa,SAAA,EAGA,MAEA,KA17DA,IA27DA,GAAAqf,EAAAvf,GAAA,IAAA+K,GAAA2P,GAAAtY,IAAA+I,GAAAwP,GAAAyE,GAAA/N,IAAA,CACAgO,GAAA,CACA,OAGAG,EAh8DA,KAi8DAtf,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,EAEAE,EAAA,IACA0e,EAt8DA,IAu8DA1e,KACA6K,GAAA7K,GAGAkC,IACAjC,EAAAD,EAAAkC,EACA+I,IAAAmP,EAAAna,UAAA,EAGA,MAEA,KAh9DA,IAi9DA,GAAAof,EAAAtf,GAAA,IAAAmf,GAAA/N,GAAAjP,IAAA2I,GAAA2P,GAAAyE,GAAAjO,IAAA,CACAmO,GAAA,CACA,OAGAG,EAt9DA,KAu9DArf,GAAAof,EAAAtf,EAEAE,EAAA,IACAye,EAz9DA,IA09DAze,KACAgL,GAAAhL,GAGAiC,IACAlC,EAAAC,EAAAiC,EACA2I,IAAAuP,EAAApa,SAAA,EAGA,MAEA,KAp+DA,KAq+DA,GAAAkC,EAAA,CACA,GAAAmd,EAAAtf,GAAA,IAAAkL,GAAAwP,GAAAwE,GAAAjO,GAAA,CACAmO,GAAA,CACA,OAGAG,EA5+DA,KA6+DArf,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,EACAC,EAAAC,EAAAiC,MAEAod,GAj/DA,KAk/DAA,EAr/DA,KAu/DAD,EAAAvf,GAAA,EACAmf,EAAAjO,EACAhR,GAAAqf,EAAAvf,EACeuf,EAAAtf,GAAA,GAAAkL,GAAAwP,IACf0E,GAAA,GAGAnf,GAAAqf,EAAAvf,EAGAuf,EAAAtf,GAAA,EACAkL,EAAAwP,IACAxa,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,IAGAE,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,EAIAC,GAAA,GAAAC,EAAA,GACAye,EAtgEA,KAugEAze,KACAD,KACAiL,GAAAhL,EACA4K,GAAA7K,GACWA,EAAA,GACX0e,EA9gEA,KA+gEA1e,KACA6K,GAAA7K,GACWC,EAAA,IACXye,EAjhEA,KAkhEAze,KACAgL,GAAAhL,EAGA,MAEA,KAzhEA,KA0hEA,GAAAiC,EAAA,CACA,GAAAmd,EAAAtf,GAAA,IAAAkL,GAAAwP,GAAA5P,GAAA2P,GAAA,CACA2E,GAAA,CACA,OAGAG,EAliEA,KAmiEArf,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,EACAC,EAAAC,EAAAiC,EACA2I,GAAAuP,EAAApa,YAEAsf,GAxiEA,KAyiEAA,EA3iEA,KA6iEAD,EAAAvf,GAAA,EACA+K,EAAA2P,GACAxa,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,GACeuf,EAAAtf,GAAA,GAAAkL,GAAAwP,IACf0E,GAAA,IAGAnf,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,GAGAuf,EAAAtf,GAAA,EACAkL,EAAAwP,IACAxa,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,IAGAE,GAAAof,EAAAtf,EACAkL,GAAAoU,EAAAtf,EAIAC,GAAA,GAAAC,EAAA,GACAye,EAhkEA,KAikEAze,KACAD,KACAiL,GAAAhL,EACA4K,GAAA7K,GACWA,EAAA,GACX0e,EAxkEA,KAykEA1e,KACA6K,GAAA7K,GACWC,EAAA,IACXye,EAzkEA,KA0kEAze,KACAgL,GAAAhL,EAGA,MAEA,KAhlEA,KAilEA,GAAAiC,EAAA,CACA,GAAAmd,EAAAvf,GAAA,IAAA+K,GAAA2P,GAAA0E,GAAA/N,GAAA,CACAgO,GAAA,CACA,OAGAG,EA7lEA,KA8lEAtf,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,EACAG,EAAAD,EAAAkC,MAEAod,GAjmEA,KAkmEAA,EAnmEA,KAqmEAD,EAAAvf,GAAA,EACA+K,EAAA2P,GACAxa,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,GACeuf,EAAAtf,GAAA,GAAAmf,GAAA/N,IACfgO,GAAA,IAGAnf,GAAAqf,EAAAvf,EACA+K,GAAAwU,EAAAvf,GAGAuf,EAAAtf,GAAA,EACAmf,EAAA/N,IACAlR,GAAAof,EAAAtf,GAGAE,GAAAof,EAAAtf,CAIAC,GAAA,GAAAC,EAAA,GACAye,EAxnEA,KAynEAze,KACAD,KACAiL,GAAAhL,EACA4K,GAAA7K,GACWA,EAAA,GACX0e,EA5nEA,KA6nEA1e,KACA6K,GAAA7K,GACWC,EAAA,IACXye,EAjoEA,KAkoEAze,KACAgL,GAAAhL,EAGA,MAEA,KAvoEA,KAwoEA,GAAAiC,EAAA,CACA,GAAAmd,EAAAvf,GAAA,IAAAmf,GAAAjO,GAAAkO,GAAA/N,GAAA,CACAgO,GAAA,CACA,OAGAG,EAppEA,KAqpEAtf,GAAAqf,EAAAvf,EACAG,EAAAD,EAAAkC,MAEAod,GAtpEA,KAupEAA,EAzpEA,KA2pEAD,EAAAvf,GAAA,EACAmf,EAAAjO,EACAhR,GAAAqf,EAAAvf,EACeuf,EAAAtf,GAAA,GAAAmf,GAAA/N,IACfgO,GAAA,GAGAnf,GAAAqf,EAAAvf,EAGAuf,EAAAtf,GAAA,EACAmf,EAAA/N,IACAlR,GAAAof,EAAAtf,GAGAE,GAAAof,EAAAtf,CAIAC,GAAA,GAAAC,EAAA,GACAye,EA1qEA,KA2qEAze,KACAD,KACAiL,GAAAhL,EACA4K,GAAA7K,GACWA,EAAA,GACX0e,EA9qEA,KA+qEA1e,KACA6K,GAAA7K,GACWC,EAAA,IACXye,EArrEA,KAsrEAze,KACAgL,GAAAhL,EAGA,MAGA,KAnsEA,OAosEA9D,KAAAqjB,KAAAH,EAAAvf,EAAAuf,EAAAtf,GACAof,GAAA,CACA,MAGA,KAxsEA,OAysEAhjB,KAAAic,KAAAxL,EAAAC,GAAA7P,GACAmiB,GAAA,CACA,MAGA,KAhtEA,OAitEA,IAAAE,EAAAvf,IAAAuf,EAAAtf,EAAA,CACAof,GAAA,CACA,OAGA5K,EAAA7J,EAAAvO,KAAAiD,SACAyL,EAAAmC,EAAAK,OAAAkH,EAAA1J,KACAI,EAAA+B,EAAAO,OAAAgH,EAAAtJ,IACAjL,EAAAoa,EAAA/I,SACApR,EAAAma,EAAA7I,UAEA8N,EAAAvf,EAAA,EACA4e,EAAAW,EAAAtf,EAAA,EAptEA,KAFA,KAutEWsf,EAAAvf,EAAA,IACX+K,GAAA7K,EACA0e,EAAAW,EAAAtf,EAAA,EAttEA,KAFA,MA2tEAsf,EAAAtf,EAAA,IACAkL,GAAAhL,GAIA9D,KAAA+c,UACApQ,EAAA3M,KAAAmf,QAAA9F,GACArZ,KAAA+c,SAAA,EAEA/c,KAAA2d,SACA3d,KAAA6e,cAAA,OASAmE,IACA/E,EAAApa,QACAoa,EAAAna,SACAma,EAAAvP,OACAuP,EAAAnP,MACA9O,KAAAuiB,SACAviB,KAAAgd,iBAIA9c,EAAAwQ,EAAA,SAAAlV,GACAA,EAAA0V,OAAA1V,EAAA8V,KACA9V,EAAA4V,OAAA5V,EAAAgW,SAKA8R,IAEAtH,KAAA,WAaA,OAZAhc,KAAA4b,OAAA5b,KAAA+c,SAAA/c,KAAA8G,WACA9G,KAAA+c,SAAA,EACA/c,KAAA6e,cAAA,MAEA7e,KAAAwN,QAAAqN,OACApO,EAAAzM,KAAA6hB,QAAArI,IAGA7M,EAAA3M,KAAAmf,QAAA9F,GACArZ,KAAA2hB,eAAA3hB,KAAA+e,qBAGA/e,MAGAujB,MAAA,WAYA,MAXAvjB,MAAA4b,QAAA5b,KAAA8G,WACA9G,KAAAod,UAAAjB,MAAkCnc,KAAA6d,kBAClC7d,KAAAwd,WAAArB,MAAmCnc,KAAA8d,mBACnC9d,KAAAie,YAAA9B,MAAoCnc,KAAA+e,oBACpC/e,KAAA8c,eAEA9c,KAAA+c,SACA/c,KAAAgd,iBAIAhd,MAGAwjB,MAAA,WAiBA,MAhBAxjB,MAAA+c,UAAA/c,KAAA8G,WACAqV,GAAAnc,KAAAie,aACAvP,KAAA,EACAI,IAAA,EACAjL,MAAA,EACAC,OAAA,IAEA9D,KAAA+c,SAAA,EACA/c,KAAAgd,gBACAhd,KAAA4d,aAAA,MAEA5d,KAAA8c,eACAnQ,EAAA3M,KAAA6hB,QAAArI,IACA/M,EAAAzM,KAAAmf,QAAA9F,IAGArZ,MASAuI,QAAA,SAAA2G,GACA,GAAAuU,GAAAxlB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,IAAAA,UAAA,EA4BA,QA1BA+B,KAAA8G,UAAAoI,IACAlP,KAAA0jB,QACA1jB,KAAAiM,QAAA5F,IAAA6I,GAGAuU,GACAzjB,KAAAkP,MACAlP,KAAAuC,MAAA8D,IAAA6I,EAEAlP,KAAA4b,QACA5b,KAAAyf,aAAApZ,IAAA6I,EACAhP,EAAAF,KAAA0f,SAAA,SAAAzT,GACAA,EAAAoU,qBAAA,UAAAha,IAAA6I,OAIAlP,KAAA0jB,QACA1jB,KAAA2jB,UAAA,GAGA3jB,KAAAwN,QAAA9I,KAAA,KACA1E,KAAA4jB,WACA5jB,KAAA6jB,KAAA3U,KAIAlP,MAGA8jB,OAAA,WAMA,MALA9jB,MAAA4b,OAAA5b,KAAA8G,WACA9G,KAAA8G,UAAA,EACA6F,EAAA3M,KAAAiD,QAAAmW,IAGApZ,MAGA+jB,QAAA,WAMA,MALA/jB,MAAA4b,QAAA5b,KAAA8G,WACA9G,KAAA8G,UAAA,EACA2F,EAAAzM,KAAAiD,QAAAmW,IAGApZ,MAOA6E,QAAA,WACA,GAAAoH,GAAAjM,KAAAiM,OAEA,OAAAA,GAAA,SAIAA,EAAA,YAAA/N,GAEA8B,KAAA0jB,OAAA1jB,KAAA2jB,WACA1X,EAAA5F,IAAArG,KAAAgkB,aAGAhkB,KAAA4jB,WACA5jB,MAVAA,MAmBAqjB,KAAA,SAAAY,GACA,GAAAC,GAAAjmB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,GAAAgmB,EACAE,EAAAnkB,KAAAwd,WACA9O,EAAAyV,EAAAzV,KACAI,EAAAqV,EAAArV,GACA,OAAA9O,MAAAokB,OAAAlZ,EAAA+Y,KAAAvV,EAAAwN,OAAA+H,GAAA/Y,EAAAgZ,KAAApV,EAAAoN,OAAAgI,KASAE,OAAA,SAAAzgB,GACA,GAAAC,GAAA3F,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,GAAA0F,EACA6Z,EAAAxd,KAAAwd,WACAiB,GAAA,CAoBA,OAnBA9a,GAAAuY,OAAAvY,GACAC,EAAAsY,OAAAtY,GAEA5D,KAAA4b,QAAA5b,KAAA8G,UAAA9G,KAAAwN,QAAAtQ,UACA8N,EAAArH,KACA6Z,EAAA9O,KAAA/K,EACA8a,GAAA,GAGAzT,EAAApH,KACA4Z,EAAA1O,IAAAlL,EACA6a,GAAA,GAGAA,GACAze,KAAA8c,cAAA,IAIA9c,MASAic,KAAA,SAAArK,EAAAyS,GACA,GAAA7G,GAAAxd,KAAAwd,UASA,OARA5L,GAAAsK,OAAAtK,GAGAA,EADAA,EAAA,EACA,KAAAA,GAEA,EAAAA,EAGA5R,KAAAskB,OAAA9G,EAAA3Z,MAAA+N,EAAA4L,EAAAxJ,aAAA,KAAAqQ,IAUAC,OAAA,SAAA1S,EAAA2S,EAAAF,GACA,GAAA7W,GAAAxN,KAAAwN,QACAgQ,EAAAxd,KAAAwd,WACA3Z,EAAA2Z,EAAA3Z,MACAC,EAAA0Z,EAAA1Z,OACAkQ,EAAAwJ,EAAAxJ,aACAE,EAAAsJ,EAAAtJ,aAGA,KAFAtC,EAAAsK,OAAAtK,KAEA,GAAA5R,KAAA4b,QAAA5b,KAAA8G,UAAA0G,EAAAnQ,SAAA,CACA,GAAAmW,GAAAQ,EAAApC,EACA6B,EAAAS,EAAAtC,CAEA,KAIS,IAJTtD,EAAAtO,KAAAiM,QAr7EA,QAs7EA2F,QACA4S,SAAA3gB,EAAAmQ,EACA2O,cAAA0B,IAEA,MAAArkB,KAGA,IAAAqkB,EAAA,CACA,GAAA3T,GAAA1Q,KAAA0Q,SACA0H,EAAA7J,EAAAvO,KAAAiD,SACA8X,EAAArK,GAAA7V,OAAA6F,KAAAgQ,GAAA7S,OAAAyU,EAAA5B,IACAyB,MAAAkS,EAAAlS,MACAC,MAAAiS,EAAAjS,MAGAoL,GAAA9O,OAAA8E,EAAA3P,KAAAkX,EAAA5I,MAAAiG,EAAA1J,KAAA8O,EAAA9O,MAAA7K,GACA2Z,EAAA1O,MAAA2E,EAAA3P,KAAAiX,EAAA3I,MAAAgG,EAAAtJ,IAAA0O,EAAA1O,KAAAhL,OACSsH,GAAAmZ,IAAAvZ,EAAAuZ,EAAA5gB,IAAAqH,EAAAuZ,EAAA3gB,IACT4Z,EAAA9O,OAAA8E,EAAA3P,KAAA0gB,EAAA5gB,EAAA6Z,EAAA9O,MAAA7K,GACA2Z,EAAA1O,MAAA2E,EAAA3P,KAAAygB,EAAA3gB,EAAA4Z,EAAA1O,KAAAhL,KAGA0Z,EAAA9O,OAAA8E,EAAA3P,GAAA,EACA2Z,EAAA1O,MAAA2E,EAAA3P,GAAA,EAGA0Z,GAAA3Z,MAAA2P,EACAgK,EAAA1Z,OAAA2P,EACAzT,KAAA8c,cAAA,GAGA,MAAA9c,OAQA+P,OAAA,SAAAkD,GACA,MAAAjT,MAAAykB,UAAAzkB,KAAAod,UAAArN,QAAA,GAAAmM,OAAAjJ,KAQAwR,SAAA,SAAAxR,GAQA,MAPAA,GAAAiJ,OAAAjJ,GAEAjI,EAAAiI,IAAAjT,KAAA4b,QAAA5b,KAAA8G,UAAA9G,KAAAwN,QAAArQ,YACA6C,KAAAod,UAAArN,OAAAkD,EAAA,IACAjT,KAAA8c,cAAA,OAGA9c,MAQAgQ,OAAA,SAAA0U,GACA,GAAAzU,GAAAjQ,KAAAod,UAAAnN,MACA,OAAAjQ,MAAAmW,MAAAuO,EAAA1Z,EAAAiF,KAAA,IAQAA,OAAA,SAAA0U,GACA,GAAA3U,GAAAhQ,KAAAod,UAAApN,MACA,OAAAhQ,MAAAmW,MAAAnL,EAAAgF,KAAA,EAAA2U,IASAxO,MAAA,SAAAnG,GACA,GAAAC,GAAAhS,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,GAAA+R,EACAoN,EAAApd,KAAAod,UACAsB,GAAA,CAoBA,OAnBA1O,GAAAkM,OAAAlM,GACAC,EAAAiM,OAAAjM,GAEAjQ,KAAA4b,QAAA5b,KAAA8G,UAAA9G,KAAAwN,QAAApQ,WACA4N,EAAAgF,KACAoN,EAAApN,SACA0O,GAAA,GAGA1T,EAAAiF,KACAmN,EAAAnN,SACAyO,GAAA,GAGAA,GACA1e,KAAA8c,cAAA,OAIA9c,MAQA2E,QAAA,WACA,GAKAD,GALAkgB,EAAA3mB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,IAAAA,UAAA,GACAuP,EAAAxN,KAAAwN,QACA4P,EAAApd,KAAAod,UACAI,EAAAxd,KAAAwd,WACAS,EAAAje,KAAAie,WAGA,IAAAje,KAAA4b,OAAA5b,KAAA+c,QAAA,CACArY,GACAf,EAAAsa,EAAAvP,KAAA8O,EAAA9O,KACA9K,EAAAqa,EAAAnP,IAAA0O,EAAA1O,IACAjL,MAAAoa,EAAApa,MACAC,OAAAma,EAAAna,OAEA,IAAA8N,GAAAwL,EAAAvZ,MAAAuZ,EAAApJ,YAKA,IAJA9T,EAAAwE,EAAA,SAAAxJ,EAAAf,GACAuK,EAAAvK,GAAAe,EAAA0W,IAGAgT,EAAA,CAGA,GAAA7B,GAAA9e,KAAA8H,MAAArH,EAAAd,EAAAc,EAAAZ,QACAgf,EAAA7e,KAAA8H,MAAArH,EAAAf,EAAAe,EAAAb,MACAa,GAAAf,EAAAM,KAAA8H,MAAArH,EAAAf,GACAe,EAAAd,EAAAK,KAAA8H,MAAArH,EAAAd,GACAc,EAAAb,MAAAif,EAAApe,EAAAf,EACAe,EAAAZ,OAAAif,EAAAre,EAAAd,OAGAc,IACAf,EAAA,EACAC,EAAA,EACAC,MAAA,EACAC,OAAA,EAaA,OATA0J,GAAArQ,YACAuH,EAAAqL,OAAAqN,EAAArN,QAAA,GAGAvC,EAAApQ,WACAsH,EAAAsL,OAAAoN,EAAApN,QAAA,EACAtL,EAAAuL,OAAAmN,EAAAnN,QAAA,GAGAvL,GAQAuI,QAAA,SAAAvI,GACA,GAAA8I,GAAAxN,KAAAwN,QACA4P,EAAApd,KAAAod,UACAI,EAAAxd,KAAAwd,WACAS,IAEA,IAAAje,KAAA4b,QAAA5b,KAAA8G,UAAAsE,EAAA1G,GAAA,CACA,GAAAga,IAAA,CAEAlR,GAAArQ,WACA6N,EAAAtG,EAAAqL,SAAArL,EAAAqL,SAAAqN,EAAArN,SACAqN,EAAArN,OAAArL,EAAAqL,OACA2O,GAAA,GAIAlR,EAAApQ,WACA4N,EAAAtG,EAAAsL,SAAAtL,EAAAsL,SAAAoN,EAAApN,SACAoN,EAAApN,OAAAtL,EAAAsL,OACA0O,GAAA,GAGA1T,EAAAtG,EAAAuL,SAAAvL,EAAAuL,SAAAmN,EAAAnN,SACAmN,EAAAnN,OAAAvL,EAAAuL,OACAyO,GAAA,IAIAA,GACA1e,KAAA8c,cAAA,KAGA,IAAAlL,GAAAwL,EAAAvZ,MAAAuZ,EAAApJ,YAEAhJ,GAAAtG,EAAAf,KACAsa,EAAAvP,KAAAhK,EAAAf,EAAAiO,EAAA4L,EAAA9O,MAGA1D,EAAAtG,EAAAd,KACAqa,EAAAnP,IAAApK,EAAAd,EAAAgO,EAAA4L,EAAA1O,KAGA9D,EAAAtG,EAAAb,SACAoa,EAAApa,MAAAa,EAAAb,MAAA+N,GAGA5G,EAAAtG,EAAAZ,UACAma,EAAAna,OAAAY,EAAAZ,OAAA8N,GAGA5R,KAAA2hB,eAAA1D,GAGA,MAAAje,OAOA6kB,iBAAA,WACA,MAAA7kB,MAAA4b,MAAAO,MAAmCnc,KAAAid,mBAOnC6H,aAAA,WACA,MAAA9kB,MAAA+kB,MAAA5I,MAAmCnc,KAAAod,eAOnCoE,cAAA,WACA,GAAAhE,GAAAxd,KAAAwd,WACA9Y,IAQA,OANA1E,MAAA4b,OACA1b,GAAA,uEAAAhF,GACAwJ,EAAAxJ,GAAAsiB,EAAAtiB,KAIAwJ,GAQAgd,cAAA,SAAAhd,GACA,GAAA8Y,GAAAxd,KAAAwd,WACAzX,EAAAyX,EAAAzX,WAsBA,OApBA/F,MAAA4b,QAAA5b,KAAA8G,UAAAsE,EAAA1G,KACAsG,EAAAtG,EAAAgK,QACA8O,EAAA9O,KAAAhK,EAAAgK,MAGA1D,EAAAtG,EAAAoK,OACA0O,EAAA1O,IAAApK,EAAAoK,KAGA9D,EAAAtG,EAAAb,QACA2Z,EAAA3Z,MAAAa,EAAAb,MACA2Z,EAAA1Z,OAAAY,EAAAb,MAAAkC,GACSiF,EAAAtG,EAAAZ,UACT0Z,EAAA1Z,OAAAY,EAAAZ,OACA0Z,EAAA3Z,MAAAa,EAAAZ,OAAAiC,GAGA/F,KAAA8c,cAAA,IAGA9c,MAOAyhB,eAAA,WACA,GACA/c,GADAuZ,EAAAje,KAAAie,WAYA,OATAje,MAAA4b,OAAA5b,KAAA+c,UACArY,GACAgK,KAAAuP,EAAAvP,KACAI,IAAAmP,EAAAnP,IACAjL,MAAAoa,EAAApa,MACAC,OAAAma,EAAAna,SAIAY,OAQAid,eAAA,SAAAjd,GACA,GAEAsgB,GACAC,EAHAhH,EAAAje,KAAAie,YACAlY,EAAA/F,KAAAwN,QAAAzH,WAkCA,OA9BA/F,MAAA4b,OAAA5b,KAAA+c,UAAA/c,KAAA8G,UAAAsE,EAAA1G,KACAsG,EAAAtG,EAAAgK,QACAuP,EAAAvP,KAAAhK,EAAAgK,MAGA1D,EAAAtG,EAAAoK,OACAmP,EAAAnP,IAAApK,EAAAoK,KAGA9D,EAAAtG,EAAAb,QAAAa,EAAAb,QAAAoa,EAAApa,QACAmhB,GAAA,EACA/G,EAAApa,MAAAa,EAAAb,OAGAmH,EAAAtG,EAAAZ,SAAAY,EAAAZ,SAAAma,EAAAna,SACAmhB,GAAA,EACAhH,EAAAna,OAAAY,EAAAZ,QAGAiC,IACAif,EACA/G,EAAAna,OAAAma,EAAApa,MAAAkC,EACWkf,IACXhH,EAAApa,MAAAoa,EAAAna,OAAAiC,IAIA/F,KAAAgd,iBAGAhd,MAQAklB,iBAAA,WACA,GAAA1X,GAAAvP,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,KAEA,KAAA+B,KAAA4b,QAAAzd,OAAAgnB,kBACA,WAGA,IAAA3H,GAAAxd,KAAAwd,WACA/S,EAAAiJ,EAAA1T,KAAAuC,MAAAvC,KAAAod,UAAAI,EAAAhQ,EAEA,KAAAxN,KAAA+c,QACA,MAAAtS,EAGA,IAAA2a,GAAAplB,KAAA2E,UACA0gB,EAAAD,EAAAzhB,EACA2hB,EAAAF,EAAAxhB,EACA2hB,EAAAH,EAAAvhB,MACA2hB,EAAAJ,EAAAthB,OAEA8N,EAAAnH,EAAA5G,MAAAI,KAAAqS,MAAAkH,EAAAxJ,aAEA,KAAApC,IACAyT,GAAAzT,EACA0T,GAAA1T,EACA2T,GAAA3T,EACA4T,GAAA5T,EAGA,IAAA7L,GAAAwf,EAAAC,EACAhQ,EAAA/C,GACA1M,cACAlC,MAAA2J,EAAAqH,UAAAC,IACAhR,OAAA0J,EAAAwH,WAAAF,MAEAW,EAAAhD,GACA1M,cACAlC,MAAA2J,EAAA0H,UAAA,EACApR,OAAA0J,EAAA4H,WAAA,GACO,SAEP8I,EAAAzL,GACA1M,cACAlC,MAAA2J,EAAA3J,QAAA,IAAA+N,EAAAnH,EAAA5G,MAAA0hB,GACAzhB,OAAA0J,EAAA1J,SAAA,IAAA8N,EAAAnH,EAAA3G,OAAA0hB,KAEA3hB,EAAAqa,EAAAra,MACAC,EAAAoa,EAAApa,MAEAD,GAAAI,KAAAyR,IAAAF,EAAA3R,MAAAI,KAAA0R,IAAAF,EAAA5R,UACAC,EAAAG,KAAAyR,IAAAF,EAAA1R,OAAAG,KAAA0R,IAAAF,EAAA3R,UACA,IAAAuR,GAAAjX,SAAAuI,cAAA,UACA2O,EAAAD,EAAAE,WAAA,KACAF,GAAAxR,MAAA8H,EAAA9H,GACAwR,EAAAvR,OAAA6H,EAAA7H,GACAwR,EAAAU,UAAAxI,EAAA+G,WAAA,cACAe,EAAAW,SAAA,IAAApS,EAAAC,EACA,IAAA2hB,GAAAjY,EAAAiH,sBACAA,MAAA,KAAAgR,KACA9Q,EAAAnH,EAAAmH,qBACAW,GAAAb,wBAEAE,IACAW,EAAAX,wBAIA,IAKA+Q,GACAC,EAEAC,EACAC,EACAC,EACAC,EAXAC,EAAAvb,EAAA5G,MACAoiB,EAAAxb,EAAA3G,OAEAoiB,EAAAb,EACAc,EAAAb,CASAY,KAAAX,GAAAW,EAAAF,GACAE,EAAA,EACAR,EAAA,EACAE,EAAA,EACAE,EAAA,GACOI,GAAA,GACPN,GAAAM,EACAA,EAAA,EACAR,EAAAzhB,KAAAyR,IAAAsQ,EAAAT,EAAAW,GACAJ,EAAAJ,GACOQ,GAAAF,IACPJ,EAAA,EACAF,EAAAzhB,KAAAyR,IAAA6P,EAAAS,EAAAE,GACAJ,EAAAJ,GAGAA,GAAA,GAAAS,IAAAX,GAAAW,EAAAF,GACAE,EAAA,EACAR,EAAA,EACAE,EAAA,EACAE,EAAA,GACOI,GAAA,GACPN,GAAAM,EACAA,EAAA,EACAR,EAAA1hB,KAAAyR,IAAAuQ,EAAAT,EAAAW,GACAJ,EAAAJ,GACOQ,GAAAF,IACPJ,EAAA,EACAF,EAAA1hB,KAAAyR,IAAA8P,EAAAS,EAAAE,GACAJ,EAAAJ,EAGA,IAAA7kB,IAAAolB,EAAAC,EAAAT,EAAAC,EAEA,IAAAG,EAAA,GAAAC,EAAA,GACA,GAAA5P,GAAAtS,EAAA0hB,CACAzkB,GAAAuB,KAAAujB,EAAAzP,EAAA0P,EAAA1P,EAAA2P,EAAA3P,EAAA4P,EAAA5P,GAQA,MAHAb,GAAAc,UAAA7L,MAAA+K,GAAA7K,GAAA4B,OAAA7O,EAAAsD,EAAAiH,IAAA,SAAAsO,GACA,MAAApS,MAAAqS,MAAA3K,EAAA0K,SAEAhB,GAQA+Q,eAAA,SAAArgB,GACA,GAAAyH,GAAAxN,KAAAwN,OAeA,OAbAxN,MAAA8G,UAAAoE,EAAAnF,KAEAyH,EAAAzH,YAAA9B,KAAA0R,IAAA,EAAA5P,IAAAE,IAEAjG,KAAA4b,QACA5b,KAAA6c,cAEA7c,KAAA+c,SACA/c,KAAAgd,kBAKAhd,MAQA4hB,YAAA,SAAAyE,GACA,GAAA7Y,GAAAxN,KAAAwN,QACAqU,EAAA7hB,KAAA6hB,QACA3C,EAAAlf,KAAAkf,IAEA,IAAAlf,KAAA4b,QAAA5b,KAAA8G,SAAA,CACA,GAAAwf,GAp9FA,SAo9FAD,EACAnpB,EAAAsQ,EAAAtQ,SAp9FA,SAo9FAmpB,CACAA,GAAAC,GAAAppB,EAAAmpB,EAp9FA,OAq9FA7Y,EAAA+M,SAAA8L,EACApZ,EAAA4U,EAAAnI,GAAA2M,GACAzZ,EAAAiV,EAAA1I,EAAAmN,GACA1Z,EAAAiV,EAAApI,GAAAvc,GAEAsQ,EAAA6N,iBAEApO,EAAAiS,EAAAxF,GAAA2M,GACAzZ,EAAAsS,EAAA/F,EAAAmN,GACA1Z,EAAAsS,EAAAzF,GAAAvc,IAIA,MAAA8C,QAIAumB,GAAAvN,EAAAtT,QAEAA,GAEA,WAMA,QAAAA,GAAAuG,GACA,GAAAuB,GAAAvP,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,KAIA,IAFAgB,EAAAe,KAAA0F,IAEAuG,IAAAoO,GAAAvO,KAAAG,EAAAua,SACA,SAAAC,OAAA,2EAGAzmB,MAAAiM,UACAjM,KAAAwN,QAAA2O,MAA8B7B,GAAAlP,EAAAoC,OAC9BxN,KAAA+c,SAAA,EACA/c,KAAA8G,UAAA,EACA9G,KAAA0Q,YACA1Q,KAAA4b,OAAA,EACA5b,KAAA0mB,WAAA,EACA1mB,KAAA2jB,UAAA,EACA3jB,KAAA+kB,OAAA,EACA/kB,KAAA2mB,QAAA,EACA3mB,KAAAwD,OA4XA,MAzXAlE,GAAAoG,IACA9F,IAAA,OACApF,MAAA,WACA,GAEA0U,GAFAjD,EAAAjM,KAAAiM,QACAua,EAAAva,EAAAua,QAAAxZ,aAGA,KAAAf,EAAA,SAMA,GAFAA,EAAA,QAAAjM,KAEA,QAAAwmB,EAAA,CAMA,GALAxmB,KAAA0jB,OAAA,EAEAxU,EAAAjD,EAAAtE,aAAA,WACA3H,KAAAgkB,YAAA9U,GAEAA,EACA,MAIAA,GAAAjD,EAAA5F,QACS,WAAAmgB,GAAAroB,OAAAgnB,oBACTjW,EAAAjD,EAAA2a,YAGA5mB,MAAA6jB,KAAA3U,OAGAtP,IAAA,OACApF,MAAA,SAAA0U,GACA,GAAAzL,GAAAzD,IAEA,IAAAkP,EAAA,CAIAlP,KAAAkP,MACAlP,KAAAod,YACA,IAAAnR,GAAAjM,KAAAiM,QACAuB,EAAAxN,KAAAwN,OAOA,IALAA,EAAArQ,WAAAqQ,EAAApQ,WACAoQ,EAAAoN,kBAAA,IAIApN,EAAAoN,mBAAAzc,OAAAiZ,YAEA,WADApX,MAAA6mB,OAKA,IAAA1M,GAAArO,KAAAoD,GAUA,YARAkL,GAAAtO,KAAAoD,GACAlP,KAAA8mB,KAAAjQ,EAAA3H,IAIAlP,KAAA6mB,QAQA,IAAAE,GAAA,GAAAC,gBACAH,EAAA7mB,KAAA6mB,MAAAtG,KAAAvgB,KACAA,MAAA0mB,WAAA,EACA1mB,KAAA+mB,MAKAA,EAAAE,QAAAJ,EACAE,EAAAG,QAAAL,EACAE,EAAAI,UAAAN,EAEAE,EAAAK,WAAA,WAvkGA,eAykGAL,EAAAM,kBAAA,iBACAN,EAAAO,SAIAP,EAAAQ,OAAA,WACA9jB,EAAAqjB,KAAAC,EAAAS,WAGAT,EAAAU,UAAA,WACAhkB,EAAAijB,WAAA,EACAjjB,EAAAsjB,IAAA,MAIAvZ,EAAAmN,kBAAA1L,EAAAC,IAAAjD,EAAAoT,cACAnQ,EAAAQ,EAAAR,IAGA6X,EAAAW,KAAA,MAAAxY,GACA6X,EAAAY,aAAA,cACAZ,EAAAa,gBAAA,oBAAA3b,EAAAoT,YACA0H,EAAAc,WAGAjoB,IAAA,OACApF,MAAA,SAAA2c,GACA,GAAA3J,GAAAxN,KAAAwN,QACA4P,EAAApd,KAAAod,UAGAtF,EAAAD,EAAAV,GACApH,EAAA,EACAC,EAAA,EACAC,EAAA,CAEA,IAAA6H,EAAA,GAEA9X,KAAAkP,IAAAsI,EAAAL,EA/mGA,aAinGA,IAAA2Q,GAAAhP,EAAAhB,EAEA/H,GAAA+X,EAAA/X,OACAC,EAAA8X,EAAA9X,OACAC,EAAA6X,EAAA7X,OAGAzC,EAAArQ,YACAigB,EAAArN,UAGAvC,EAAApQ,WACAggB,EAAApN,SACAoN,EAAAnN,UAGAjQ,KAAA6mB,WAGAjnB,IAAA,QACApF,MAAA,WACA,GAAAyR,GAAAjM,KAAAiM,QACAiD,EAAAlP,KAAAkP,IACAmQ,EAAApT,EAAAoT,YACAC,EAAApQ,CAEAlP,MAAAwN,QAAAmN,kBAAA1L,EAAAC,KACAmQ,IACAA,EAAA,aAIAC,EAAA5P,EAAAR,IAGAlP,KAAAqf,cACArf,KAAAsf,gBACA,IAAA/c,GAAAnE,SAAAuI,cAAA,MAEA0Y,KACA9c,EAAA8c,eAGA9c,EAAA8D,IAAAiZ,GAAApQ,EACA3M,EAAAgd,IAAAtT,EAAAsT,KAAA,oBACAvf,KAAAuC,QACAA,EAAAglB,OAAAvnB,KAAAuE,MAAAgc,KAAAvgB,MACAuC,EAAA2kB,QAAAlnB,KAAA+nB,KAAAxH,KAAAvgB,MACAyM,EAAAlK,EAAA+W,GACArN,EAAA+b,WAAAC,aAAA1lB,EAAA0J,EAAAic,gBAGAtoB,IAAA,QACApF,MAAA,WACA,GAAAiK,GAAAzE,KAEAuC,EAAAvC,KAAAuC,KACAA,GAAAglB,OAAA,KACAhlB,EAAA2kB,QAAA,KACAlnB,KAAA2mB,QAAA,CAGA,IAAAwB,GAAAnP,EAAAoP,WAAA,sCAAAtc,KAAAkN,EAAAoP,UAAAC,WAEAjmB,EAAA,SAAA4R,EAAAE,GACAiI,GAAA1X,EAAA2Y,WACApJ,eACAE,gBACAnO,YAAAiO,EAAAE,IAEAzP,EAAAkiB,QAAA,EACAliB,EAAAsgB,OAAA,EAEAtgB,EAAA6jB,QAIA,IAAA/lB,EAAAyR,eAAAmU,EAEA,WADA/lB,GAAAG,EAAAyR,aAAAzR,EAAA2R,cAIA,IAAAqU,GAAAnqB,SAAAuI,cAAA,OACA6hB,EAAApqB,SAAAoqB,MAAApqB,SAAAwQ,eACA5O,MAAAuoB,cAEAA,EAAAhB,OAAA,WACAnlB,EAAAmmB,EAAA1kB,MAAA0kB,EAAAzkB,QAEAqkB,GACAK,EAAAC,YAAAF,IAIAA,EAAAliB,IAAA9D,EAAA8D,IAGA8hB,IACAI,EAAApc,MAAA4T,QAAA,uJACAyI,EAAA3hB,YAAA0hB,OAIA3oB,IAAA,OACApF,MAAA,WACA,GAAA+H,GAAAvC,KAAAuC,KACAA,GAAAglB,OAAA,KACAhlB,EAAA2kB,QAAA,KACA3kB,EAAAylB,WAAAS,YAAAlmB,GACAvC,KAAAuC,MAAA,QAGA3C,IAAA,QACApF,MAAA,WACA,GAAAwF,KAAA+kB,QAAA/kB,KAAA4b,MAAA,CAIA,GAAA3P,GAAAjM,KAAAiM,QACAuB,EAAAxN,KAAAwN,QACAjL,EAAAvC,KAAAuC,MAEAvE,EAAAiO,EAAA+b,WACAU,EAAAtqB,SAAAuI,cAAA,MACA+hB,GAAAjiB,UAzpGA,mrCA0pGA,IAAAxD,GAAAylB,EAAA9pB,cAAA,IAAAyN,OA5xGA,UA4xGA,eACAgJ,EAAApS,EAAArE,cAAA,IAAAyN,OA7xGA,UA6xGA,YACAwV,EAAA5e,EAAArE,cAAA,IAAAyN,OA9xGA,UA8xGA,cACA8S,EAAAlc,EAAArE,cAAA,IAAAyN,OA/xGA,UA+xGA,cACA6S,EAAAC,EAAAvgB,cAAA,IAAAyN,OAhyGA,UAgyGA,SACArM,MAAAhC,YACAgC,KAAAiD,UACAjD,KAAAqV,SACArV,KAAA6hB,UACA7hB,KAAAmf,UACAnf,KAAAwf,QAAAvc,EAAArE,cAAA,IAAAyN,OAtyGA,UAsyGA,cACArM,KAAAkf,OACA7J,EAAAxO,YAAAtE,GAEAkK,EAAAR,EAAAoN,GAEArb,EAAAiqB,aAAAhlB,EAAAgJ,EAAAic,aAEAloB,KAAA0jB,OACA/W,EAAApK,EAAA+W,GAGAtZ,KAAAof,cACApf,KAAAugB,OACA/S,EAAAgN,mBAAAvW,KAAA0R,IAAA,EAAAnI,EAAAgN,qBAAAvU,IACAuH,EAAAzH,YAAA9B,KAAA0R,IAAA,EAAAnI,EAAAzH,cAAAE,IACAuH,EAAAvQ,SAAAgH,KAAA0R,IAAA,EAAA1R,KAAAyR,IAAA,EAAAzR,KAAA8H,MAAAyB,EAAAvQ,aAAA,EACAwP,EAAA0S,EAAA9F,GAEA7L,EAAAsN,QACArO,EAAA0S,EAAAwJ,uBAAA,GAAAtc,OA1zGA,UA0zGA,YAAAgN,GAGA7L,EAAAuN,QACAtO,EAAA0S,EAAAwJ,uBAAA,GAAAtc,OA9zGA,UA8zGA,YAAAgN,GAGA7L,EAAAyN,YACAxO,EAAAxJ,EAAA,GAAAoJ,OAl0GA,UAk0GA,QAGAmB,EAAAwN,WACAvO,EAAAyS,EAAA3F,IAGA/L,EAAA6N,iBACA5O,EAAAyS,EAAAzF,IACAxM,EAAAiS,EAAAxF,GAz0GA,QA40GAlM,EAAA8N,mBACA7O,EAAA0S,EAAAwJ,uBAAA,GAAAtc,OA/0GA,UA+0GA,UAAAgN,GACA5M,EAAA0S,EAAAwJ,uBAAA,GAAAtc,OAh1GA,UAg1GA,WAAAgN,IAGArZ,KAAA0c,SACA1c,KAAA4b,OAAA,EACA5b,KAAA4hB,YAAApU,EAAA+M,UAEA/M,EAAA0N,UACAlb,KAAAgc,OAGAhc,KAAAiN,QAAAO,EAAA9I,MAEA6G,EAAAiC,EAAAoO,QACA7N,EAAA9B,EArzGA,QAqzGAuB,EAAAoO,OACA3N,MAAA,IAIAK,EAAArC,EA1zGA,aA6zGArM,IAAA,UACApF,MAAA,WACAwF,KAAA4b,QAIA5b,KAAA4b,OAAA,EACA5b,KAAAshB,SACAthB,KAAAggB,eACAhgB,KAAAiD,QAAA+kB,WAAAS,YAAAzoB,KAAAiD,SACA0J,EAAA3M,KAAAiM,QAAAoN,OAGAzZ,IAAA,WACApF,MAAA,WACAwF,KAAA4b,OACA5b,KAAA4oB,UACA5oB,KAAA4b,OAAA,EACA5b,KAAA+c,SAAA,GACS/c,KAAA2mB,QACT3mB,KAAAuoB,YAAAhB,OAAA,KACAvnB,KAAA2mB,QAAA,EACA3mB,KAAA+kB,OAAA,GACS/kB,KAAA0mB,WACT1mB,KAAA+mB,IAAAE,QAAA,KACAjnB,KAAA+mB,IAAAO,SACStnB,KAAAuC,OACTvC,KAAA+nB,YASAnoB,IAAA,aACApF,MAAA,WAEA,MADA2D,QAAAuH,QAAA6gB,GACA7gB,KAQA9F,IAAA,cACApF,MAAA,SAAAgT,GACA2O,GAAA7B,GAAAlP,EAAAoC,WAIA9H,IAKA,OAFAyW,IAAAzW,GAAApK,UAAAohB,GAAAjC,GAAA6F,GAAAiB,GAAAsB,GAAAS,IAEA5d,MbymBM,SAAUxL,EAAQD,EAASH,Ic9nIjC,SAAA+uB,EAAAlf,GAEAzP,EAAAD,QAAA0P,KAOC3J,EAAA,WACD,gBAAAnG,GAKA,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA+DA,OAnCAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAAmD,MAAAA,IAGnDV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,GAAAS,GAAAT,KAAAiB,WACA,WAAmC,MAAAjB,GAAA,SACnC,WAAyC,MAAAA,GAEzC,OADAJ,GAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAA8D,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAG9DvB,EAAA0B,EAAA,GAGA1B,IAAA2B,EAAA,KAKA,SAAAvB,EAAAD,EAAAH,GAEA,YAGAI,GAAAD,QAAA,SAAAuG,GACA,MAAA9C,OAAAC,QAAAD,MAAAC,QAAA6C,GAAA,mBAAA3F,OAAAS,UAAAyP,SAAA1Q,KAAAmG,KAKA,SAAAtG,EAAAD,EAAAH,GAEA,YAKA,SAAAmF,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAF3F,GAAAE,GAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAtF,GAAA,EAAgBA,EAAAsF,EAAA5B,OAAkB1D,IAAA,CAAO,GAAAuF,GAAAD,EAAAtF,EAA2BuF,GAAA1E,WAAA0E,EAAA1E,aAAA,EAAwD0E,EAAA3E,cAAA,EAAgC,SAAA2E,OAAAC,UAAA,GAAuD9E,OAAAC,eAAA0E,EAAAE,EAAAE,IAAAF,IAA+D,gBAAAP,EAAAU,EAAAC,GAA2L,MAAlID,IAAAN,EAAAJ,EAAA7D,UAAAuE,GAAqEC,GAAAP,EAAAJ,EAAAW,GAA6DX,MAIxhB2pB,EAAAhvB,EAAA,GACAivB,EAAAjvB,EAAA,GACAkvB,EAAAlvB,EAAA,GAEAmvB,EAAA,WACA,QAAAA,GAAAC,EAAAxlB,GACA,GAAAylB,GAAAzlB,EAAA4L,SACAA,MAAApR,KAAAirB,EAAA,EAAAA,EACAC,EAAA1lB,EAAA2lB,SACAA,MAAAnrB,KAAAkrB,EAAA,IAAAA,EACAE,EAAA5lB,EAAAkF,UACAA,MAAA1K,KAAAorB,EAAA,GAAAA,EACAC,EAAA7lB,EAAA8lB,iBACAA,MAAAtrB,KAAAqrB,EAAA,GAAAA,EACAE,EAAA/lB,EAAAgmB,gBACAA,MAAAxrB,KAAAurB,KACAE,EAAAjmB,EAAAkmB,eACAA,MAAA1rB,KAAAyrB,EAAA,MAAAA,EACAE,EAAAnmB,EAAAomB,eACAA,MAAA5rB,KAAA2rB,KACAE,EAAArmB,EAAAsmB,mBACAA,MAAA9rB,KAAA6rB,EAAA,EAAAA,CAEA9qB,GAAAe,KAAAipB,GAEAjpB,KAAAwN,SACA8B,WACA+Z,WACAzgB,YACA4gB,mBACAE,kBACAE,iBACAE,iBACAE,sBAGAhqB,KAAAkpB,QAAAlpB,KAAAwN,QAAAkc,gBAAAR,IAAAlc,cAEAhN,KAAAkpB,QAAArrB,QAAA2rB,IACAxpB,KAAAgpB,kBAAAhpB,KAAAkpB,UA+CA,MA3CA5pB,GAAA2pB,IACArpB,IAAA,SACApF,MAAA,SAAAyvB,GAMA,GALAjqB,KAAAwN,QAAAkc,kBACAO,IAAAjd,eAIAhN,KAAAkpB,UAAAe,EACA,OACAC,SAAA,EACAC,MAAA,EACAC,iBAAA,EAAAH,EAAApsB,OAAA,IAKA,IAAAwsB,GAAArqB,KAAAwN,QACAgc,EAAAa,EAAAb,iBACAI,EAAAS,EAAAT,cAEA,IAAA5pB,KAAAkpB,QAAArrB,OAAA2rB,EACA,MAAAV,GAAAmB,EAAAjqB,KAAAkpB,QAAAU,EAIA,IAAAU,GAAAtqB,KAAAwN,QACA8B,EAAAgb,EAAAhb,SACA+Z,EAAAiB,EAAAjB,SACAzgB,EAAA0hB,EAAA1hB,UACAkhB,EAAAQ,EAAAR,eACAE,EAAAM,EAAAN,kBAEA,OAAAjB,GAAAkB,EAAAjqB,KAAAkpB,QAAAlpB,KAAAgpB,iBACA1Z,WACA+Z,WACAzgB,YACAkhB,iBACAE,2BAKAf,IAOA/uB,GAAAD,QAAAgvB,GAIA,SAAA/uB,EAAAD,EAAAH,GAEA,YAGA,IAAA6D,GAAA7D,EAAA,GAEAywB,EAAA,QAAAA,GAAA/pB,EAAAkC,EAAA8nB,GACA,GAAA9nB,EAGG,CACH,GAAA+nB,GAAA/nB,EAAA8J,QAAA,KACAke,EAAAhoB,EACAioB,EAAA,MAEA,IAAAF,IACAC,EAAAhoB,EAAA+I,MAAA,EAAAgf,GACAE,EAAAjoB,EAAA+I,MAAAgf,EAAA,GAGA,IAAAjwB,GAAAgG,EAAAkqB,EAEA,WAAAlwB,OAAA0D,KAAA1D,EACA,GAAAmwB,GAAA,gBAAAnwB,IAAA,gBAAAA,GAEO,GAAAmD,EAAAnD,GAEP,OAAAL,GAAA,EAAAywB,EAAApwB,EAAAqD,OAA2C1D,EAAAywB,EAASzwB,GAAA,EACpDowB,EAAA/vB,EAAAL,GAAAwwB,EAAAH,OAEOG,IAEPJ,EAAA/vB,EAAAmwB,EAAAH,OARAA,GAAAnoB,KAAA7H,EAAAuQ,gBAfAyf,GAAAnoB,KAAA7B,EA4BA,OAAAgqB,GAGAtwB,GAAAD,QAAA,SAAAuG,EAAAkC,GACA,MAAA6nB,GAAA/pB,EAAAkC,QAKA,SAAAxI,EAAAD,EAAAH,GAEA,YAGAI,GAAAD,QAAA,WASA,OARA4wB,GAAA5sB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,MACA+rB,EAAA/rB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,KAEAmsB,KACA7lB,GAAA,EACA8N,GAAA,EACAlY,EAAA,EAEAywB,EAAAC,EAAAhtB,OAAkC1D,EAAAywB,EAASzwB,GAAA,GAC3C,GAAAiV,GAAAyb,EAAA1wB,EACAiV,KAAA,IAAA7K,EACAA,EAAApK,EACKiV,IAAA,IAAA7K,IACL8N,EAAAlY,EAAA,EACAkY,EAAA9N,EAAA,GAAAylB,GACAI,EAAA/nB,MAAAkC,EAAA8N,IAEA9N,GAAA,GASA,MAJAsmB,GAAA1wB,EAAA,IAAAA,EAAAoK,GAAAylB,GACAI,EAAA/nB,MAAAkC,EAAApK,EAAA,IAGAiwB,IAKA,SAAAlwB,EAAAD,EAAAH,GAEA,YAGAI,GAAAD,QAAA,SAAAivB,GAIA,OAHA4B,MACAF,EAAA1B,EAAArrB,OAEA1D,EAAA,EAAiBA,EAAAywB,EAASzwB,GAAA,EAC1B2wB,EAAA5B,EAAA6B,OAAA5wB,IAAA,CAGA,QAAA6H,GAAA,EAAkBA,EAAA4oB,EAAU5oB,GAAA,EAC5B8oB,EAAA5B,EAAA6B,OAAA/oB,KAAA,GAAA4oB,EAAA5oB,EAAA,CAGA,OAAA8oB,KAKA,SAAA5wB,EAAAD,EAAAH,GAEA,YAGA,IAAAkxB,GAAA,qCAEA9wB,GAAAD,QAAA,SAAAgwB,EAAAf,GACA,GAAAU,GAAA3rB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,SAEAgtB,EAAA,GAAAC,QAAAhC,EAAA3gB,QAAAyiB,EAAA,QAAAziB,QAAAqhB,EAAA,MACAuB,EAAAlB,EAAA7a,MAAA6b,GACAf,IAAAiB,EACAf,IAEA,IAAAF,EACA,OAAA/vB,GAAA,EAAAixB,EAAAD,EAAAttB,OAAgD1D,EAAAixB,EAAgBjxB,GAAA,GAChE,GAAAiV,GAAA+b,EAAAhxB,EACAiwB,GAAA/nB,MAAA4nB,EAAAzd,QAAA4C,KAAAvR,OAAA,IAIA,OAEAssB,MAAAD,EAAA,KACAA,UACAE,oBAMA,SAAAlwB,EAAAD,EAAAH,GAEA,YAGAI,GAAAD,QAAA,SAAAivB,EAAAxlB,GACA,GAAA2nB,GAAA3nB,EAAA4nB,OACAA,MAAAptB,KAAAmtB,EAAA,EAAAA,EACAE,EAAA7nB,EAAA8nB,gBACAA,MAAAttB,KAAAqtB,EAAA,EAAAA,EACAE,EAAA/nB,EAAAgoB,iBACAA,MAAAxtB,KAAAutB,EAAA,EAAAA,EACArC,EAAA1lB,EAAA2lB,SACAA,MAAAnrB,KAAAkrB,EAAA,IAAAA,EAEAuC,EAAAL,EAAApC,EAAArrB,OACA+tB,EAAA3nB,KAAAgN,IAAAya,EAAAF,EAEA,OAAAnC,GAKAsC,EAAAC,EAAAvC,EAHAuC,EAAA,EAAAD,IAQA,SAAAzxB,EAAAD,EAAAH,GAEA,YAGA,IAAA+xB,GAAA/xB,EAAA,GACAswB,EAAAtwB,EAAA,EAEAI,GAAAD,QAAA,SAAAgwB,EAAAf,EAAAF,EAAAtlB,GAwBA,OAvBAylB,GAAAzlB,EAAA4L,SACAA,MAAApR,KAAAirB,EAAA,EAAAA,EACAC,EAAA1lB,EAAA2lB,SACAA,MAAAnrB,KAAAkrB,EAAA,IAAAA,EACAE,EAAA5lB,EAAAkF,UACAA,MAAA1K,KAAAorB,EAAA,GAAAA,EACAO,EAAAnmB,EAAAomB,eACAA,MAAA5rB,KAAA2rB,KACAE,EAAArmB,EAAAsmB,mBACAA,MAAA9rB,KAAA6rB,EAAA,EAAAA,EAEA2B,EAAApc,EAEAwc,EAAA7B,EAAApsB,OAEAkuB,EAAAnjB,EAEAojB,EAAA/B,EAAAzd,QAAA0c,EAAAwC,GAEAO,EAAA/C,EAAArrB,OAGAquB,KACA/xB,EAAA,EAAiBA,EAAA2xB,EAAa3xB,GAAA,EAC9B+xB,EAAA/xB,GAAA,CAGA,SAAA6xB,EAAA,CACA,GAAA7B,GAAA0B,EAAA3C,GACAoC,OAAA,EACAE,gBAAAQ,EACAN,mBACArC,YAOA,IALA0C,EAAA9nB,KAAAyR,IAAAyU,EAAA4B,IAKA,KAFAC,EAAA/B,EAAA5hB,YAAA6gB,EAAAwC,EAAAO,IAEA,CACA,GAAAE,GAAAN,EAAA3C,GACAoC,OAAA,EACAE,gBAAAQ,EACAN,mBACArC,YAEA0C,GAAA9nB,KAAAyR,IAAAyW,EAAAJ,IAKAC,GAAA,CAQA,QANAI,MACAC,EAAA,EACAC,EAAAL,EAAAH,EAEAhB,EAAA,GAAAmB,EAAA,EAEAjqB,EAAA,EAAkBA,EAAAiqB,EAAiBjqB,GAAA,GAOnC,IAHA,GAAAuqB,GAAA,EACAC,EAAAF,EAEAC,EAAAC,GAAA,CACAX,EAAA3C,GACAoC,OAAAtpB,EACAwpB,gBAAAE,EAAAc,EACAd,mBACArC,cAGA0C,EACAQ,EAAAC,EAEAF,EAAAE,EAGAA,EAAAvoB,KAAAqS,OAAAgW,EAAAC,GAAA,EAAAA,GAIAD,EAAAE,CAEA,IAAAjoB,GAAAN,KAAA0R,IAAA,EAAA+V,EAAAc,EAAA,GACAC,EAAA3C,EAAAgC,EAAA7nB,KAAAyR,IAAAgW,EAAAc,EAAAV,GAAAG,EAGAS,EAAAhvB,MAAA+uB,EAAA,EAEAC,GAAAD,EAAA,OAAAzqB,GAAA,CAEA,QAAA2qB,GAAAF,EAAwBE,GAAApoB,EAAYooB,GAAA,GACpC,GAAAnB,GAAAmB,EAAA,EACAC,EAAA5D,EAAAiB,EAAAc,OAAAS,GAcA,IAZAoB,IACAV,EAAAV,GAAA,GAIAkB,EAAAC,IAAAD,EAAAC,EAAA,SAAAC,EAGA,IAAA5qB,IACA0qB,EAAAC,KAAAP,EAAAO,EAAA,GAAAP,EAAAO,KAAA,IAAAP,EAAAO,EAAA,IAGAD,EAAAC,GAAA7B,IACAuB,EAAAR,EAAA3C,GACAoC,OAAAtpB,EACAwpB,kBACAE,mBACArC,eAKA0C,EAAA,CAMA,GAJAA,EAAAM,GACAL,EAAAR,IAGAE,EACA,KAIAnnB,GAAAN,KAAA0R,IAAA,IAAA+V,EAAAM,IAeA,GATAH,EAAA3C,GACAoC,OAAAtpB,EAAA,EACAwpB,gBAAAE,EACAA,mBACArC,aAKA0C,EACA,KAGAK,GAAAM,EAMA,OACAxC,QAAA8B,GAAA,EACA7B,MAAA,IAAAkC,EAAA,KAAAA,EACAjC,iBAAA8B,EAAAlC,MAMA,SAAA9vB,EAAAD,EAAAH,GAEA,YAOA,SAAAmF,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAJ3F,GAAAwK,GAAA,kBAAA3H,SAAA,gBAAAA,QAAAC,SAAA,SAAA1B,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAyB,SAAAzB,EAAAqJ,cAAA5H,QAAAzB,IAAAyB,OAAA3G,UAAA,eAAAkF,IAE5IlB,EAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAtF,GAAA,EAAgBA,EAAAsF,EAAA5B,OAAkB1D,IAAA,CAAO,GAAAuF,GAAAD,EAAAtF,EAA2BuF,GAAA1E,WAAA0E,EAAA1E,aAAA,EAAwD0E,EAAA3E,cAAA,EAAgC,SAAA2E,OAAAC,UAAA,GAAuD9E,OAAAC,eAAA0E,EAAAE,EAAAE,IAAAF,IAA+D,gBAAAP,EAAAU,EAAAC,GAA2L,MAAlID,IAAAN,EAAAJ,EAAA7D,UAAAuE,GAAqEC,GAAAP,EAAAJ,EAAAW,GAA6DX,MAIxhB8pB,EAAAnvB,EAAA,GACAywB,EAAAzwB,EAAA,GACA6D,EAAA7D,EAAA,GAEA2O,EAAA,WACA,QAAAA,GAAA+hB,EAAA9mB,GACA,GAAAylB,GAAAzlB,EAAA4L,SACAA,MAAApR,KAAAirB,EAAA,EAAAA,EACAC,EAAA1lB,EAAA2lB,SACAA,MAAAnrB,KAAAkrB,EAAA,IAAAA,EACAE,EAAA5lB,EAAAkF,UACAA,MAAA1K,KAAAorB,EAAA,GAAAA,EACAC,EAAA7lB,EAAA8lB,iBACAA,MAAAtrB,KAAAqrB,EAAA,GAAAA,EACAsD,EAAAnpB,EAAAopB,cACAA,MAAA5uB,KAAA2uB,KACAlD,EAAAjmB,EAAAkmB,eACAA,MAAA1rB,KAAAyrB,EAAA,MAAAA,EACAE,EAAAnmB,EAAAomB,eACAA,MAAA5rB,KAAA2rB,KACAE,EAAArmB,EAAAsmB,mBACAA,MAAA9rB,KAAA6rB,EAAA,EAAAA,EACAgD,EAAArpB,EAAAiF,GACAA,MAAAzK,KAAA6uB,EAAA,KAAAA,EACAC,EAAAtpB,EAAAhD,KACAA,MAAAxC,KAAA8uB,OACAC,EAAAvpB,EAAAmF,WACAA,MAAA3K,KAAA+uB,KACAC,EAAAxpB,EAAAypB,MACAA,MAAAjvB,KAAAgvB,EAAA3C,EAAA2C,EACAE,EAAA1pB,EAAA2pB,OACAA,MAAAnvB,KAAAkvB,EAAA,SAAAtb,EAAAC,GACA,MAAAD,GAAAqY,MAAApY,EAAAoY,OACKiD,EACLE,EAAA5pB,EAAA6pB,SACAA,MAAArvB,KAAAovB,KACAE,EAAA9pB,EAAA+pB,eACAA,MAAAvvB,KAAAsvB,KACAE,EAAAhqB,EAAAiqB,eACAA,MAAAzvB,KAAAwvB,KACAE,EAAAlqB,EAAAmqB,aACAA,MAAA3vB,KAAA0vB,KACAE,EAAApqB,EAAAqqB,QACAA,MAAA7vB,KAAA4vB,IAEA7uB,GAAAe,KAAAyI,GAEAzI,KAAAwN,SACA8B,WACA+Z,WACAzgB,YACA4gB,mBACAE,gBAAAoD,EACAlD,iBACAE,iBACAE,qBACArhB,KACAjI,OACAitB,iBACAE,eACAhlB,aACAskB,QACAE,SACAU,UACAR,WACAE,kBAGAztB,KAAAguB,cAAAxD,GAqYA,MAlYAlrB,GAAAmJ,IACA7I,IAAA,gBACApF,MAAA,SAAAgwB,GAEA,MADAxqB,MAAAwqB,OACAA,KAGA5qB,IAAA,SACApF,MAAA,SAAA0uB,GACA,GAAA+E,GAAAhwB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,IAAsFiwB,OAAA,EAEtFluB,MAAAmuB,KAAA,+BAAAjF,EAAA,IAEA,IAAAkF,GAAApuB,KAAAquB,kBAAAnF,GACAoF,EAAAF,EAAAE,eACAC,EAAAH,EAAAG,aAEAC,EAAAxuB,KAAAyuB,QAAAH,EAAAC,GACAG,EAAAF,EAAAE,QACAC,EAAAH,EAAAG,OAYA,OAVA3uB,MAAA4uB,cAAAF,EAAAC,GAEA3uB,KAAAwN,QAAA3E,YACA7I,KAAA6uB,MAAAF,GAGAV,EAAAC,OAAA,gBAAAD,GAAAC,QACAS,IAAAljB,MAAA,EAAAwiB,EAAAC,QAGAluB,KAAA8uB,QAAAH,MAGA/uB,IAAA,oBACApF,MAAA,WACA,GAAA0uB,GAAAjrB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,MAEAqwB,IAEA,IAAAtuB,KAAAwN,QAAA+f,SAGA,OADAwB,GAAA7F,EAAAxb,MAAA1N,KAAAwN,QAAAoc,gBACAzvB,EAAA,EAAAywB,EAAAmE,EAAAlxB,OAA4C1D,EAAAywB,EAASzwB,GAAA,EACrDm0B,EAAAjsB,KAAA,GAAA4mB,GAAA8F,EAAA50B,GAAA6F,KAAAwN,SAMA,QAAc8gB,iBAAAC,aAFd,GAAAtF,GAAAC,EAAAlpB,KAAAwN,aAKA5N,IAAA,UACApF,MAAA,WACA,GAAA8zB,GAAArwB,UAAAJ,OAAA,OAAAK,KAAAD,UAAA,GAAAA,UAAA,MACAswB,EAAAtwB,UAAA,GAEAusB,EAAAxqB,KAAAwqB,KACAwE,KACAL,IAIA,oBAAAnE,GAAA,IAEA,OAAArwB,GAAA,EAAAywB,EAAAJ,EAAA3sB,OAA0C1D,EAAAywB,EAASzwB,GAAA,EACnD6F,KAAAivB,UACArvB,IAAA,GACApF,MAAAgwB,EAAArwB,GACA+0B,OAAA/0B,EACAg1B,MAAAh1B,IAEA60B,YACAL,UACAL,iBACAC,gBAIA,QAAgBG,QAAA,KAAAC,WAMhB,OADAD,MACA1sB,EAAA,EAAAoa,EAAAoO,EAAA3sB,OAA0CmE,EAAAoa,EAAWpa,GAAA,EAGrD,OAFAmH,GAAAqhB,EAAAxoB,GAEA2qB,EAAA,EAAAyC,EAAApvB,KAAAwN,QAAA9M,KAAA7C,OAA2D8uB,EAAAyC,EAAazC,GAAA,GACxE,GAAA/sB,GAAAI,KAAAwN,QAAA9M,KAAAisB,EACA,oBAAA/sB,GAAA,CAIA,GAHA8uB,EAAA9uB,EAAAlF,OACAgO,OAAA,EAAA9I,EAAA8I,QAAA,GAEA9I,EAAA8I,QAAA,GAAA9I,EAAA8I,OAAA,EACA,SAAA+d,OAAA,oCAEA7mB,KAAAlF,SAEAg0B,GAAA9uB,IACA8I,OAAA,EAIA1I,MAAAivB,UACArvB,MACApF,MAAAwF,KAAAwN,QAAA2f,MAAAhkB,EAAAvJ,GACAsvB,OAAA/lB,EACAgmB,MAAAntB,IAEAgtB,YACAL,UACAL,iBACAC,iBAKA,OAAcG,UAAAC,cAGd/uB,IAAA,WACApF,MAAA,SAAAyX,EAAAO,GACA,GAAA5S,GAAAqS,EAAArS,IACAyvB,EAAApd,EAAAqd,WACAA,MAAApxB,KAAAmxB,GAAA,EAAAA,EACA70B,EAAAyX,EAAAzX,MACA00B,EAAAjd,EAAAid,OACAC,EAAAld,EAAAkd,MACAI,EAAA/c,EAAA8b,eACAA,MAAApwB,KAAAqxB,OACAC,EAAAhd,EAAA+b,aACAA,MAAArwB,KAAAsxB,OACAC,EAAAjd,EAAAwc,UACAA,MAAA9wB,KAAAuxB,KAAwDA,EACxDC,EAAAld,EAAAmc,QACAA,MAAAzwB,KAAAwxB,MAGA,QAAAxxB,KAAA1D,GAAA,OAAAA,EAAA,CAIA,GAAAm1B,IAAA,EACAC,GAAA,EACAC,EAAA,CAEA,oBAAAr1B,GAAA,CACAwF,KAAAmuB,KAAA,gBAAAvuB,EAAA,IAAAA,GAEA,IAAAkwB,GAAAvB,EAAAlnB,OAAA7M,EAGA,IAFAwF,KAAAmuB,KAAA,eAAA3zB,EAAA,aAAAs1B,EAAA3F,OAEAnqB,KAAAwN,QAAA+f,SAAA,CAIA,OAHAwC,GAAAv1B,EAAAkT,MAAA1N,KAAAwN,QAAAoc,gBACAoG,KAEA71B,EAAA,EAAyBA,EAAAm0B,EAAAzwB,OAA2B1D,GAAA,GACpD,GAAA81B,GAAA3B,EAAAn0B,EAEA6F,MAAAmuB,KAAA,eAAA8B,EAAA/G,QAAA,IAKA,QAFAgH,IAAA,EAEAvD,EAAA,EAA2BA,EAAAoD,EAAAlyB,OAAkB8uB,GAAA,GAC7C,GAAAwD,GAAAJ,EAAApD,GACAyD,EAAAH,EAAA5oB,OAAA8oB,GACA3vB,IACA4vB,GAAAlG,SACA1pB,EAAA2vB,GAAAC,EAAAjG,MACAwF,GAAA,EACAO,GAAA,EACAF,EAAA3tB,KAAA+tB,EAAAjG,SAEA3pB,EAAA2vB,GAAA,EACAnwB,KAAAwN,QAAAigB,gBACAuC,EAAA3tB,KAAA,IAGArC,KAAAmuB,KAAA,WAAAgC,EAAA,aAAA3vB,EAAA2vB,IAIAD,IACAL,GAAA,GAIAD,EAAAI,EAAA,EAEA,QADAK,GAAAL,EAAAnyB,OACAyyB,EAAA,EAA2BA,EAAAD,EAAiBC,GAAA,EAC5CV,GAAAI,EAAAM,EAEAV,IAAAS,EAEArwB,KAAAmuB,KAAA,uBAAAyB,GAGA,GAAAvD,GAAAyD,EAAA3F,KACAyF,IAAA,IACAvD,KAAAuD,GAAA,GAGA5vB,KAAAmuB,KAAA,iBAAA9B,EAEA,IAAAkE,IAAAvwB,KAAAwN,QAAA+f,WAAAvtB,KAAAwN,QAAAigB,gBAAAoC,GAAAvB,EAAAzwB,MAKA,IAHAmC,KAAAmuB,KAAA,oBAAAoC,IAGAZ,GAAAG,EAAA5F,UAAAqG,EAAA,CAEA,GAAAC,GAAAxB,EAAAG,EACAqB,GAGAA,EAAA1R,OAAAzc,MACAzC,MACA0vB,aACA90B,QACA2vB,MAAAkC,EACAjC,eAAA0F,EAAA1F,kBAIA4E,EAAAG,IACAhmB,KAAA+lB,EACApQ,SACAlf,MACA0vB,aACA90B,QACA2vB,MAAAkC,EACAjC,eAAA0F,EAAA1F,kBAIAuE,EAAAtsB,KAAA2sB,EAAAG,UAGO,IAAAxxB,EAAAnD,GACP,OAAAi2B,GAAA,EAAA7F,EAAApwB,EAAAqD,OAA6C4yB,EAAA7F,EAAW6F,GAAA,EACxDzwB,KAAAivB,UACArvB,MACA0vB,WAAAmB,EACAj2B,QAAAi2B,GACAvB,SACAC,UAEAH,YACAL,UACAL,iBACAC,qBAMA3uB,IAAA,gBACApF,MAAA,SAAAk0B,EAAAC,GACA3uB,KAAAmuB,KAAA,yBAEA,QAAAh0B,GAAA,EAAAywB,EAAA+D,EAAA9wB,OAA2C1D,EAAAywB,EAASzwB,GAAA,GAOpD,OANA2kB,GAAA6P,EAAAx0B,GAAA2kB,OACA4R,EAAA5R,EAAAjhB,OAEA8yB,EAAA,EACAC,EAAA,EAEAjE,EAAA,EAAuBA,EAAA+D,EAAc/D,GAAA,GACrC,GAAAjkB,GAAAgmB,IAAA5P,EAAA6N,GAAA/sB,KAAA8I,OAAA,EACAyhB,EAAA,IAAAzhB,EAAAoW,EAAA6N,GAAAxC,MAAArL,EAAA6N,GAAAxC,OAAA,KACA0G,EAAA1G,EAAAzhB,CAEA,KAAAA,EACAkoB,EAAA3sB,KAAAyR,IAAAkb,EAAAC,IAEA/R,EAAA6N,GAAAkE,SACAF,GAAAE,GAIAlC,EAAAx0B,GAAAgwB,MAAA,IAAAyG,EAAAD,EAAAC,EAEA5wB,KAAAmuB,KAAAQ,EAAAx0B,QAIAyF,IAAA,QACApF,MAAA,SAAAm0B,GACA3uB,KAAAmuB,KAAA,mBACAQ,EAAA9c,KAAA7R,KAAAwN,QAAA6f,WAGAztB,IAAA,UACApF,MAAA,SAAAm0B,GACA,GAAAmC,KAEA,IAAA9wB,KAAAwN,QAAAugB,QAAA,CACA,GAAAgD,KACA/wB,MAAAmuB,KAAA,kBAAA9qB,KAAA2B,UAAA2pB,EAAA,SAAA/uB,EAAApF,GACA,wBAAAA,EAAA,YAAAoP,EAAApP,KAAA,OAAAA,EAAA,CACA,QAAAu2B,EAAAvkB,QAAAhS,GAEA,MAGAu2B,GAAA1uB,KAAA7H,GAEA,MAAAA,MAEAu2B,EAAA,KAGA,GAAAC,KAEAhxB,MAAAwN,QAAAmgB,gBACAqD,EAAA3uB,KAAA,SAAA4uB,EAAAvsB,GACA,GAAAoa,GAAAmS,EAAAnS,MACApa,GAAAymB,UAEA,QAAAhxB,GAAA,EAAAywB,EAAA9L,EAAAjhB,OAA8C1D,EAAAywB,EAASzwB,GAAA,GACvD,GAAAgP,GAAA2V,EAAA3kB,EAEA,QAAAgP,EAAAihB,eAAAvsB,OAAA,CAIA,GAAA2C,IACA0wB,QAAA/nB,EAAAihB,eACA5vB,MAAA2O,EAAA3O,MAEA2O,GAAAvJ,MACAY,EAAAZ,IAAAuJ,EAAAvJ,KAEAuJ,EAAA5N,eAAA,eAAA4N,EAAAmmB,YAAA,IACA9uB,EAAA8uB,WAAAnmB,EAAAmmB,YAEA5qB,EAAAymB,QAAA9oB,KAAA7B,OAKAR,KAAAwN,QAAAqgB,cACAmD,EAAA3uB,KAAA,SAAA4uB,EAAAvsB,GACAA,EAAAylB,MAAA8G,EAAA9G,OAIA,QAAAhwB,GAAA,EAAAywB,EAAA+D,EAAA9wB,OAA2C1D,EAAAywB,EAASzwB,GAAA,GACpD,GAAA82B,GAAAtC,EAAAx0B,EAMA,IAJA6F,KAAAwN,QAAA7E,KACAsoB,EAAA9nB,KAAAnJ,KAAAwN,QAAA2f,MAAA8D,EAAA9nB,KAAAnJ,KAAAwN,QAAA7E,IAAA,IAGAqoB,EAAAnzB,OAAA,CASA,OAJA6G,IACAyE,KAAA8nB,EAAA9nB,MAGAwjB,EAAA,EAAAxe,EAAA6iB,EAAAnzB,OAAoD8uB,EAAAxe,EAAWwe,GAAA,EAC/DqE,EAAArE,GAAAsE,EAAAvsB,EAGAosB,GAAAzuB,KAAAqC,OAZAosB,GAAAzuB,KAAA4uB,EAAA9nB,MAeA,MAAA2nB,MAGAlxB,IAAA,OACApF,MAAA,WACA,GAAAwF,KAAAwN,QAAAugB,QAAA,CACA,GAAAoD,IAEAA,EAAA9wB,SAAAC,IAAAiK,MAAA4mB,EAAAlzB,gBAKAwK,IAGAvO,GAAAD,QAAAwO","file":"./src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 10);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SELECTORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CLASSES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ATTRIBUTES; });\nvar SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nvar CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nvar ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SELECTORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return MODIFIERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CROP_BOX_THRESHOLD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return META_KEYS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return CROPPER_CONFIG; });\nvar SELECTORS = {\n    HOOK: '.js-media-chooser-crop-preview-btn',\n    CONTAINER: '.js-media-cropper',\n    IMAGE: '.js-media-cropper-image',\n    META_CONTAINER: '.js-media-cropper-meta',\n    META_ITEM: '.js-media-cropper-meta-value',\n    VIEW_SELECT: '.js-media-cropper-view-select',\n    SAVE: '.js-media-cropper-save'\n};\n\nvar MODIFIERS = {\n    CROP_BOX_SMALL_CROPPED_AREA: 'media-cropper--crop-box-expanded'\n};\n\nvar CROP_BOX_THRESHOLD = 250;\n\nvar META_KEYS = ['width', 'height'];\n\nvar CROPPER_CONFIG = {\n    viewMode: 2,\n    movable: false,\n    rotatable: false,\n    scalable: false,\n    zoomable: false,\n    zoomOnTouch: false,\n    zoomOnWheel: false\n};\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return initMediaCroppers; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MediaCropper__ = __webpack_require__(5);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\nfunction initMediaCroppers() {\n    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;\n\n    var PREVIEW_BTNS = [].concat(_toConsumableArray(container.querySelectorAll(__WEBPACK_IMPORTED_MODULE_0__config__[\"a\" /* SELECTORS */].HOOK)));\n\n    document.addEventListener('modalOpen', function (e) {\n        var targetModal = e.detail;\n        var node = targetModal.querySelector(__WEBPACK_IMPORTED_MODULE_0__config__[\"a\" /* SELECTORS */].CONTAINER);\n\n        if (!node.hasAttribute('data-initialized')) {\n            new __WEBPACK_IMPORTED_MODULE_1__MediaCropper__[\"a\" /* MediaCropper */](node);\n        }\n    });\n}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__ = __webpack_require__(7);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar PagePartChooser = function () {\n    function PagePartChooser() {\n        _classCallCheck(this, PagePartChooser);\n    }\n\n    _createClass(PagePartChooser, null, [{\n        key: 'init',\n        value: function init() {\n            var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;\n\n            var pagePartChoosers = [].concat(_toConsumableArray(container.querySelectorAll(__WEBPACK_IMPORTED_MODULE_0__config__[\"a\" /* SELECTORS */].PP_CHOOSER)));\n\n            pagePartChoosers.forEach(function (pagePartChooser) {\n                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__pagepart_search_initSearch__[\"a\" /* initSearch */])(pagePartChooser);\n            });\n        }\n    }]);\n\n    return PagePartChooser;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PagePartChooser);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// This can be used to import extra polyfills that aren't in babel-polyfill already.\n\nconsole.log('polyfills');\n\n(function () {\n    if (!Object.entries) {\n\n        console.log('object.entries not available');\n\n        Object.entries = function (obj) {\n            var ownProps = Object.keys(obj),\n                i = ownProps.length,\n                resArray = new Array(i); // preallocate the Array\n            while (i--) {\n                resArray[i] = [ownProps[i], obj[ownProps[i]]];\n            }return resArray;\n        };\n    }\n})();\n\n(function () {\n\n    if (typeof window.CustomEvent === \"function\") return false;\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MediaCropper; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_cropperjs__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_cropperjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_cropperjs__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__renderViewSelectOptions__ = __webpack_require__(6);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar MediaCropper = function () {\n    function MediaCropper(node) {\n        _classCallCheck(this, MediaCropper);\n\n        this.node = node;\n        this.image = this.node.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].IMAGE);\n        this.imagePath = this.node.hasAttribute('data-path') ? this.node.dataset.path : false;\n        this.metaContainer = this.node.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].META_CONTAINER);\n        this.viewSelect = this.metaContainer.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].VIEW_SELECT);\n        this.save = this.metaContainer.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].SAVE);\n        this.input = document.querySelector('#' + this.node.dataset.inputId);\n        this.metaValueNodes = {};\n        this.cropper = null;\n        this.viewData = {};\n        this.cropData = {};\n        this.savedCropData = this.input.value !== '' ? JSON.parse(this.input.value) : false;\n        this.initialized = false;\n\n        this.init();\n    }\n\n    _createClass(MediaCropper, [{\n        key: 'getValueNodes',\n        value: function getValueNodes() {\n            var _this = this;\n\n            __WEBPACK_IMPORTED_MODULE_1__config__[\"b\" /* META_KEYS */].forEach(function (key) {\n                _this.metaValueNodes[key] = _this.metaContainer.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].META_ITEM + '-' + key);\n            });\n        }\n    }, {\n        key: 'updateValue',\n        value: function updateValue(_ref) {\n            var x = _ref.x,\n                y = _ref.y,\n                width = _ref.width,\n                height = _ref.height;\n\n            var small_crop_box_area = false;\n\n            this.metaValueNodes.width.textContent = Math.ceil(width);\n            this.metaValueNodes.height.textContent = Math.ceil(height);\n\n            if ((width || height) <= __WEBPACK_IMPORTED_MODULE_1__config__[\"c\" /* CROP_BOX_THRESHOLD */] && !small_crop_box_area) {\n                this.node.classList.add(__WEBPACK_IMPORTED_MODULE_1__config__[\"d\" /* MODIFIERS */].CROP_BOX_SMALL_CROPPED_AREA);\n                small_crop_box_area = true;\n            } else {\n                this.node.classList.remove(__WEBPACK_IMPORTED_MODULE_1__config__[\"d\" /* MODIFIERS */].CROP_BOX_SMALL_CROPPED_AREA);\n                small_crop_box_area = false;\n            }\n\n            if (this.viewData && this.currentView) {\n                if (!this.cropData.hasOwnProperty(this.currentView)) {\n                    this.cropData[this.currentView] = {};\n                }\n                this.cropData[this.currentView].start = [x, y];\n                this.cropData[this.currentView].size = [width, height];\n            }\n        }\n    }, {\n        key: 'addEventListeners',\n        value: function addEventListeners() {\n            var _this2 = this;\n\n            this.image.addEventListener('crop', function () {\n                var data = _this2.cropper.getData();\n                _this2.updateValue(data);\n            });\n\n            this.viewSelect.addEventListener('change', function () {\n                _this2.currentView = _this2.viewSelect.value;\n                _this2.cropper.destroy();\n                _this2.initCropper();\n            });\n\n            this.save.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this2.input.value = JSON.stringify(_this2.cropData);\n            });\n        }\n    }, {\n        key: 'initCropper',\n        value: function initCropper() {\n            var entries = Object.entries(this.viewData[this.currentView]);\n            var config = __WEBPACK_IMPORTED_MODULE_1__config__[\"e\" /* CROPPER_CONFIG */];\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _step$value = _slicedToArray(_step.value, 2),\n                        key = _step$value[0],\n                        value = _step$value[1];\n\n                    config[key] = value;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            if (this.cropData.hasOwnProperty(this.currentView)) {\n                var savedValues = this.savedCropData[this.currentView];\n\n                config.data = {\n                    x: savedValues.start[0],\n                    y: savedValues.start[1],\n                    width: savedValues.size[0],\n                    height: savedValues.size[1]\n                };\n            } else {\n                config.data = null;\n            }\n\n            this.cropper = new __WEBPACK_IMPORTED_MODULE_0_cropperjs___default.a(this.image, config);\n        }\n    }, {\n        key: 'init',\n        value: function init() {\n            var _this3 = this;\n\n            this.getValueNodes();\n\n            var viewData = JSON.parse(this.node.dataset.croppingViews);\n            if (viewData.length > 0) {\n                viewData.forEach(function (view) {\n                    _this3.viewData[view.name] = {};\n                    _this3.viewData[view.name].aspectRatio = view.lockRatio ? view.height / view.width : NaN;\n                    _this3.viewData[view.name].minCropBoxWidth = view.width ? view.width : 200;\n                    _this3.viewData[view.name].minCropBoxHeight = view.height ? view.height : 100;\n                });\n                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__renderViewSelectOptions__[\"a\" /* renderViewSelectOptions */])(this.viewSelect, this.viewData);\n\n                this.currentView = this.viewSelect.value;\n            }\n\n            if (this.imagePath) {\n                this.image.src = this.imagePath;\n            }\n\n            if (this.savedCropData) {\n                this.cropData = this.savedCropData;\n            }\n\n            this.initCropper();\n            this.addEventListeners();\n\n            this.initialized = true;\n            this.node.dataset.initialized = true;\n        }\n    }]);\n\n    return MediaCropper;\n}();\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return renderViewSelectOptions; });\nfunction renderViewSelectOptions(select, data) {\n    var OPTION_NAMES = Object.keys(data);\n    select.innerHTML = '';\n\n    OPTION_NAMES.forEach(function (name, i) {\n        var option = document.createElement('option');\n        option.value = name;\n        option.textContent = name;\n\n        if (i === 0) {\n            option.selected = true;\n        }\n\n        select.appendChild(option);\n    });\n\n    select.disabled = OPTION_NAMES.length === 1;\n}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = initSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fuse_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resetSearch__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__updateSearch__ = __webpack_require__(9);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\nfunction initSearch(ppChooser) {\n    var ppTypes = JSON.parse(ppChooser.getAttribute(__WEBPACK_IMPORTED_MODULE_1__config__[\"b\" /* ATTRIBUTES */].PP_TYPES));\n\n    var ppTypesSearchData = makePagePartDataSearchable(ppTypes);\n\n    var ppList = [].concat(_toConsumableArray(ppChooser.querySelectorAll(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_ITEM)));\n    var fuse = initFuse(ppTypesSearchData);\n\n    var searchField = ppChooser.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_FIELD);\n    searchField.addEventListener('keyup', searchHandler);\n\n    var searchResetButton = ppChooser.querySelector(__WEBPACK_IMPORTED_MODULE_1__config__[\"a\" /* SELECTORS */].PP_SEARCH_RESET);\n    searchResetButton.addEventListener('click', resetHandler);\n\n    function searchHandler() {\n        if (searchField.value.trim().length > 0) {\n            var searchResults = fuse.search(searchField.value);\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__updateSearch__[\"a\" /* updateSearch */])(ppList, searchResults);\n        } else {\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__resetSearch__[\"a\" /* resetSearch */])(ppList);\n        }\n    }\n\n    function resetHandler() {\n        searchField.value = '';\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__resetSearch__[\"a\" /* resetSearch */])(ppList);\n    }\n}\n\nfunction makePagePartDataSearchable(ppTypes) {\n    return ppTypes.map(function (_ref) {\n        var name = _ref.name,\n            className = _ref.class;\n        return {\n            name: name,\n            className: extractClassNameFromNamespace(className)\n        };\n    });\n}\n\nfunction extractClassNameFromNamespace(ppClass) {\n    var className = ppClass;\n\n    var lastBackSlashIndex = className.lastIndexOf('\\\\');\n    if (lastBackSlashIndex !== -1) {\n        className = className.substring(lastBackSlashIndex + 1);\n    }\n\n    return className.replace('PagePart', '');\n}\n\nfunction initFuse(ppSearchData) {\n    return new __WEBPACK_IMPORTED_MODULE_0_fuse_js___default.a(ppSearchData, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'className',\n            weight: 0.3 // The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = resetSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n\n\nfunction resetSearch(searchItems) {\n    searchItems.forEach(function (item) {\n        item.classList.remove(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = updateSearch;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(0);\n\n\nfunction updateSearch(searchItems, searchResults) {\n    searchItems.forEach(function (item) {\n        var ppName = item.getAttribute(__WEBPACK_IMPORTED_MODULE_0__config__[\"b\" /* ATTRIBUTES */].PP_NAME);\n\n        if (searchResults.includes(ppName)) {\n            item.classList.remove(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(__WEBPACK_IMPORTED_MODULE_0__config__[\"c\" /* CLASSES */].PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polyfills__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polyfills___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__polyfills__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PagePartChooser__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__MediaCropper__ = __webpack_require__(2);\n\n\n\n\n\nfunction init() {\n    __WEBPACK_IMPORTED_MODULE_1__PagePartChooser__[\"a\" /* default */].init();\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__MediaCropper__[\"a\" /* initMediaCroppers */])();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        init();\n    });\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Cropper.js v1.5.6\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2019-10-04T04:33:48.372Z\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Cropper = factory());\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  var WINDOW = IS_BROWSER ? window : {};\n  var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;\n  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\n  var NAMESPACE = 'cropper'; // Actions\n\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw'; // Classes\n\n  var CLASS_CROP = \"\".concat(NAMESPACE, \"-crop\");\n  var CLASS_DISABLED = \"\".concat(NAMESPACE, \"-disabled\");\n  var CLASS_HIDDEN = \"\".concat(NAMESPACE, \"-hidden\");\n  var CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\n  var CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\n  var CLASS_MODAL = \"\".concat(NAMESPACE, \"-modal\");\n  var CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\"); // Data keys\n\n  var DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n  var DATA_PREVIEW = \"\".concat(NAMESPACE, \"Preview\"); // Drag modes\n\n  var DRAG_MODE_CROP = 'crop';\n  var DRAG_MODE_MOVE = 'move';\n  var DRAG_MODE_NONE = 'none'; // Events\n\n  var EVENT_CROP = 'crop';\n  var EVENT_CROP_END = 'cropend';\n  var EVENT_CROP_MOVE = 'cropmove';\n  var EVENT_CROP_START = 'cropstart';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\n  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\n  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\n  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\n  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\n  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\n  var EVENT_READY = 'ready';\n  var EVENT_RESIZE = 'resize';\n  var EVENT_WHEEL = 'wheel';\n  var EVENT_ZOOM = 'zoom'; // Mime types\n\n  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps\n\n  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;\n  var REGEXP_DATA_URL = /^data:/;\n  var REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\n  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc\n  // Inspired by the default width and height of a canvas element.\n\n  var MIN_CONTAINER_WIDTH = 200;\n  var MIN_CONTAINER_HEIGHT = 100;\n\n  var DEFAULTS = {\n    // Define the view mode of the cropper\n    viewMode: 0,\n    // 0, 1, 2, 3\n    // Define the dragging mode of the cropper\n    dragMode: DRAG_MODE_CROP,\n    // 'crop', 'move' or 'none'\n    // Define the initial aspect ratio of the crop box\n    initialAspectRatio: NaN,\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n    // An object with the previous cropping result data\n    data: null,\n    // A selector for adding extra containers to preview\n    preview: '',\n    // Re-render the cropper when resize the window\n    responsive: true,\n    // Restore the cropped area after resize the window\n    restore: true,\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n    // Show the black modal\n    modal: true,\n    // Show the dashed lines for guiding\n    guides: true,\n    // Show the center indicator for guiding\n    center: true,\n    // Show the white modal to highlight the crop box\n    highlight: true,\n    // Show the grid background\n    background: true,\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n    // Enable to move the image\n    movable: true,\n    // Enable to rotate the image\n    rotatable: true,\n    // Enable to scale the image\n    scalable: true,\n    // Enable to zoom the image\n    zoomable: true,\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n    // Enable to move the crop box\n    cropBoxMovable: true,\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n    // Shortcuts of events\n    ready: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  var TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + '</div>' + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + '</div>' + '</div>';\n\n  /**\n   * Check if the given value is not a number.\n   */\n\n  var isNaN = Number.isNaN || WINDOW.isNaN;\n  /**\n   * Check if the given value is a number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n   */\n\n  function isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n  }\n  /**\n   * Check if the given value is a positive number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n   */\n\n  var isPositiveNumber = function isPositiveNumber(value) {\n    return value > 0 && value < Infinity;\n  };\n  /**\n   * Check if the given value is undefined.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n   */\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n  /**\n   * Check if the given value is an object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n   */\n\n  function isObject(value) {\n    return _typeof(value) === 'object' && value !== null;\n  }\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\n   * Check if the given value is a plain object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n   */\n\n  function isPlainObject(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n\n    try {\n      var _constructor = value.constructor;\n      var prototype = _constructor.prototype;\n      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Check if the given value is a function.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  var slice = Array.prototype.slice;\n  /**\n   * Convert array-like or iterable object to an array.\n   * @param {*} value - The value to convert.\n   * @returns {Array} Returns a new array.\n   */\n\n  function toArray(value) {\n    return Array.from ? Array.from(value) : slice.call(value);\n  }\n  /**\n   * Iterate the given data.\n   * @param {*} data - The data to iterate.\n   * @param {Function} callback - The process function for each element.\n   * @returns {*} The original data.\n   */\n\n  function forEach(data, callback) {\n    if (data && isFunction(callback)) {\n      if (Array.isArray(data) || isNumber(data.length)\n      /* array-like */\n      ) {\n          toArray(data).forEach(function (value, key) {\n            callback.call(data, value, key, data);\n          });\n        } else if (isObject(data)) {\n        Object.keys(data).forEach(function (key) {\n          callback.call(data, data[key], key, data);\n        });\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Extend the given object.\n   * @param {*} target - The target object to extend.\n   * @param {*} args - The rest objects for merging to the target object.\n   * @returns {Object} The extended object.\n   */\n\n  var assign = Object.assign || function assign(target) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (isObject(target) && args.length > 0) {\n      args.forEach(function (arg) {\n        if (isObject(arg)) {\n          Object.keys(arg).forEach(function (key) {\n            target[key] = arg[key];\n          });\n        }\n      });\n    }\n\n    return target;\n  };\n  var REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n  /**\n   * Normalize decimal number.\n   * Check out {@link http://0.30000000000000004.com/}\n   * @param {number} value - The value to normalize.\n   * @param {number} [times=100000000000] - The times for normalizing.\n   * @returns {number} Returns the normalized number.\n   */\n\n  function normalizeDecimalNumber(value) {\n    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n  }\n  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;\n  /**\n   * Apply styles to the given element.\n   * @param {Element} element - The target element.\n   * @param {Object} styles - The styles for applying.\n   */\n\n  function setStyle(element, styles) {\n    var style = element.style;\n    forEach(styles, function (value, property) {\n      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n        value = \"\".concat(value, \"px\");\n      }\n\n      style[property] = value;\n    });\n  }\n  /**\n   * Check if the given element has a special class.\n   * @param {Element} element - The element to check.\n   * @param {string} value - The class to search.\n   * @returns {boolean} Returns `true` if the special class was found.\n   */\n\n  function hasClass(element, value) {\n    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n  }\n  /**\n   * Add classes to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be added.\n   */\n\n  function addClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        addClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.add(value);\n      return;\n    }\n\n    var className = element.className.trim();\n\n    if (!className) {\n      element.className = value;\n    } else if (className.indexOf(value) < 0) {\n      element.className = \"\".concat(className, \" \").concat(value);\n    }\n  }\n  /**\n   * Remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be removed.\n   */\n\n  function removeClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        removeClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.remove(value);\n      return;\n    }\n\n    if (element.className.indexOf(value) >= 0) {\n      element.className = element.className.replace(value, '');\n    }\n  }\n  /**\n   * Add or remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be toggled.\n   * @param {boolean} added - Add only.\n   */\n\n  function toggleClass(element, value, added) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        toggleClass(elem, value, added);\n      });\n      return;\n    } // IE10-11 doesn't support the second parameter of `classList.toggle`\n\n\n    if (added) {\n      addClass(element, value);\n    } else {\n      removeClass(element, value);\n    }\n  }\n  var REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\n  /**\n   * Transform the given string from camelCase to kebab-case\n   * @param {string} value - The value to transform.\n   * @returns {string} The transformed value.\n   */\n\n  function toParamCase(value) {\n    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();\n  }\n  /**\n   * Get data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to get.\n   * @returns {string} The data value.\n   */\n\n  function getData(element, name) {\n    if (isObject(element[name])) {\n      return element[name];\n    }\n\n    if (element.dataset) {\n      return element.dataset[name];\n    }\n\n    return element.getAttribute(\"data-\".concat(toParamCase(name)));\n  }\n  /**\n   * Set data to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to set.\n   * @param {string} data - The data value.\n   */\n\n  function setData(element, name, data) {\n    if (isObject(data)) {\n      element[name] = data;\n    } else if (element.dataset) {\n      element.dataset[name] = data;\n    } else {\n      element.setAttribute(\"data-\".concat(toParamCase(name)), data);\n    }\n  }\n  /**\n   * Remove data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to remove.\n   */\n\n  function removeData(element, name) {\n    if (isObject(element[name])) {\n      try {\n        delete element[name];\n      } catch (error) {\n        element[name] = undefined;\n      }\n    } else if (element.dataset) {\n      // #128 Safari not allows to delete dataset property\n      try {\n        delete element.dataset[name];\n      } catch (error) {\n        element.dataset[name] = undefined;\n      }\n    } else {\n      element.removeAttribute(\"data-\".concat(toParamCase(name)));\n    }\n  }\n  var REGEXP_SPACES = /\\s\\s*/;\n\n  var onceSupported = function () {\n    var supported = false;\n\n    if (IS_BROWSER) {\n      var once = false;\n\n      var listener = function listener() {};\n\n      var options = Object.defineProperty({}, 'once', {\n        get: function get() {\n          supported = true;\n          return once;\n        },\n\n        /**\n         * This setter can fix a `TypeError` in strict mode\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n         * @param {boolean} value - The value to set\n         */\n        set: function set(value) {\n          once = value;\n        }\n      });\n      WINDOW.addEventListener('test', listener, options);\n      WINDOW.removeEventListener('test', listener, options);\n    }\n\n    return supported;\n  }();\n  /**\n   * Remove event listener from the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n\n  function removeListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (!onceSupported) {\n        var listeners = element.listeners;\n\n        if (listeners && listeners[event] && listeners[event][listener]) {\n          handler = listeners[event][listener];\n          delete listeners[event][listener];\n\n          if (Object.keys(listeners[event]).length === 0) {\n            delete listeners[event];\n          }\n\n          if (Object.keys(listeners).length === 0) {\n            delete element.listeners;\n          }\n        }\n      }\n\n      element.removeEventListener(event, handler, options);\n    });\n  }\n  /**\n   * Add event listener to the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n  function addListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (options.once && !onceSupported) {\n        var _element$listeners = element.listeners,\n            listeners = _element$listeners === void 0 ? {} : _element$listeners;\n\n        _handler = function handler() {\n          delete listeners[event][listener];\n          element.removeEventListener(event, _handler, options);\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          listener.apply(element, args);\n        };\n\n        if (!listeners[event]) {\n          listeners[event] = {};\n        }\n\n        if (listeners[event][listener]) {\n          element.removeEventListener(event, listeners[event][listener], options);\n        }\n\n        listeners[event][listener] = _handler;\n        element.listeners = listeners;\n      }\n\n      element.addEventListener(event, _handler, options);\n    });\n  }\n  /**\n   * Dispatch event on the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Object} data - The additional event data.\n   * @returns {boolean} Indicate if the event is default prevented or not.\n   */\n\n  function dispatchEvent(element, type, data) {\n    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors\n\n    if (isFunction(Event) && isFunction(CustomEvent)) {\n      event = new CustomEvent(type, {\n        detail: data,\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent(type, true, true, data);\n    }\n\n    return element.dispatchEvent(event);\n  }\n  /**\n   * Get the offset base on the document.\n   * @param {Element} element - The target element.\n   * @returns {Object} The offset data.\n   */\n\n  function getOffset(element) {\n    var box = element.getBoundingClientRect();\n    return {\n      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n      top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n    };\n  }\n  var location = WINDOW.location;\n  var REGEXP_ORIGINS = /^(\\w+:)\\/\\/([^:/?#]*):?(\\d*)/i;\n  /**\n   * Check if the given URL is a cross origin URL.\n   * @param {string} url - The target URL.\n   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\n   */\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(REGEXP_ORIGINS);\n    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\n  }\n  /**\n   * Add timestamp to the given URL.\n   * @param {string} url - The target URL.\n   * @returns {string} The result URL.\n   */\n\n  function addTimestamp(url) {\n    var timestamp = \"timestamp=\".concat(new Date().getTime());\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;\n  }\n  /**\n   * Get transforms base on the given object.\n   * @param {Object} obj - The target object.\n   * @returns {string} A string contains transform values.\n   */\n\n  function getTransforms(_ref) {\n    var rotate = _ref.rotate,\n        scaleX = _ref.scaleX,\n        scaleY = _ref.scaleY,\n        translateX = _ref.translateX,\n        translateY = _ref.translateY;\n    var values = [];\n\n    if (isNumber(translateX) && translateX !== 0) {\n      values.push(\"translateX(\".concat(translateX, \"px)\"));\n    }\n\n    if (isNumber(translateY) && translateY !== 0) {\n      values.push(\"translateY(\".concat(translateY, \"px)\"));\n    } // Rotate should come first before scale to match orientation transform\n\n\n    if (isNumber(rotate) && rotate !== 0) {\n      values.push(\"rotate(\".concat(rotate, \"deg)\"));\n    }\n\n    if (isNumber(scaleX) && scaleX !== 1) {\n      values.push(\"scaleX(\".concat(scaleX, \")\"));\n    }\n\n    if (isNumber(scaleY) && scaleY !== 1) {\n      values.push(\"scaleY(\".concat(scaleY, \")\"));\n    }\n\n    var transform = values.length ? values.join(' ') : 'none';\n    return {\n      WebkitTransform: transform,\n      msTransform: transform,\n      transform: transform\n    };\n  }\n  /**\n   * Get the max ratio of a group of pointers.\n   * @param {string} pointers - The target pointers.\n   * @returns {number} The result ratio.\n   */\n\n  function getMaxZoomRatio(pointers) {\n    var pointers2 = _objectSpread2({}, pointers);\n\n    var ratios = [];\n    forEach(pointers, function (pointer, pointerId) {\n      delete pointers2[pointerId];\n      forEach(pointers2, function (pointer2) {\n        var x1 = Math.abs(pointer.startX - pointer2.startX);\n        var y1 = Math.abs(pointer.startY - pointer2.startY);\n        var x2 = Math.abs(pointer.endX - pointer2.endX);\n        var y2 = Math.abs(pointer.endY - pointer2.endY);\n        var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n        var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n        var ratio = (z2 - z1) / z1;\n        ratios.push(ratio);\n      });\n    });\n    ratios.sort(function (a, b) {\n      return Math.abs(a) < Math.abs(b);\n    });\n    return ratios[0];\n  }\n  /**\n   * Get a pointer from an event object.\n   * @param {Object} event - The target event object.\n   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n   * @returns {Object} The result pointer contains start and/or end point coordinates.\n   */\n\n  function getPointer(_ref2, endOnly) {\n    var pageX = _ref2.pageX,\n        pageY = _ref2.pageY;\n    var end = {\n      endX: pageX,\n      endY: pageY\n    };\n    return endOnly ? end : _objectSpread2({\n      startX: pageX,\n      startY: pageY\n    }, end);\n  }\n  /**\n   * Get the center point coordinate of a group of pointers.\n   * @param {Object} pointers - The target pointers.\n   * @returns {Object} The center point coordinate.\n   */\n\n  function getPointersCenter(pointers) {\n    var pageX = 0;\n    var pageY = 0;\n    var count = 0;\n    forEach(pointers, function (_ref3) {\n      var startX = _ref3.startX,\n          startY = _ref3.startY;\n      pageX += startX;\n      pageY += startY;\n      count += 1;\n    });\n    pageX /= count;\n    pageY /= count;\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n  /**\n   * Get the max sizes in a rectangle under the given aspect ratio.\n   * @param {Object} data - The original sizes.\n   * @param {string} [type='contain'] - The adjust type.\n   * @returns {Object} The result sizes.\n   */\n\n  function getAdjustedSizes(_ref4) // or 'cover'\n  {\n    var aspectRatio = _ref4.aspectRatio,\n        height = _ref4.height,\n        width = _ref4.width;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\n    var isValidWidth = isPositiveNumber(width);\n    var isValidHeight = isPositiveNumber(height);\n\n    if (isValidWidth && isValidHeight) {\n      var adjustedWidth = height * aspectRatio;\n\n      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n        height = width / aspectRatio;\n      } else {\n        width = height * aspectRatio;\n      }\n    } else if (isValidWidth) {\n      height = width / aspectRatio;\n    } else if (isValidHeight) {\n      width = height * aspectRatio;\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n  /**\n   * Get the new sizes of a rectangle after rotated.\n   * @param {Object} data - The original sizes.\n   * @returns {Object} The result sizes.\n   */\n\n  function getRotatedSizes(_ref5) {\n    var width = _ref5.width,\n        height = _ref5.height,\n        degree = _ref5.degree;\n    degree = Math.abs(degree) % 180;\n\n    if (degree === 90) {\n      return {\n        width: height,\n        height: width\n      };\n    }\n\n    var arc = degree % 90 * Math.PI / 180;\n    var sinArc = Math.sin(arc);\n    var cosArc = Math.cos(arc);\n    var newWidth = width * cosArc + height * sinArc;\n    var newHeight = width * sinArc + height * cosArc;\n    return degree > 90 ? {\n      width: newHeight,\n      height: newWidth\n    } : {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n  /**\n   * Get a canvas which drew the given image.\n   * @param {HTMLImageElement} image - The image for drawing.\n   * @param {Object} imageData - The image data.\n   * @param {Object} canvasData - The canvas data.\n   * @param {Object} options - The options.\n   * @returns {HTMLCanvasElement} The result canvas.\n   */\n\n  function getSourceCanvas(image, _ref6, _ref7, _ref8) {\n    var imageAspectRatio = _ref6.aspectRatio,\n        imageNaturalWidth = _ref6.naturalWidth,\n        imageNaturalHeight = _ref6.naturalHeight,\n        _ref6$rotate = _ref6.rotate,\n        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,\n        _ref6$scaleX = _ref6.scaleX,\n        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,\n        _ref6$scaleY = _ref6.scaleY,\n        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;\n    var aspectRatio = _ref7.aspectRatio,\n        naturalWidth = _ref7.naturalWidth,\n        naturalHeight = _ref7.naturalHeight;\n    var _ref8$fillColor = _ref8.fillColor,\n        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,\n        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,\n        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,\n        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,\n        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,\n        _ref8$maxWidth = _ref8.maxWidth,\n        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,\n        _ref8$maxHeight = _ref8.maxHeight,\n        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,\n        _ref8$minWidth = _ref8.minWidth,\n        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,\n        _ref8$minHeight = _ref8.minHeight,\n        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var maxSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var minSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\n    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as\n    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\n\n    var destMaxSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var destMinSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\n    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\n    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];\n    canvas.width = normalizeDecimalNumber(width);\n    canvas.height = normalizeDecimalNumber(height);\n    context.fillStyle = fillColor;\n    context.fillRect(0, 0, width, height);\n    context.save();\n    context.translate(width / 2, height / 2);\n    context.rotate(rotate * Math.PI / 180);\n    context.scale(scaleX, scaleY);\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\n    context.imageSmoothingQuality = imageSmoothingQuality;\n    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {\n      return Math.floor(normalizeDecimalNumber(param));\n    }))));\n    context.restore();\n    return canvas;\n  }\n  var fromCharCode = String.fromCharCode;\n  /**\n   * Get string from char code in data view.\n   * @param {DataView} dataView - The data view for read.\n   * @param {number} start - The start index.\n   * @param {number} length - The read length.\n   * @returns {string} The read result.\n   */\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    length += start;\n\n    for (var i = start; i < length; i += 1) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n  var REGEXP_DATA_URL_HEAD = /^data:.*,/;\n  /**\n   * Transform Data URL to array buffer.\n   * @param {string} dataURL - The Data URL to transform.\n   * @returns {ArrayBuffer} The result array buffer.\n   */\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var arrayBuffer = new ArrayBuffer(binary.length);\n    var uint8 = new Uint8Array(arrayBuffer);\n    forEach(uint8, function (value, i) {\n      uint8[i] = binary.charCodeAt(i);\n    });\n    return arrayBuffer;\n  }\n  /**\n   * Transform array buffer to Data URL.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n   * @param {string} mimeType - The mime type of the Data URL.\n   * @returns {string} The result Data URL.\n   */\n\n  function arrayBufferToDataURL(arrayBuffer, mimeType) {\n    var chunks = []; // Chunk Typed Array for better performance (#435)\n\n    var chunkSize = 8192;\n    var uint8 = new Uint8Array(arrayBuffer);\n\n    while (uint8.length > 0) {\n      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n      // eslint-disable-next-line prefer-spread\n      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n      uint8 = uint8.subarray(chunkSize);\n    }\n\n    return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\n  }\n  /**\n   * Get orientation value from given array buffer.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n   * @returns {number} The read orientation value.\n   */\n\n  function resetAndGetOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var orientation; // Ignores range error when the image does not have correct Exif information\n\n    try {\n      var littleEndian;\n      var app1Start;\n      var ifdStart; // Only handle JPEG image (start by 0xFFD8)\n\n      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n        var length = dataView.byteLength;\n        var offset = 2;\n\n        while (offset + 1 < length) {\n          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n            app1Start = offset;\n            break;\n          }\n\n          offset += 1;\n        }\n      }\n\n      if (app1Start) {\n        var exifIDCode = app1Start + 4;\n        var tiffOffset = app1Start + 10;\n\n        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n          var endianness = dataView.getUint16(tiffOffset);\n          littleEndian = endianness === 0x4949;\n\n          if (littleEndian || endianness === 0x4D4D\n          /* bigEndian */\n          ) {\n              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n                if (firstIFDOffset >= 0x00000008) {\n                  ifdStart = tiffOffset + firstIFDOffset;\n                }\n              }\n            }\n        }\n      }\n\n      if (ifdStart) {\n        var _length = dataView.getUint16(ifdStart, littleEndian);\n\n        var _offset;\n\n        var i;\n\n        for (i = 0; i < _length; i += 1) {\n          _offset = ifdStart + i * 12 + 2;\n\n          if (dataView.getUint16(_offset, littleEndian) === 0x0112\n          /* Orientation */\n          ) {\n              // 8 is the offset of the current tag's value\n              _offset += 8; // Get the original orientation value\n\n              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value\n\n              dataView.setUint16(_offset, 1, littleEndian);\n              break;\n            }\n        }\n      }\n    } catch (error) {\n      orientation = 1;\n    }\n\n    return orientation;\n  }\n  /**\n   * Parse Exif Orientation value.\n   * @param {number} orientation - The orientation to parse.\n   * @returns {Object} The parsed result.\n   */\n\n  function parseOrientation(orientation) {\n    var rotate = 0;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    switch (orientation) {\n      // Flip horizontal\n      case 2:\n        scaleX = -1;\n        break;\n      // Rotate left 180\n\n      case 3:\n        rotate = -180;\n        break;\n      // Flip vertical\n\n      case 4:\n        scaleY = -1;\n        break;\n      // Flip vertical and rotate right 90\n\n      case 5:\n        rotate = 90;\n        scaleY = -1;\n        break;\n      // Rotate right 90\n\n      case 6:\n        rotate = 90;\n        break;\n      // Flip horizontal and rotate right 90\n\n      case 7:\n        rotate = 90;\n        scaleX = -1;\n        break;\n      // Rotate left 90\n\n      case 8:\n        rotate = -90;\n        break;\n\n      default:\n    }\n\n    return {\n      rotate: rotate,\n      scaleX: scaleX,\n      scaleY: scaleY\n    };\n  }\n\n  var render = {\n    render: function render() {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n      this.renderCanvas();\n\n      if (this.cropped) {\n        this.renderCropBox();\n      }\n    },\n    initContainer: function initContainer() {\n      var element = this.element,\n          options = this.options,\n          container = this.container,\n          cropper = this.cropper;\n      addClass(cropper, CLASS_HIDDEN);\n      removeClass(element, CLASS_HIDDEN);\n      var containerData = {\n        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),\n        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)\n      };\n      this.containerData = containerData;\n      setStyle(cropper, {\n        width: containerData.width,\n        height: containerData.height\n      });\n      addClass(element, CLASS_HIDDEN);\n      removeClass(cropper, CLASS_HIDDEN);\n    },\n    // Canvas (image wrapper)\n    initCanvas: function initCanvas() {\n      var containerData = this.containerData,\n          imageData = this.imageData;\n      var viewMode = this.options.viewMode;\n      var rotated = Math.abs(imageData.rotate) % 180 === 90;\n      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\n      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerData.width;\n      var canvasHeight = containerData.height;\n\n      if (containerData.height * aspectRatio > containerData.width) {\n        if (viewMode === 3) {\n          canvasWidth = containerData.height * aspectRatio;\n        } else {\n          canvasHeight = containerData.width / aspectRatio;\n        }\n      } else if (viewMode === 3) {\n        canvasHeight = containerData.width / aspectRatio;\n      } else {\n        canvasWidth = containerData.height * aspectRatio;\n      }\n\n      var canvasData = {\n        aspectRatio: aspectRatio,\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n      canvasData.left = (containerData.width - canvasWidth) / 2;\n      canvasData.top = (containerData.height - canvasHeight) / 2;\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      this.canvasData = canvasData;\n      this.limited = viewMode === 1 || viewMode === 2;\n      this.limitCanvas(true, true);\n      this.initialImageData = assign({}, imageData);\n      this.initialCanvasData = assign({}, canvasData);\n    },\n    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\n      var options = this.options,\n          containerData = this.containerData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var viewMode = options.viewMode;\n      var aspectRatio = canvasData.aspectRatio;\n      var cropped = this.cropped && cropBoxData;\n\n      if (sizeLimited) {\n        var minCanvasWidth = Number(options.minCanvasWidth) || 0;\n        var minCanvasHeight = Number(options.minCanvasHeight) || 0;\n\n        if (viewMode > 1) {\n          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\n          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\n\n          if (viewMode === 3) {\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        } else if (viewMode > 0) {\n          if (minCanvasWidth) {\n            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\n          } else if (minCanvasHeight) {\n            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\n          } else if (cropped) {\n            minCanvasWidth = cropBoxData.width;\n            minCanvasHeight = cropBoxData.height;\n\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        }\n\n        var _getAdjustedSizes = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: minCanvasWidth,\n          height: minCanvasHeight\n        });\n\n        minCanvasWidth = _getAdjustedSizes.width;\n        minCanvasHeight = _getAdjustedSizes.height;\n        canvasData.minWidth = minCanvasWidth;\n        canvasData.minHeight = minCanvasHeight;\n        canvasData.maxWidth = Infinity;\n        canvasData.maxHeight = Infinity;\n      }\n\n      if (positionLimited) {\n        if (viewMode > (cropped ? 0 : 1)) {\n          var newCanvasLeft = containerData.width - canvasData.width;\n          var newCanvasTop = containerData.height - canvasData.height;\n          canvasData.minLeft = Math.min(0, newCanvasLeft);\n          canvasData.minTop = Math.min(0, newCanvasTop);\n          canvasData.maxLeft = Math.max(0, newCanvasLeft);\n          canvasData.maxTop = Math.max(0, newCanvasTop);\n\n          if (cropped && this.limited) {\n            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\n            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\n            canvasData.maxLeft = cropBoxData.left;\n            canvasData.maxTop = cropBoxData.top;\n\n            if (viewMode === 2) {\n              if (canvasData.width >= containerData.width) {\n                canvasData.minLeft = Math.min(0, newCanvasLeft);\n                canvasData.maxLeft = Math.max(0, newCanvasLeft);\n              }\n\n              if (canvasData.height >= containerData.height) {\n                canvasData.minTop = Math.min(0, newCanvasTop);\n                canvasData.maxTop = Math.max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvasData.minLeft = -canvasData.width;\n          canvasData.minTop = -canvasData.height;\n          canvasData.maxLeft = containerData.width;\n          canvasData.maxTop = containerData.height;\n        }\n      }\n    },\n    renderCanvas: function renderCanvas(changed, transformed) {\n      var canvasData = this.canvasData,\n          imageData = this.imageData;\n\n      if (transformed) {\n        var _getRotatedSizes = getRotatedSizes({\n          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\n          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\n          degree: imageData.rotate || 0\n        }),\n            naturalWidth = _getRotatedSizes.width,\n            naturalHeight = _getRotatedSizes.height;\n\n        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\n        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\n        canvasData.left -= (width - canvasData.width) / 2;\n        canvasData.top -= (height - canvasData.height) / 2;\n        canvasData.width = width;\n        canvasData.height = height;\n        canvasData.aspectRatio = naturalWidth / naturalHeight;\n        canvasData.naturalWidth = naturalWidth;\n        canvasData.naturalHeight = naturalHeight;\n        this.limitCanvas(true, false);\n      }\n\n      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\n        canvasData.left = canvasData.oldLeft;\n      }\n\n      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\n        canvasData.top = canvasData.oldTop;\n      }\n\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n      this.limitCanvas(false, true);\n      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\n      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      setStyle(this.canvas, assign({\n        width: canvasData.width,\n        height: canvasData.height\n      }, getTransforms({\n        translateX: canvasData.left,\n        translateY: canvasData.top\n      })));\n      this.renderImage(changed);\n\n      if (this.cropped && this.limited) {\n        this.limitCropBox(true, true);\n      }\n    },\n    renderImage: function renderImage(changed) {\n      var canvasData = this.canvasData,\n          imageData = this.imageData;\n      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\n      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\n      assign(imageData, {\n        width: width,\n        height: height,\n        left: (canvasData.width - width) / 2,\n        top: (canvasData.height - height) / 2\n      });\n      setStyle(this.image, assign({\n        width: imageData.width,\n        height: imageData.height\n      }, getTransforms(assign({\n        translateX: imageData.left,\n        translateY: imageData.top\n      }, imageData))));\n\n      if (changed) {\n        this.output();\n      }\n    },\n    initCropBox: function initCropBox() {\n      var options = this.options,\n          canvasData = this.canvasData;\n      var aspectRatio = options.aspectRatio || options.initialAspectRatio;\n      var autoCropArea = Number(options.autoCropArea) || 0.8;\n      var cropBoxData = {\n        width: canvasData.width,\n        height: canvasData.height\n      };\n\n      if (aspectRatio) {\n        if (canvasData.height * aspectRatio > canvasData.width) {\n          cropBoxData.height = cropBoxData.width / aspectRatio;\n        } else {\n          cropBoxData.width = cropBoxData.height * aspectRatio;\n        }\n      }\n\n      this.cropBoxData = cropBoxData;\n      this.limitCropBox(true, true); // Initialize auto crop area\n\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than \"minWidth/Height\"\n\n      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\n      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\n      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\n      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n      this.initialCropBoxData = assign({}, cropBoxData);\n    },\n    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\n      var options = this.options,\n          containerData = this.containerData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData,\n          limited = this.limited;\n      var aspectRatio = options.aspectRatio;\n\n      if (sizeLimited) {\n        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\n        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\n        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\n        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height\n\n        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\n        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        } // The minWidth/Height must be less than maxWidth/Height\n\n\n        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\n        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\n        cropBoxData.maxWidth = maxCropBoxWidth;\n        cropBoxData.maxHeight = maxCropBoxHeight;\n      }\n\n      if (positionLimited) {\n        if (limited) {\n          cropBoxData.minLeft = Math.max(0, canvasData.left);\n          cropBoxData.minTop = Math.max(0, canvasData.top);\n          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\n          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\n        } else {\n          cropBoxData.minLeft = 0;\n          cropBoxData.minTop = 0;\n          cropBoxData.maxLeft = containerData.width - cropBoxData.width;\n          cropBoxData.maxTop = containerData.height - cropBoxData.height;\n        }\n      }\n    },\n    renderCropBox: function renderCropBox() {\n      var options = this.options,\n          containerData = this.containerData,\n          cropBoxData = this.cropBoxData;\n\n      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\n        cropBoxData.left = cropBoxData.oldLeft;\n      }\n\n      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\n        cropBoxData.top = cropBoxData.oldTop;\n      }\n\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n      this.limitCropBox(false, true);\n      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\n      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n\n      if (options.movable && options.cropBoxMovable) {\n        // Turn to move the canvas when the crop box is equal to the container\n        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      setStyle(this.cropBox, assign({\n        width: cropBoxData.width,\n        height: cropBoxData.height\n      }, getTransforms({\n        translateX: cropBoxData.left,\n        translateY: cropBoxData.top\n      })));\n\n      if (this.cropped && this.limited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.disabled) {\n        this.output();\n      }\n    },\n    output: function output() {\n      this.preview();\n      dispatchEvent(this.element, EVENT_CROP, this.getData());\n    }\n  };\n\n  var preview = {\n    initPreview: function initPreview() {\n      var element = this.element,\n          crossOrigin = this.crossOrigin;\n      var preview = this.options.preview;\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var alt = element.alt || 'The image to preview';\n      var image = document.createElement('img');\n\n      if (crossOrigin) {\n        image.crossOrigin = crossOrigin;\n      }\n\n      image.src = url;\n      image.alt = alt;\n      this.viewBox.appendChild(image);\n      this.viewBoxImage = image;\n\n      if (!preview) {\n        return;\n      }\n\n      var previews = preview;\n\n      if (typeof preview === 'string') {\n        previews = element.ownerDocument.querySelectorAll(preview);\n      } else if (preview.querySelector) {\n        previews = [preview];\n      }\n\n      this.previews = previews;\n      forEach(previews, function (el) {\n        var img = document.createElement('img'); // Save the original size for recover\n\n        setData(el, DATA_PREVIEW, {\n          width: el.offsetWidth,\n          height: el.offsetHeight,\n          html: el.innerHTML\n        });\n\n        if (crossOrigin) {\n          img.crossOrigin = crossOrigin;\n        }\n\n        img.src = url;\n        img.alt = alt;\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * Add `height:auto` to override `height` attribute on IE8\n         * (Occur only when margin-top <= -height)\n         */\n\n        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;\"';\n        el.innerHTML = '';\n        el.appendChild(img);\n      });\n    },\n    resetPreview: function resetPreview() {\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        setStyle(element, {\n          width: data.width,\n          height: data.height\n        });\n        element.innerHTML = data.html;\n        removeData(element, DATA_PREVIEW);\n      });\n    },\n    preview: function preview() {\n      var imageData = this.imageData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var cropBoxWidth = cropBoxData.width,\n          cropBoxHeight = cropBoxData.height;\n      var width = imageData.width,\n          height = imageData.height;\n      var left = cropBoxData.left - canvasData.left - imageData.left;\n      var top = cropBoxData.top - canvasData.top - imageData.top;\n\n      if (!this.cropped || this.disabled) {\n        return;\n      }\n\n      setStyle(this.viewBoxImage, assign({\n        width: width,\n        height: height\n      }, getTransforms(assign({\n        translateX: -left,\n        translateY: -top\n      }, imageData))));\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        setStyle(element, {\n          width: newWidth,\n          height: newHeight\n        });\n        setStyle(element.getElementsByTagName('img')[0], assign({\n          width: width * ratio,\n          height: height * ratio\n        }, getTransforms(assign({\n          translateX: -left * ratio,\n          translateY: -top * ratio\n        }, imageData))));\n      });\n    }\n  };\n\n  var events = {\n    bind: function bind() {\n      var element = this.element,\n          options = this.options,\n          cropper = this.cropper;\n\n      if (isFunction(options.cropstart)) {\n        addListener(element, EVENT_CROP_START, options.cropstart);\n      }\n\n      if (isFunction(options.cropmove)) {\n        addListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if (isFunction(options.cropend)) {\n        addListener(element, EVENT_CROP_END, options.cropend);\n      }\n\n      if (isFunction(options.crop)) {\n        addListener(element, EVENT_CROP, options.crop);\n      }\n\n      if (isFunction(options.zoom)) {\n        addListener(element, EVENT_ZOOM, options.zoom);\n      }\n\n      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n          passive: false,\n          capture: true\n        });\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n      }\n\n      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\n      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\n\n      if (options.responsive) {\n        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n      }\n    },\n    unbind: function unbind() {\n      var element = this.element,\n          options = this.options,\n          cropper = this.cropper;\n\n      if (isFunction(options.cropstart)) {\n        removeListener(element, EVENT_CROP_START, options.cropstart);\n      }\n\n      if (isFunction(options.cropmove)) {\n        removeListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if (isFunction(options.cropend)) {\n        removeListener(element, EVENT_CROP_END, options.cropend);\n      }\n\n      if (isFunction(options.crop)) {\n        removeListener(element, EVENT_CROP, options.crop);\n      }\n\n      if (isFunction(options.zoom)) {\n        removeListener(element, EVENT_ZOOM, options.zoom);\n      }\n\n      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        removeListener(cropper, EVENT_WHEEL, this.onWheel, {\n          passive: false,\n          capture: true\n        });\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\n      }\n\n      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\n      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\n\n      if (options.responsive) {\n        removeListener(window, EVENT_RESIZE, this.onResize);\n      }\n    }\n  };\n\n  var handlers = {\n    resize: function resize() {\n      var options = this.options,\n          container = this.container,\n          containerData = this.containerData;\n      var minContainerWidth = Number(options.minContainerWidth) || MIN_CONTAINER_WIDTH;\n      var minContainerHeight = Number(options.minContainerHeight) || MIN_CONTAINER_HEIGHT;\n\n      if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {\n        return;\n      }\n\n      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed\n\n      if (ratio !== 1 || container.offsetHeight !== containerData.height) {\n        var canvasData;\n        var cropBoxData;\n\n        if (options.restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (options.restore) {\n          this.setCanvasData(forEach(canvasData, function (n, i) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData(forEach(cropBoxData, function (n, i) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n    dblclick: function dblclick() {\n      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\n        return;\n      }\n\n      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\n    },\n    wheel: function wheel(event) {\n      var _this = this;\n\n      var ratio = Number(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.disabled) {\n        return;\n      }\n\n      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)\n\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n      setTimeout(function () {\n        _this.wheeling = false;\n      }, 50);\n\n      if (event.deltaY) {\n        delta = event.deltaY > 0 ? 1 : -1;\n      } else if (event.wheelDelta) {\n        delta = -event.wheelDelta / 120;\n      } else if (event.detail) {\n        delta = event.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n    cropStart: function cropStart(event) {\n      var buttons = event.buttons,\n          button = event.button;\n\n      if (this.disabled // Handle mouse event and pointer event and ignore touch event\n      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)\n      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu\n      || event.ctrlKey)) {\n        return;\n      }\n\n      var options = this.options,\n          pointers = this.pointers;\n      var action;\n\n      if (event.changedTouches) {\n        // Handle touch event\n        forEach(event.changedTouches, function (touch) {\n          pointers[touch.identifier] = getPointer(touch);\n        });\n      } else {\n        // Handle mouse event and pointer event\n        pointers[event.pointerId || 0] = getPointer(event);\n      }\n\n      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n        action = ACTION_ZOOM;\n      } else {\n        action = getData(event.target, DATA_ACTION);\n      }\n\n      if (!REGEXP_ACTIONS.test(action)) {\n        return;\n      }\n\n      if (dispatchEvent(this.element, EVENT_CROP_START, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      } // This line is required for preventing page zooming in iOS browsers\n\n\n      event.preventDefault();\n      this.action = action;\n      this.cropping = false;\n\n      if (action === ACTION_CROP) {\n        this.cropping = true;\n        addClass(this.dragBox, CLASS_MODAL);\n      }\n    },\n    cropMove: function cropMove(event) {\n      var action = this.action;\n\n      if (this.disabled || !action) {\n        return;\n      }\n\n      var pointers = this.pointers;\n      event.preventDefault();\n\n      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      }\n\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          // The first parameter should not be undefined (#432)\n          assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n        });\n      } else {\n        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n      }\n\n      this.change(event);\n    },\n    cropEnd: function cropEnd(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      var action = this.action,\n          pointers = this.pointers;\n\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          delete pointers[touch.identifier];\n        });\n      } else {\n        delete pointers[event.pointerId || 0];\n      }\n\n      if (!action) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (!Object.keys(pointers).length) {\n        this.action = '';\n      }\n\n      if (this.cropping) {\n        this.cropping = false;\n        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\n      }\n\n      dispatchEvent(this.element, EVENT_CROP_END, {\n        originalEvent: event,\n        action: action\n      });\n    }\n  };\n\n  var change = {\n    change: function change(event) {\n      var options = this.options,\n          canvasData = this.canvasData,\n          containerData = this.containerData,\n          cropBoxData = this.cropBoxData,\n          pointers = this.pointers;\n      var action = this.action;\n      var aspectRatio = options.aspectRatio;\n      var left = cropBoxData.left,\n          top = cropBoxData.top,\n          width = cropBoxData.width,\n          height = cropBoxData.height;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = containerData.width;\n      var maxHeight = containerData.height;\n      var renderable = true;\n      var offset; // Locking aspect ratio in \"free mode\" by holding shift key\n\n      if (!aspectRatio && event.shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBoxData.minLeft;\n        minTop = cropBoxData.minTop;\n        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\n        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\n      }\n\n      var pointer = pointers[Object.keys(pointers)[0]];\n      var range = {\n        x: pointer.endX - pointer.startX,\n        y: pointer.endY - pointer.startY\n      };\n\n      var check = function check(side) {\n        switch (side) {\n          case ACTION_EAST:\n            if (right + range.x > maxWidth) {\n              range.x = maxWidth - right;\n            }\n\n            break;\n\n          case ACTION_WEST:\n            if (left + range.x < minLeft) {\n              range.x = minLeft - left;\n            }\n\n            break;\n\n          case ACTION_NORTH:\n            if (top + range.y < minTop) {\n              range.y = minTop - top;\n            }\n\n            break;\n\n          case ACTION_SOUTH:\n            if (bottom + range.y > maxHeight) {\n              range.y = maxHeight - bottom;\n            }\n\n            break;\n\n          default:\n        }\n      };\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n        // Resize crop box\n\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_EAST);\n          width += range.x;\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = -width;\n            left -= width;\n          }\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_NORTH);\n          height -= range.y;\n          top += range.y;\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = -height;\n            top -= height;\n          }\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_WEST);\n          width -= range.x;\n          left += range.x;\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = -width;\n            left -= width;\n          }\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_SOUTH);\n          height += range.y;\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = -height;\n            top -= height;\n          }\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_EAST);\n\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += cropBoxData.width - width;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_WEST);\n\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_WEST);\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_WEST);\n\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_EAST);\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_EAST);\n\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n        // Move canvas\n\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n        // Zoom canvas\n\n        case ACTION_ZOOM:\n          this.zoom(getMaxZoomRatio(pointers), event);\n          renderable = false;\n          break;\n        // Create crop box\n\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = getOffset(this.cropper);\n          left = pointer.startX - offset.left;\n          top = pointer.startY - offset.top;\n          width = cropBoxData.minWidth;\n          height = cropBoxData.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          } // Show the crop box if is hidden\n\n\n          if (!this.cropped) {\n            removeClass(this.cropBox, CLASS_HIDDEN);\n            this.cropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        default:\n      }\n\n      if (renderable) {\n        cropBoxData.width = width;\n        cropBoxData.height = height;\n        cropBoxData.left = left;\n        cropBoxData.top = top;\n        this.action = action;\n        this.renderCropBox();\n      } // Override\n\n\n      forEach(pointers, function (p) {\n        p.startX = p.endX;\n        p.startY = p.endY;\n      });\n    }\n  };\n\n  var methods = {\n    // Show the crop box manually\n    crop: function crop() {\n      if (this.ready && !this.cropped && !this.disabled) {\n        this.cropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          addClass(this.dragBox, CLASS_MODAL);\n        }\n\n        removeClass(this.cropBox, CLASS_HIDDEN);\n        this.setCropBoxData(this.initialCropBoxData);\n      }\n\n      return this;\n    },\n    // Reset the image and crop box to their initial states\n    reset: function reset() {\n      if (this.ready && !this.disabled) {\n        this.imageData = assign({}, this.initialImageData);\n        this.canvasData = assign({}, this.initialCanvasData);\n        this.cropBoxData = assign({}, this.initialCropBoxData);\n        this.renderCanvas();\n\n        if (this.cropped) {\n          this.renderCropBox();\n        }\n      }\n\n      return this;\n    },\n    // Clear the crop box\n    clear: function clear() {\n      if (this.cropped && !this.disabled) {\n        assign(this.cropBoxData, {\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        });\n        this.cropped = false;\n        this.renderCropBox();\n        this.limitCanvas(true, true); // Render canvas after crop box rendered\n\n        this.renderCanvas();\n        removeClass(this.dragBox, CLASS_MODAL);\n        addClass(this.cropBox, CLASS_HIDDEN);\n      }\n\n      return this;\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     * @param {string} url - The new URL.\n     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\n     * @returns {Cropper} this\n     */\n    replace: function replace(url) {\n      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!this.disabled && url) {\n        if (this.isImg) {\n          this.element.src = url;\n        }\n\n        if (hasSameSize) {\n          this.url = url;\n          this.image.src = url;\n\n          if (this.ready) {\n            this.viewBoxImage.src = url;\n            forEach(this.previews, function (element) {\n              element.getElementsByTagName('img')[0].src = url;\n            });\n          }\n        } else {\n          if (this.isImg) {\n            this.replaced = true;\n          }\n\n          this.options.data = null;\n          this.uncreate();\n          this.load(url);\n        }\n      }\n\n      return this;\n    },\n    // Enable (unfreeze) the cropper\n    enable: function enable() {\n      if (this.ready && this.disabled) {\n        this.disabled = false;\n        removeClass(this.cropper, CLASS_DISABLED);\n      }\n\n      return this;\n    },\n    // Disable (freeze) the cropper\n    disable: function disable() {\n      if (this.ready && !this.disabled) {\n        this.disabled = true;\n        addClass(this.cropper, CLASS_DISABLED);\n      }\n\n      return this;\n    },\n\n    /**\n     * Destroy the cropper and remove the instance from the image\n     * @returns {Cropper} this\n     */\n    destroy: function destroy() {\n      var element = this.element;\n\n      if (!element[NAMESPACE]) {\n        return this;\n      }\n\n      element[NAMESPACE] = undefined;\n\n      if (this.isImg && this.replaced) {\n        element.src = this.originalUrl;\n      }\n\n      this.uncreate();\n      return this;\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     * @param {number} offsetX - The relative offset distance on the x-axis.\n     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\n     * @returns {Cropper} this\n     */\n    move: function move(offsetX) {\n      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\n      var _this$canvasData = this.canvasData,\n          left = _this$canvasData.left,\n          top = _this$canvasData.top;\n      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     * @param {number} x - The x-axis coordinate.\n     * @param {number} [y=x] - The y-axis coordinate.\n     * @returns {Cropper} this\n     */\n    moveTo: function moveTo(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      var canvasData = this.canvasData;\n      var changed = false;\n      x = Number(x);\n      y = Number(y);\n\n      if (this.ready && !this.disabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvasData.left = x;\n          changed = true;\n        }\n\n        if (isNumber(y)) {\n          canvasData.top = y;\n          changed = true;\n        }\n\n        if (changed) {\n          this.renderCanvas(true);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoom: function zoom(ratio, _originalEvent) {\n      var canvasData = this.canvasData;\n      ratio = Number(ratio);\n\n      if (ratio < 0) {\n        ratio = 1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Object} pivot - The zoom pivot point coordinate.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\n      var options = this.options,\n          canvasData = this.canvasData;\n      var width = canvasData.width,\n          height = canvasData.height,\n          naturalWidth = canvasData.naturalWidth,\n          naturalHeight = canvasData.naturalHeight;\n      ratio = Number(ratio);\n\n      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\n        var newWidth = naturalWidth * ratio;\n        var newHeight = naturalHeight * ratio;\n\n        if (dispatchEvent(this.element, EVENT_ZOOM, {\n          ratio: ratio,\n          oldRatio: width / naturalWidth,\n          originalEvent: _originalEvent\n        }) === false) {\n          return this;\n        }\n\n        if (_originalEvent) {\n          var pointers = this.pointers;\n          var offset = getOffset(this.cropper);\n          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n            pageX: _originalEvent.pageX,\n            pageY: _originalEvent.pageY\n          }; // Zoom from the triggering point of the event\n\n          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\n        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\n        } else {\n          // Zoom from the center of the canvas\n          canvasData.left -= (newWidth - width) / 2;\n          canvasData.top -= (newHeight - height) / 2;\n        }\n\n        canvasData.width = newWidth;\n        canvasData.height = newHeight;\n        this.renderCanvas(true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotate: function rotate(degree) {\n      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotateTo: function rotateTo(degree) {\n      degree = Number(degree);\n\n      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\n        this.imageData.rotate = degree % 360;\n        this.renderCanvas(true, true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Scale the image on the x-axis.\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @returns {Cropper} this\n     */\n    scaleX: function scaleX(_scaleX) {\n      var scaleY = this.imageData.scaleY;\n      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the image on the y-axis.\n     * @param {number} scaleY - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scaleY: function scaleY(_scaleY) {\n      var scaleX = this.imageData.scaleX;\n      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\n    },\n\n    /**\n     * Scale the image\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scale: function scale(scaleX) {\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n      var imageData = this.imageData;\n      var transformed = false;\n      scaleX = Number(scaleX);\n      scaleY = Number(scaleY);\n\n      if (this.ready && !this.disabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          imageData.scaleX = scaleX;\n          transformed = true;\n        }\n\n        if (isNumber(scaleY)) {\n          imageData.scaleY = scaleY;\n          transformed = true;\n        }\n\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     * @param {boolean} [rounded=false] - Indicate if round the data values or not.\n     * @returns {Object} The result cropped data.\n     */\n    getData: function getData() {\n      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var options = this.options,\n          imageData = this.imageData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var data;\n\n      if (this.ready && this.cropped) {\n        data = {\n          x: cropBoxData.left - canvasData.left,\n          y: cropBoxData.top - canvasData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n        var ratio = imageData.width / imageData.naturalWidth;\n        forEach(data, function (n, i) {\n          data[i] = n / ratio;\n        });\n\n        if (rounded) {\n          // In case rounding off leads to extra 1px in right or bottom border\n          // we should round the top-left corner and the dimension (#343).\n          var bottom = Math.round(data.y + data.height);\n          var right = Math.round(data.x + data.width);\n          data.x = Math.round(data.x);\n          data.y = Math.round(data.y);\n          data.width = right - data.x;\n          data.height = bottom - data.y;\n        }\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = imageData.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = imageData.scaleX || 1;\n        data.scaleY = imageData.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     * @param {Object} data - The new data.\n     * @returns {Cropper} this\n     */\n    setData: function setData(data) {\n      var options = this.options,\n          imageData = this.imageData,\n          canvasData = this.canvasData;\n      var cropBoxData = {};\n\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        var transformed = false;\n\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\n            imageData.rotate = data.rotate;\n            transformed = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\n            imageData.scaleX = data.scaleX;\n            transformed = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\n            imageData.scaleY = data.scaleY;\n            transformed = true;\n          }\n        }\n\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n\n        var ratio = imageData.width / imageData.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvasData.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvasData.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the container size data.\n     * @returns {Object} The result container data.\n     */\n    getContainerData: function getContainerData() {\n      return this.ready ? assign({}, this.containerData) : {};\n    },\n\n    /**\n     * Get the image position and size data.\n     * @returns {Object} The result image data.\n     */\n    getImageData: function getImageData() {\n      return this.sized ? assign({}, this.imageData) : {};\n    },\n\n    /**\n     * Get the canvas position and size data.\n     * @returns {Object} The result canvas data.\n     */\n    getCanvasData: function getCanvasData() {\n      var canvasData = this.canvasData;\n      var data = {};\n\n      if (this.ready) {\n        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {\n          data[n] = canvasData[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data.\n     * @param {Object} data - The new canvas data.\n     * @returns {Cropper} this\n     */\n    setCanvasData: function setCanvasData(data) {\n      var canvasData = this.canvasData;\n      var aspectRatio = canvasData.aspectRatio;\n\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvasData.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvasData.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvasData.width = data.width;\n          canvasData.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvasData.height = data.height;\n          canvasData.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the crop box position and size data.\n     * @returns {Object} The result crop box data.\n     */\n    getCropBoxData: function getCropBoxData() {\n      var cropBoxData = this.cropBoxData;\n      var data;\n\n      if (this.ready && this.cropped) {\n        data = {\n          left: cropBoxData.left,\n          top: cropBoxData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data.\n     * @param {Object} data - The new crop box data.\n     * @returns {Cropper} this\n     */\n    setCropBoxData: function setCropBoxData(data) {\n      var cropBoxData = this.cropBoxData;\n      var aspectRatio = this.options.aspectRatio;\n      var widthChanged;\n      var heightChanged;\n\n      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          cropBoxData.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBoxData.top = data.top;\n        }\n\n        if (isNumber(data.width) && data.width !== cropBoxData.width) {\n          widthChanged = true;\n          cropBoxData.width = data.width;\n        }\n\n        if (isNumber(data.height) && data.height !== cropBoxData.height) {\n          heightChanged = true;\n          cropBoxData.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (widthChanged) {\n            cropBoxData.height = cropBoxData.width / aspectRatio;\n          } else if (heightChanged) {\n            cropBoxData.width = cropBoxData.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n\n      return this;\n    },\n\n    /**\n     * Get a canvas drawn the cropped image.\n     * @param {Object} [options={}] - The config options.\n     * @returns {HTMLCanvasElement} - The result canvas.\n     */\n    getCroppedCanvas: function getCroppedCanvas() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.ready || !window.HTMLCanvasElement) {\n        return null;\n      }\n\n      var canvasData = this.canvasData;\n      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.\n\n      if (!this.cropped) {\n        return source;\n      }\n\n      var _this$getData = this.getData(),\n          initialX = _this$getData.x,\n          initialY = _this$getData.y,\n          initialWidth = _this$getData.width,\n          initialHeight = _this$getData.height;\n\n      var ratio = source.width / Math.floor(canvasData.naturalWidth);\n\n      if (ratio !== 1) {\n        initialX *= ratio;\n        initialY *= ratio;\n        initialWidth *= ratio;\n        initialHeight *= ratio;\n      }\n\n      var aspectRatio = initialWidth / initialHeight;\n      var maxSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.maxWidth || Infinity,\n        height: options.maxHeight || Infinity\n      });\n      var minSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.minWidth || 0,\n        height: options.minHeight || 0\n      }, 'cover');\n\n      var _getAdjustedSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.width || (ratio !== 1 ? source.width : initialWidth),\n        height: options.height || (ratio !== 1 ? source.height : initialHeight)\n      }),\n          width = _getAdjustedSizes.width,\n          height = _getAdjustedSizes.height;\n\n      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      canvas.width = normalizeDecimalNumber(width);\n      canvas.height = normalizeDecimalNumber(height);\n      context.fillStyle = options.fillColor || 'transparent';\n      context.fillRect(0, 0, width, height);\n      var _options$imageSmoothi = options.imageSmoothingEnabled,\n          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,\n          imageSmoothingQuality = options.imageSmoothingQuality;\n      context.imageSmoothingEnabled = imageSmoothingEnabled;\n\n      if (imageSmoothingQuality) {\n        context.imageSmoothingQuality = imageSmoothingQuality;\n      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n\n\n      var sourceWidth = source.width;\n      var sourceHeight = source.height; // Source canvas parameters\n\n      var srcX = initialX;\n      var srcY = initialY;\n      var srcWidth;\n      var srcHeight; // Destination canvas parameters\n\n      var dstX;\n      var dstY;\n      var dstWidth;\n      var dstHeight;\n\n      if (srcX <= -initialWidth || srcX > sourceWidth) {\n        srcX = 0;\n        srcWidth = 0;\n        dstX = 0;\n        dstWidth = 0;\n      } else if (srcX <= 0) {\n        dstX = -srcX;\n        srcX = 0;\n        srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n        dstWidth = srcWidth;\n      } else if (srcX <= sourceWidth) {\n        dstX = 0;\n        srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n        dstWidth = srcWidth;\n      }\n\n      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n        srcY = 0;\n        srcHeight = 0;\n        dstY = 0;\n        dstHeight = 0;\n      } else if (srcY <= 0) {\n        dstY = -srcY;\n        srcY = 0;\n        srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n        dstHeight = srcHeight;\n      } else if (srcY <= sourceHeight) {\n        dstY = 0;\n        srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n        dstHeight = srcHeight;\n      }\n\n      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid \"IndexSizeError\"\n\n      if (dstWidth > 0 && dstHeight > 0) {\n        var scale = width / initialWidth;\n        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n      } // All the numerical parameters should be integer for `drawImage`\n      // https://github.com/fengyuanchen/cropper/issues/476\n\n\n      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {\n        return Math.floor(normalizeDecimalNumber(param));\n      }))));\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box.\n     * @param {number} aspectRatio - The new aspect ratio.\n     * @returns {Cropper} this\n     */\n    setAspectRatio: function setAspectRatio(aspectRatio) {\n      var options = this.options;\n\n      if (!this.disabled && !isUndefined(aspectRatio)) {\n        // 0 -> NaN\n        options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n\n        if (this.ready) {\n          this.initCropBox();\n\n          if (this.cropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Change the drag mode.\n     * @param {string} mode - The new drag mode.\n     * @returns {Cropper} this\n     */\n    setDragMode: function setDragMode(mode) {\n      var options = this.options,\n          dragBox = this.dragBox,\n          face = this.face;\n\n      if (this.ready && !this.disabled) {\n        var croppable = mode === DRAG_MODE_CROP;\n        var movable = options.movable && mode === DRAG_MODE_MOVE;\n        mode = croppable || movable ? mode : DRAG_MODE_NONE;\n        options.dragMode = mode;\n        setData(dragBox, DATA_ACTION, mode);\n        toggleClass(dragBox, CLASS_CROP, croppable);\n        toggleClass(dragBox, CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n          // Sync drag mode to crop box when it is not movable\n          setData(face, DATA_ACTION, mode);\n          toggleClass(face, CLASS_CROP, croppable);\n          toggleClass(face, CLASS_MOVE, movable);\n        }\n      }\n\n      return this;\n    }\n  };\n\n  var AnotherCropper = WINDOW.Cropper;\n\n  var Cropper =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Create a new Cropper.\n     * @param {Element} element - The target element for cropping.\n     * @param {Object} [options={}] - The configuration options.\n     */\n    function Cropper(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Cropper);\n\n      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\n        throw new Error('The first argument is required and must be an <img> or <canvas> element.');\n      }\n\n      this.element = element;\n      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n      this.cropped = false;\n      this.disabled = false;\n      this.pointers = {};\n      this.ready = false;\n      this.reloading = false;\n      this.replaced = false;\n      this.sized = false;\n      this.sizing = false;\n      this.init();\n    }\n\n    _createClass(Cropper, [{\n      key: \"init\",\n      value: function init() {\n        var element = this.element;\n        var tagName = element.tagName.toLowerCase();\n        var url;\n\n        if (element[NAMESPACE]) {\n          return;\n        }\n\n        element[NAMESPACE] = this;\n\n        if (tagName === 'img') {\n          this.isImg = true; // e.g.: \"img/picture.jpg\"\n\n          url = element.getAttribute('src') || '';\n          this.originalUrl = url; // Stop when it's a blank image\n\n          if (!url) {\n            return;\n          } // e.g.: \"http://example.com/img/picture.jpg\"\n\n\n          url = element.src;\n        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {\n          url = element.toDataURL();\n        }\n\n        this.load(url);\n      }\n    }, {\n      key: \"load\",\n      value: function load(url) {\n        var _this = this;\n\n        if (!url) {\n          return;\n        }\n\n        this.url = url;\n        this.imageData = {};\n        var element = this.element,\n            options = this.options;\n\n        if (!options.rotatable && !options.scalable) {\n          options.checkOrientation = false;\n        } // Only IE10+ supports Typed Arrays\n\n\n        if (!options.checkOrientation || !window.ArrayBuffer) {\n          this.clone();\n          return;\n        } // Detect the mime type of the image directly if it is a Data URL\n\n\n        if (REGEXP_DATA_URL.test(url)) {\n          // Read ArrayBuffer from Data URL of JPEG images directly for better performance\n          if (REGEXP_DATA_URL_JPEG.test(url)) {\n            this.read(dataURLToArrayBuffer(url));\n          } else {\n            // Only a JPEG image may contains Exif Orientation information,\n            // the rest types of Data URLs are not necessary to check orientation at all.\n            this.clone();\n          }\n\n          return;\n        } // 1. Detect the mime type of the image by a XMLHttpRequest.\n        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.\n\n\n        var xhr = new XMLHttpRequest();\n        var clone = this.clone.bind(this);\n        this.reloading = true;\n        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:\n        // http, https, data, chrome, chrome-extension.\n        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy\n        // in some browsers as IE11 and Safari.\n\n        xhr.onabort = clone;\n        xhr.onerror = clone;\n        xhr.ontimeout = clone;\n\n        xhr.onprogress = function () {\n          // Abort the request directly if it not a JPEG image for better performance\n          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {\n            xhr.abort();\n          }\n        };\n\n        xhr.onload = function () {\n          _this.read(xhr.response);\n        };\n\n        xhr.onloadend = function () {\n          _this.reloading = false;\n          _this.xhr = null;\n        }; // Bust cache when there is a \"crossOrigin\" property to avoid browser cache error\n\n\n        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\n          url = addTimestamp(url);\n        }\n\n        xhr.open('GET', url);\n        xhr.responseType = 'arraybuffer';\n        xhr.withCredentials = element.crossOrigin === 'use-credentials';\n        xhr.send();\n      }\n    }, {\n      key: \"read\",\n      value: function read(arrayBuffer) {\n        var options = this.options,\n            imageData = this.imageData; // Reset the orientation value to its default value 1\n        // as some iOS browsers will render image with its orientation\n\n        var orientation = resetAndGetOrientation(arrayBuffer);\n        var rotate = 0;\n        var scaleX = 1;\n        var scaleY = 1;\n\n        if (orientation > 1) {\n          // Generate a new URL which has the default orientation value\n          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);\n\n          var _parseOrientation = parseOrientation(orientation);\n\n          rotate = _parseOrientation.rotate;\n          scaleX = _parseOrientation.scaleX;\n          scaleY = _parseOrientation.scaleY;\n        }\n\n        if (options.rotatable) {\n          imageData.rotate = rotate;\n        }\n\n        if (options.scalable) {\n          imageData.scaleX = scaleX;\n          imageData.scaleY = scaleY;\n        }\n\n        this.clone();\n      }\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var element = this.element,\n            url = this.url;\n        var crossOrigin = element.crossOrigin;\n        var crossOriginUrl = url;\n\n        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\n          if (!crossOrigin) {\n            crossOrigin = 'anonymous';\n          } // Bust cache when there is not a \"crossOrigin\" property (#519)\n\n\n          crossOriginUrl = addTimestamp(url);\n        }\n\n        this.crossOrigin = crossOrigin;\n        this.crossOriginUrl = crossOriginUrl;\n        var image = document.createElement('img');\n\n        if (crossOrigin) {\n          image.crossOrigin = crossOrigin;\n        }\n\n        image.src = crossOriginUrl || url;\n        image.alt = element.alt || 'The image to crop';\n        this.image = image;\n        image.onload = this.start.bind(this);\n        image.onerror = this.stop.bind(this);\n        addClass(image, CLASS_HIDE);\n        element.parentNode.insertBefore(image, element.nextSibling);\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,\n        // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n\n        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);\n\n        var done = function done(naturalWidth, naturalHeight) {\n          assign(_this2.imageData, {\n            naturalWidth: naturalWidth,\n            naturalHeight: naturalHeight,\n            aspectRatio: naturalWidth / naturalHeight\n          });\n          _this2.sizing = false;\n          _this2.sized = true;\n\n          _this2.build();\n        }; // Most modern browsers (excepts iOS WebKit)\n\n\n        if (image.naturalWidth && !isIOSWebKit) {\n          done(image.naturalWidth, image.naturalHeight);\n          return;\n        }\n\n        var sizingImage = document.createElement('img');\n        var body = document.body || document.documentElement;\n        this.sizingImage = sizingImage;\n\n        sizingImage.onload = function () {\n          done(sizingImage.width, sizingImage.height);\n\n          if (!isIOSWebKit) {\n            body.removeChild(sizingImage);\n          }\n        };\n\n        sizingImage.src = image.src; // iOS WebKit will convert the image automatically\n        // with its orientation once append it into DOM (#279)\n\n        if (!isIOSWebKit) {\n          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n          body.appendChild(sizingImage);\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        image.parentNode.removeChild(image);\n        this.image = null;\n      }\n    }, {\n      key: \"build\",\n      value: function build() {\n        if (!this.sized || this.ready) {\n          return;\n        }\n\n        var element = this.element,\n            options = this.options,\n            image = this.image; // Create cropper elements\n\n        var container = element.parentNode;\n        var template = document.createElement('div');\n        template.innerHTML = TEMPLATE;\n        var cropper = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n        var canvas = cropper.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n        var dragBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-drag-box\"));\n        var cropBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-crop-box\"));\n        var face = cropBox.querySelector(\".\".concat(NAMESPACE, \"-face\"));\n        this.container = container;\n        this.cropper = cropper;\n        this.canvas = canvas;\n        this.dragBox = dragBox;\n        this.cropBox = cropBox;\n        this.viewBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-view-box\"));\n        this.face = face;\n        canvas.appendChild(image); // Hide the original image\n\n        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image\n\n        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden\n\n        if (!this.isImg) {\n          removeClass(image, CLASS_HIDE);\n        }\n\n        this.initPreview();\n        this.bind();\n        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\n        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\n        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\n        addClass(cropBox, CLASS_HIDDEN);\n\n        if (!options.guides) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-dashed\")), CLASS_HIDDEN);\n        }\n\n        if (!options.center) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-center\")), CLASS_HIDDEN);\n        }\n\n        if (options.background) {\n          addClass(cropper, \"\".concat(NAMESPACE, \"-bg\"));\n        }\n\n        if (!options.highlight) {\n          addClass(face, CLASS_INVISIBLE);\n        }\n\n        if (options.cropBoxMovable) {\n          addClass(face, CLASS_MOVE);\n          setData(face, DATA_ACTION, ACTION_ALL);\n        }\n\n        if (!options.cropBoxResizable) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-line\")), CLASS_HIDDEN);\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-point\")), CLASS_HIDDEN);\n        }\n\n        this.render();\n        this.ready = true;\n        this.setDragMode(options.dragMode);\n\n        if (options.autoCrop) {\n          this.crop();\n        }\n\n        this.setData(options.data);\n\n        if (isFunction(options.ready)) {\n          addListener(element, EVENT_READY, options.ready, {\n            once: true\n          });\n        }\n\n        dispatchEvent(element, EVENT_READY);\n      }\n    }, {\n      key: \"unbuild\",\n      value: function unbuild() {\n        if (!this.ready) {\n          return;\n        }\n\n        this.ready = false;\n        this.unbind();\n        this.resetPreview();\n        this.cropper.parentNode.removeChild(this.cropper);\n        removeClass(this.element, CLASS_HIDDEN);\n      }\n    }, {\n      key: \"uncreate\",\n      value: function uncreate() {\n        if (this.ready) {\n          this.unbuild();\n          this.ready = false;\n          this.cropped = false;\n        } else if (this.sizing) {\n          this.sizingImage.onload = null;\n          this.sizing = false;\n          this.sized = false;\n        } else if (this.reloading) {\n          this.xhr.onabort = null;\n          this.xhr.abort();\n        } else if (this.image) {\n          this.stop();\n        }\n      }\n      /**\n       * Get the no conflict cropper class.\n       * @returns {Cropper} The cropper class.\n       */\n\n    }], [{\n      key: \"noConflict\",\n      value: function noConflict() {\n        window.Cropper = AnotherCropper;\n        return Cropper;\n      }\n      /**\n       * Change the default options.\n       * @param {Object} options - The new default options.\n       */\n\n    }, {\n      key: \"setDefaults\",\n      value: function setDefaults(options) {\n        assign(DEFAULTS, isPlainObject(options) && options);\n      }\n    }]);\n\n    return Cropper;\n  }();\n\n  assign(Cropper.prototype, render, preview, events, handlers, change, methods);\n\n  return Cropper;\n\n}));\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Fuse.js v3.3.1 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    // console.log('score', score, finalScore)\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // console.log('FINAL SCORE', finalScore)\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { limit: false };\n\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      if (opts.limit && typeof opts.limit === 'number') {\n        results = results.slice(0, opts.limit);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var currScore = 1;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            currScore *= nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? currScore : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      if (this.options.verbose) {\n        var cache = [];\n        this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results, function (key, value) {\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {\n            if (cache.indexOf(value) !== -1) {\n              // Circular reference found, discard key\n              return;\n            }\n            // Store value in our collection\n            cache.push(value);\n          }\n          return value;\n        }));\n        cache = null; // Enable garbage collection\n      }\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d0e60ac6dc1756d0403e","export const SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nexport const CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nexport const ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/config.js","const SELECTORS = {\n    HOOK: '.js-media-chooser-crop-preview-btn',\n    CONTAINER: '.js-media-cropper',\n    IMAGE: '.js-media-cropper-image',\n    META_CONTAINER: '.js-media-cropper-meta',\n    META_ITEM: '.js-media-cropper-meta-value',\n    VIEW_SELECT: '.js-media-cropper-view-select',\n    SAVE: '.js-media-cropper-save',\n};\n\nconst MODIFIERS = {\n    CROP_BOX_SMALL_CROPPED_AREA: 'media-cropper--crop-box-expanded',\n};\n\nconst CROP_BOX_THRESHOLD = 250;\n\nconst META_KEYS = ['width', 'height'];\n\nconst CROPPER_CONFIG = {\n    viewMode: 2,\n    movable: false,\n    rotatable: false,\n    scalable: false,\n    zoomable: false,\n    zoomOnTouch: false,\n    zoomOnWheel: false,\n};\n\nexport {\n    SELECTORS,\n    MODIFIERS,\n    CROP_BOX_THRESHOLD,\n    META_KEYS,\n    CROPPER_CONFIG,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/config.js","import { SELECTORS } from './config';\nimport { MediaCropper } from './MediaCropper';\n\nfunction initMediaCroppers(container = window.document) {\n    const PREVIEW_BTNS = [...container.querySelectorAll(SELECTORS.HOOK)];\n\n    document.addEventListener('modalOpen', (e) => {\n        const targetModal = e.detail;\n        const node = targetModal.querySelector(SELECTORS.CONTAINER);\n\n        if (!node.hasAttribute('data-initialized')) {\n            new MediaCropper(node);\n        }\n    });\n}\n\nexport { initMediaCroppers };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/index.js","import {SELECTORS} from './config';\nimport {initSearch} from './pagepart-search/initSearch';\n\nexport default class PagePartChooser {\n    static init(container = window.document) {\n        const pagePartChoosers = [...container.querySelectorAll(SELECTORS.PP_CHOOSER)];\n\n        pagePartChoosers.forEach((pagePartChooser) => {\n            initSearch(pagePartChooser);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/index.js","// This can be used to import extra polyfills that aren't in babel-polyfill already.\n\nconsole.log('polyfills');\n\n(function() {\n    if (!Object.entries) {\n\n        console.log('object.entries not available');\n\n        Object.entries = function( obj ){\n          var ownProps = Object.keys( obj ),\n              i = ownProps.length,\n              resArray = new Array(i); // preallocate the Array\n          while (i--)\n            resArray[i] = [ownProps[i], obj[ownProps[i]]];\n\n          return resArray;\n        };\n      }\n}());\n\n(function () {\n\n    if ( typeof window.CustomEvent === \"function\" ) return false;\n\n    function CustomEvent ( event, params ) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/polyfills.js","import Cropper from 'cropperjs';\nimport { SELECTORS, MODIFIERS, META_KEYS, CROP_BOX_THRESHOLD, CROPPER_CONFIG } from './config';\nimport { renderViewSelectOptions } from './renderViewSelectOptions';\n\nclass MediaCropper {\n    constructor(node) {\n        this.node = node;\n        this.image = this.node.querySelector(SELECTORS.IMAGE);\n        this.imagePath = this.node.hasAttribute('data-path') ? this.node.dataset.path : false;\n        this.metaContainer = this.node.querySelector(SELECTORS.META_CONTAINER);\n        this.viewSelect = this.metaContainer.querySelector(SELECTORS.VIEW_SELECT);\n        this.save = this.metaContainer.querySelector(SELECTORS.SAVE);\n        this.input = document.querySelector(`#${this.node.dataset.inputId}`);\n        this.metaValueNodes = {};\n        this.cropper = null;\n        this.viewData = {};\n        this.cropData = {};\n        this.savedCropData = this.input.value !== '' ? JSON.parse(this.input.value) : false;\n        this.initialized = false;\n\n        this.init();\n    }\n\n    getValueNodes() {\n        META_KEYS.forEach((key) => {\n            this.metaValueNodes[key] = this.metaContainer.querySelector(`${SELECTORS.META_ITEM}-${key}`);\n        });\n    }\n\n    updateValue({x, y, width, height}) {\n        let small_crop_box_area = false;\n\n        this.metaValueNodes.width.textContent = Math.ceil(width);\n        this.metaValueNodes.height.textContent = Math.ceil(height);\n\n        if ((width || height) <= CROP_BOX_THRESHOLD && !small_crop_box_area) {\n            this.node.classList.add(MODIFIERS.CROP_BOX_SMALL_CROPPED_AREA);\n            small_crop_box_area = true;\n        } else {\n            this.node.classList.remove(MODIFIERS.CROP_BOX_SMALL_CROPPED_AREA);\n            small_crop_box_area = false;\n        }\n\n        if (this.viewData && this.currentView) {\n            if (!this.cropData.hasOwnProperty(this.currentView)) {\n                this.cropData[this.currentView] = {};\n            }\n            this.cropData[this.currentView].start = [x, y];\n            this.cropData[this.currentView].size = [width, height];\n        }\n    }\n\n    addEventListeners() {\n        this.image.addEventListener('crop', () => {\n            const data = this.cropper.getData();\n            this.updateValue(data);\n        });\n\n        this.viewSelect.addEventListener('change', () => {\n            this.currentView = this.viewSelect.value;\n            this.cropper.destroy();\n            this.initCropper();\n        });\n\n        this.save.addEventListener('click', (e) => {\n            e.preventDefault();\n            this.input.value = JSON.stringify(this.cropData);\n        });\n    }\n\n    initCropper() {\n        const entries = Object.entries(this.viewData[this.currentView]);\n        const config = CROPPER_CONFIG;\n\n        for (const [key, value] of entries) {\n            config[key] = value;\n        }\n\n        if (this.cropData.hasOwnProperty(this.currentView)) {\n            const savedValues = this.savedCropData[this.currentView];\n\n            config.data = {\n                x: savedValues.start[0],\n                y: savedValues.start[1],\n                width: savedValues.size[0],\n                height: savedValues.size[1],\n            };\n        } else {\n            config.data = null;\n        }\n\n        this.cropper = new Cropper(this.image, config);\n    }\n\n    init() {\n        this.getValueNodes();\n\n        const viewData = JSON.parse(this.node.dataset.croppingViews);\n        if (viewData.length > 0) {\n            viewData.forEach((view) => {\n                this.viewData[view.name] = {};\n                this.viewData[view.name].aspectRatio = view.lockRatio ? view.height / view.width : NaN;\n                this.viewData[view.name].minCropBoxWidth = view.width ? view.width : 200;\n                this.viewData[view.name].minCropBoxHeight = view.height ? view.height : 100;\n            });\n            renderViewSelectOptions(this.viewSelect, this.viewData);\n\n            this.currentView = this.viewSelect.value;\n        }\n\n\n        if (this.imagePath) {\n            this.image.src = this.imagePath;\n        }\n\n        if (this.savedCropData) {\n            this.cropData = this.savedCropData;\n        }\n\n        this.initCropper();\n        this.addEventListeners();\n\n        this.initialized = true;\n        this.node.dataset.initialized = true;\n    }\n}\n\nexport { MediaCropper };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/MediaCropper.js","function renderViewSelectOptions(select, data) {\n    const OPTION_NAMES = Object.keys(data);\n    select.innerHTML = '';\n\n    OPTION_NAMES.forEach((name, i) => {\n        const option = document.createElement('option');\n        option.value = name;\n        option.textContent = name;\n\n        if (i === 0) {\n            option.selected = true;\n        }\n\n        select.appendChild(option);\n    });\n\n    select.disabled = OPTION_NAMES.length === 1;\n}\n\nexport { renderViewSelectOptions };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/MediaCropper/renderViewSelectOptions.js","import Fuse from 'fuse.js';\nimport {ATTRIBUTES, SELECTORS} from '../config';\nimport {resetSearch} from './resetSearch';\nimport {updateSearch} from './updateSearch';\n\nexport function initSearch(ppChooser) {\n    const ppTypes = JSON.parse(ppChooser.getAttribute(ATTRIBUTES.PP_TYPES));\n\n    const ppTypesSearchData = makePagePartDataSearchable(ppTypes);\n\n    const ppList = [...ppChooser.querySelectorAll(SELECTORS.PP_SEARCH_ITEM)];\n    const fuse = initFuse(ppTypesSearchData);\n\n    const searchField = ppChooser.querySelector(SELECTORS.PP_SEARCH_FIELD);\n    searchField.addEventListener('keyup', searchHandler);\n\n    const searchResetButton = ppChooser.querySelector(SELECTORS.PP_SEARCH_RESET);\n    searchResetButton.addEventListener('click', resetHandler);\n\n    function searchHandler() {\n        if (searchField.value.trim().length > 0) {\n            const searchResults = fuse.search(searchField.value);\n            updateSearch(ppList, searchResults);\n        } else {\n            resetSearch(ppList);\n        }\n    }\n\n    function resetHandler() {\n        searchField.value = '';\n        resetSearch(ppList);\n    }\n}\n\nfunction makePagePartDataSearchable(ppTypes) {\n    return ppTypes.map(({name, class: className}) => ({\n        name,\n        className: extractClassNameFromNamespace(className)\n    }));\n}\n\nfunction extractClassNameFromNamespace(ppClass) {\n    let className = ppClass;\n\n    const lastBackSlashIndex = className.lastIndexOf('\\\\');\n    if (lastBackSlashIndex !== -1) {\n        className = className.substring(lastBackSlashIndex + 1);\n    }\n\n    return className.replace('PagePart', '');\n}\n\nfunction initFuse(ppSearchData) {\n    return new Fuse(ppSearchData, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'className',\n            weight: 0.3 // The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/initSearch.js","import {CLASSES} from '../config';\n\nexport function resetSearch(searchItems) {\n    searchItems.forEach((item) => {\n        item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/resetSearch.js","import {CLASSES, ATTRIBUTES} from '../config';\n\nexport function updateSearch(searchItems, searchResults) {\n    searchItems.forEach((item) => {\n        const ppName = item.getAttribute(ATTRIBUTES.PP_NAME);\n\n        if (searchResults.includes(ppName)) {\n            item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser/pagepart-search/updateSearch.js","import './polyfills';\n\nimport PagePartChooser from './PagePartChooser';\nimport { initMediaCroppers } from './MediaCropper';\n\nfunction init() {\n    PagePartChooser.init();\n    initMediaCroppers();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', () => {\n        init();\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","/*!\n * Cropper.js v1.5.6\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2019-10-04T04:33:48.372Z\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Cropper = factory());\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  var WINDOW = IS_BROWSER ? window : {};\n  var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;\n  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\n  var NAMESPACE = 'cropper'; // Actions\n\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw'; // Classes\n\n  var CLASS_CROP = \"\".concat(NAMESPACE, \"-crop\");\n  var CLASS_DISABLED = \"\".concat(NAMESPACE, \"-disabled\");\n  var CLASS_HIDDEN = \"\".concat(NAMESPACE, \"-hidden\");\n  var CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\n  var CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\n  var CLASS_MODAL = \"\".concat(NAMESPACE, \"-modal\");\n  var CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\"); // Data keys\n\n  var DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n  var DATA_PREVIEW = \"\".concat(NAMESPACE, \"Preview\"); // Drag modes\n\n  var DRAG_MODE_CROP = 'crop';\n  var DRAG_MODE_MOVE = 'move';\n  var DRAG_MODE_NONE = 'none'; // Events\n\n  var EVENT_CROP = 'crop';\n  var EVENT_CROP_END = 'cropend';\n  var EVENT_CROP_MOVE = 'cropmove';\n  var EVENT_CROP_START = 'cropstart';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\n  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\n  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\n  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\n  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\n  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\n  var EVENT_READY = 'ready';\n  var EVENT_RESIZE = 'resize';\n  var EVENT_WHEEL = 'wheel';\n  var EVENT_ZOOM = 'zoom'; // Mime types\n\n  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps\n\n  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;\n  var REGEXP_DATA_URL = /^data:/;\n  var REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\n  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc\n  // Inspired by the default width and height of a canvas element.\n\n  var MIN_CONTAINER_WIDTH = 200;\n  var MIN_CONTAINER_HEIGHT = 100;\n\n  var DEFAULTS = {\n    // Define the view mode of the cropper\n    viewMode: 0,\n    // 0, 1, 2, 3\n    // Define the dragging mode of the cropper\n    dragMode: DRAG_MODE_CROP,\n    // 'crop', 'move' or 'none'\n    // Define the initial aspect ratio of the crop box\n    initialAspectRatio: NaN,\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n    // An object with the previous cropping result data\n    data: null,\n    // A selector for adding extra containers to preview\n    preview: '',\n    // Re-render the cropper when resize the window\n    responsive: true,\n    // Restore the cropped area after resize the window\n    restore: true,\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n    // Show the black modal\n    modal: true,\n    // Show the dashed lines for guiding\n    guides: true,\n    // Show the center indicator for guiding\n    center: true,\n    // Show the white modal to highlight the crop box\n    highlight: true,\n    // Show the grid background\n    background: true,\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n    // Enable to move the image\n    movable: true,\n    // Enable to rotate the image\n    rotatable: true,\n    // Enable to scale the image\n    scalable: true,\n    // Enable to zoom the image\n    zoomable: true,\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n    // Enable to move the crop box\n    cropBoxMovable: true,\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n    // Shortcuts of events\n    ready: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  var TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + '</div>' + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + '</div>' + '</div>';\n\n  /**\n   * Check if the given value is not a number.\n   */\n\n  var isNaN = Number.isNaN || WINDOW.isNaN;\n  /**\n   * Check if the given value is a number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n   */\n\n  function isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n  }\n  /**\n   * Check if the given value is a positive number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n   */\n\n  var isPositiveNumber = function isPositiveNumber(value) {\n    return value > 0 && value < Infinity;\n  };\n  /**\n   * Check if the given value is undefined.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n   */\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n  /**\n   * Check if the given value is an object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n   */\n\n  function isObject(value) {\n    return _typeof(value) === 'object' && value !== null;\n  }\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\n   * Check if the given value is a plain object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n   */\n\n  function isPlainObject(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n\n    try {\n      var _constructor = value.constructor;\n      var prototype = _constructor.prototype;\n      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Check if the given value is a function.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  var slice = Array.prototype.slice;\n  /**\n   * Convert array-like or iterable object to an array.\n   * @param {*} value - The value to convert.\n   * @returns {Array} Returns a new array.\n   */\n\n  function toArray(value) {\n    return Array.from ? Array.from(value) : slice.call(value);\n  }\n  /**\n   * Iterate the given data.\n   * @param {*} data - The data to iterate.\n   * @param {Function} callback - The process function for each element.\n   * @returns {*} The original data.\n   */\n\n  function forEach(data, callback) {\n    if (data && isFunction(callback)) {\n      if (Array.isArray(data) || isNumber(data.length)\n      /* array-like */\n      ) {\n          toArray(data).forEach(function (value, key) {\n            callback.call(data, value, key, data);\n          });\n        } else if (isObject(data)) {\n        Object.keys(data).forEach(function (key) {\n          callback.call(data, data[key], key, data);\n        });\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Extend the given object.\n   * @param {*} target - The target object to extend.\n   * @param {*} args - The rest objects for merging to the target object.\n   * @returns {Object} The extended object.\n   */\n\n  var assign = Object.assign || function assign(target) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (isObject(target) && args.length > 0) {\n      args.forEach(function (arg) {\n        if (isObject(arg)) {\n          Object.keys(arg).forEach(function (key) {\n            target[key] = arg[key];\n          });\n        }\n      });\n    }\n\n    return target;\n  };\n  var REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n  /**\n   * Normalize decimal number.\n   * Check out {@link http://0.30000000000000004.com/}\n   * @param {number} value - The value to normalize.\n   * @param {number} [times=100000000000] - The times for normalizing.\n   * @returns {number} Returns the normalized number.\n   */\n\n  function normalizeDecimalNumber(value) {\n    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n  }\n  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;\n  /**\n   * Apply styles to the given element.\n   * @param {Element} element - The target element.\n   * @param {Object} styles - The styles for applying.\n   */\n\n  function setStyle(element, styles) {\n    var style = element.style;\n    forEach(styles, function (value, property) {\n      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n        value = \"\".concat(value, \"px\");\n      }\n\n      style[property] = value;\n    });\n  }\n  /**\n   * Check if the given element has a special class.\n   * @param {Element} element - The element to check.\n   * @param {string} value - The class to search.\n   * @returns {boolean} Returns `true` if the special class was found.\n   */\n\n  function hasClass(element, value) {\n    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n  }\n  /**\n   * Add classes to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be added.\n   */\n\n  function addClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        addClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.add(value);\n      return;\n    }\n\n    var className = element.className.trim();\n\n    if (!className) {\n      element.className = value;\n    } else if (className.indexOf(value) < 0) {\n      element.className = \"\".concat(className, \" \").concat(value);\n    }\n  }\n  /**\n   * Remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be removed.\n   */\n\n  function removeClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        removeClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.remove(value);\n      return;\n    }\n\n    if (element.className.indexOf(value) >= 0) {\n      element.className = element.className.replace(value, '');\n    }\n  }\n  /**\n   * Add or remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be toggled.\n   * @param {boolean} added - Add only.\n   */\n\n  function toggleClass(element, value, added) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        toggleClass(elem, value, added);\n      });\n      return;\n    } // IE10-11 doesn't support the second parameter of `classList.toggle`\n\n\n    if (added) {\n      addClass(element, value);\n    } else {\n      removeClass(element, value);\n    }\n  }\n  var REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\n  /**\n   * Transform the given string from camelCase to kebab-case\n   * @param {string} value - The value to transform.\n   * @returns {string} The transformed value.\n   */\n\n  function toParamCase(value) {\n    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();\n  }\n  /**\n   * Get data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to get.\n   * @returns {string} The data value.\n   */\n\n  function getData(element, name) {\n    if (isObject(element[name])) {\n      return element[name];\n    }\n\n    if (element.dataset) {\n      return element.dataset[name];\n    }\n\n    return element.getAttribute(\"data-\".concat(toParamCase(name)));\n  }\n  /**\n   * Set data to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to set.\n   * @param {string} data - The data value.\n   */\n\n  function setData(element, name, data) {\n    if (isObject(data)) {\n      element[name] = data;\n    } else if (element.dataset) {\n      element.dataset[name] = data;\n    } else {\n      element.setAttribute(\"data-\".concat(toParamCase(name)), data);\n    }\n  }\n  /**\n   * Remove data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to remove.\n   */\n\n  function removeData(element, name) {\n    if (isObject(element[name])) {\n      try {\n        delete element[name];\n      } catch (error) {\n        element[name] = undefined;\n      }\n    } else if (element.dataset) {\n      // #128 Safari not allows to delete dataset property\n      try {\n        delete element.dataset[name];\n      } catch (error) {\n        element.dataset[name] = undefined;\n      }\n    } else {\n      element.removeAttribute(\"data-\".concat(toParamCase(name)));\n    }\n  }\n  var REGEXP_SPACES = /\\s\\s*/;\n\n  var onceSupported = function () {\n    var supported = false;\n\n    if (IS_BROWSER) {\n      var once = false;\n\n      var listener = function listener() {};\n\n      var options = Object.defineProperty({}, 'once', {\n        get: function get() {\n          supported = true;\n          return once;\n        },\n\n        /**\n         * This setter can fix a `TypeError` in strict mode\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n         * @param {boolean} value - The value to set\n         */\n        set: function set(value) {\n          once = value;\n        }\n      });\n      WINDOW.addEventListener('test', listener, options);\n      WINDOW.removeEventListener('test', listener, options);\n    }\n\n    return supported;\n  }();\n  /**\n   * Remove event listener from the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n\n  function removeListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (!onceSupported) {\n        var listeners = element.listeners;\n\n        if (listeners && listeners[event] && listeners[event][listener]) {\n          handler = listeners[event][listener];\n          delete listeners[event][listener];\n\n          if (Object.keys(listeners[event]).length === 0) {\n            delete listeners[event];\n          }\n\n          if (Object.keys(listeners).length === 0) {\n            delete element.listeners;\n          }\n        }\n      }\n\n      element.removeEventListener(event, handler, options);\n    });\n  }\n  /**\n   * Add event listener to the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n  function addListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (options.once && !onceSupported) {\n        var _element$listeners = element.listeners,\n            listeners = _element$listeners === void 0 ? {} : _element$listeners;\n\n        _handler = function handler() {\n          delete listeners[event][listener];\n          element.removeEventListener(event, _handler, options);\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          listener.apply(element, args);\n        };\n\n        if (!listeners[event]) {\n          listeners[event] = {};\n        }\n\n        if (listeners[event][listener]) {\n          element.removeEventListener(event, listeners[event][listener], options);\n        }\n\n        listeners[event][listener] = _handler;\n        element.listeners = listeners;\n      }\n\n      element.addEventListener(event, _handler, options);\n    });\n  }\n  /**\n   * Dispatch event on the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Object} data - The additional event data.\n   * @returns {boolean} Indicate if the event is default prevented or not.\n   */\n\n  function dispatchEvent(element, type, data) {\n    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors\n\n    if (isFunction(Event) && isFunction(CustomEvent)) {\n      event = new CustomEvent(type, {\n        detail: data,\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent(type, true, true, data);\n    }\n\n    return element.dispatchEvent(event);\n  }\n  /**\n   * Get the offset base on the document.\n   * @param {Element} element - The target element.\n   * @returns {Object} The offset data.\n   */\n\n  function getOffset(element) {\n    var box = element.getBoundingClientRect();\n    return {\n      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n      top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n    };\n  }\n  var location = WINDOW.location;\n  var REGEXP_ORIGINS = /^(\\w+:)\\/\\/([^:/?#]*):?(\\d*)/i;\n  /**\n   * Check if the given URL is a cross origin URL.\n   * @param {string} url - The target URL.\n   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\n   */\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(REGEXP_ORIGINS);\n    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\n  }\n  /**\n   * Add timestamp to the given URL.\n   * @param {string} url - The target URL.\n   * @returns {string} The result URL.\n   */\n\n  function addTimestamp(url) {\n    var timestamp = \"timestamp=\".concat(new Date().getTime());\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;\n  }\n  /**\n   * Get transforms base on the given object.\n   * @param {Object} obj - The target object.\n   * @returns {string} A string contains transform values.\n   */\n\n  function getTransforms(_ref) {\n    var rotate = _ref.rotate,\n        scaleX = _ref.scaleX,\n        scaleY = _ref.scaleY,\n        translateX = _ref.translateX,\n        translateY = _ref.translateY;\n    var values = [];\n\n    if (isNumber(translateX) && translateX !== 0) {\n      values.push(\"translateX(\".concat(translateX, \"px)\"));\n    }\n\n    if (isNumber(translateY) && translateY !== 0) {\n      values.push(\"translateY(\".concat(translateY, \"px)\"));\n    } // Rotate should come first before scale to match orientation transform\n\n\n    if (isNumber(rotate) && rotate !== 0) {\n      values.push(\"rotate(\".concat(rotate, \"deg)\"));\n    }\n\n    if (isNumber(scaleX) && scaleX !== 1) {\n      values.push(\"scaleX(\".concat(scaleX, \")\"));\n    }\n\n    if (isNumber(scaleY) && scaleY !== 1) {\n      values.push(\"scaleY(\".concat(scaleY, \")\"));\n    }\n\n    var transform = values.length ? values.join(' ') : 'none';\n    return {\n      WebkitTransform: transform,\n      msTransform: transform,\n      transform: transform\n    };\n  }\n  /**\n   * Get the max ratio of a group of pointers.\n   * @param {string} pointers - The target pointers.\n   * @returns {number} The result ratio.\n   */\n\n  function getMaxZoomRatio(pointers) {\n    var pointers2 = _objectSpread2({}, pointers);\n\n    var ratios = [];\n    forEach(pointers, function (pointer, pointerId) {\n      delete pointers2[pointerId];\n      forEach(pointers2, function (pointer2) {\n        var x1 = Math.abs(pointer.startX - pointer2.startX);\n        var y1 = Math.abs(pointer.startY - pointer2.startY);\n        var x2 = Math.abs(pointer.endX - pointer2.endX);\n        var y2 = Math.abs(pointer.endY - pointer2.endY);\n        var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n        var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n        var ratio = (z2 - z1) / z1;\n        ratios.push(ratio);\n      });\n    });\n    ratios.sort(function (a, b) {\n      return Math.abs(a) < Math.abs(b);\n    });\n    return ratios[0];\n  }\n  /**\n   * Get a pointer from an event object.\n   * @param {Object} event - The target event object.\n   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n   * @returns {Object} The result pointer contains start and/or end point coordinates.\n   */\n\n  function getPointer(_ref2, endOnly) {\n    var pageX = _ref2.pageX,\n        pageY = _ref2.pageY;\n    var end = {\n      endX: pageX,\n      endY: pageY\n    };\n    return endOnly ? end : _objectSpread2({\n      startX: pageX,\n      startY: pageY\n    }, end);\n  }\n  /**\n   * Get the center point coordinate of a group of pointers.\n   * @param {Object} pointers - The target pointers.\n   * @returns {Object} The center point coordinate.\n   */\n\n  function getPointersCenter(pointers) {\n    var pageX = 0;\n    var pageY = 0;\n    var count = 0;\n    forEach(pointers, function (_ref3) {\n      var startX = _ref3.startX,\n          startY = _ref3.startY;\n      pageX += startX;\n      pageY += startY;\n      count += 1;\n    });\n    pageX /= count;\n    pageY /= count;\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n  /**\n   * Get the max sizes in a rectangle under the given aspect ratio.\n   * @param {Object} data - The original sizes.\n   * @param {string} [type='contain'] - The adjust type.\n   * @returns {Object} The result sizes.\n   */\n\n  function getAdjustedSizes(_ref4) // or 'cover'\n  {\n    var aspectRatio = _ref4.aspectRatio,\n        height = _ref4.height,\n        width = _ref4.width;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\n    var isValidWidth = isPositiveNumber(width);\n    var isValidHeight = isPositiveNumber(height);\n\n    if (isValidWidth && isValidHeight) {\n      var adjustedWidth = height * aspectRatio;\n\n      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n        height = width / aspectRatio;\n      } else {\n        width = height * aspectRatio;\n      }\n    } else if (isValidWidth) {\n      height = width / aspectRatio;\n    } else if (isValidHeight) {\n      width = height * aspectRatio;\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n  /**\n   * Get the new sizes of a rectangle after rotated.\n   * @param {Object} data - The original sizes.\n   * @returns {Object} The result sizes.\n   */\n\n  function getRotatedSizes(_ref5) {\n    var width = _ref5.width,\n        height = _ref5.height,\n        degree = _ref5.degree;\n    degree = Math.abs(degree) % 180;\n\n    if (degree === 90) {\n      return {\n        width: height,\n        height: width\n      };\n    }\n\n    var arc = degree % 90 * Math.PI / 180;\n    var sinArc = Math.sin(arc);\n    var cosArc = Math.cos(arc);\n    var newWidth = width * cosArc + height * sinArc;\n    var newHeight = width * sinArc + height * cosArc;\n    return degree > 90 ? {\n      width: newHeight,\n      height: newWidth\n    } : {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n  /**\n   * Get a canvas which drew the given image.\n   * @param {HTMLImageElement} image - The image for drawing.\n   * @param {Object} imageData - The image data.\n   * @param {Object} canvasData - The canvas data.\n   * @param {Object} options - The options.\n   * @returns {HTMLCanvasElement} The result canvas.\n   */\n\n  function getSourceCanvas(image, _ref6, _ref7, _ref8) {\n    var imageAspectRatio = _ref6.aspectRatio,\n        imageNaturalWidth = _ref6.naturalWidth,\n        imageNaturalHeight = _ref6.naturalHeight,\n        _ref6$rotate = _ref6.rotate,\n        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,\n        _ref6$scaleX = _ref6.scaleX,\n        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,\n        _ref6$scaleY = _ref6.scaleY,\n        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;\n    var aspectRatio = _ref7.aspectRatio,\n        naturalWidth = _ref7.naturalWidth,\n        naturalHeight = _ref7.naturalHeight;\n    var _ref8$fillColor = _ref8.fillColor,\n        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,\n        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,\n        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,\n        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,\n        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,\n        _ref8$maxWidth = _ref8.maxWidth,\n        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,\n        _ref8$maxHeight = _ref8.maxHeight,\n        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,\n        _ref8$minWidth = _ref8.minWidth,\n        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,\n        _ref8$minHeight = _ref8.minHeight,\n        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var maxSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var minSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\n    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as\n    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\n\n    var destMaxSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var destMinSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\n    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\n    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];\n    canvas.width = normalizeDecimalNumber(width);\n    canvas.height = normalizeDecimalNumber(height);\n    context.fillStyle = fillColor;\n    context.fillRect(0, 0, width, height);\n    context.save();\n    context.translate(width / 2, height / 2);\n    context.rotate(rotate * Math.PI / 180);\n    context.scale(scaleX, scaleY);\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\n    context.imageSmoothingQuality = imageSmoothingQuality;\n    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {\n      return Math.floor(normalizeDecimalNumber(param));\n    }))));\n    context.restore();\n    return canvas;\n  }\n  var fromCharCode = String.fromCharCode;\n  /**\n   * Get string from char code in data view.\n   * @param {DataView} dataView - The data view for read.\n   * @param {number} start - The start index.\n   * @param {number} length - The read length.\n   * @returns {string} The read result.\n   */\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    length += start;\n\n    for (var i = start; i < length; i += 1) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n  var REGEXP_DATA_URL_HEAD = /^data:.*,/;\n  /**\n   * Transform Data URL to array buffer.\n   * @param {string} dataURL - The Data URL to transform.\n   * @returns {ArrayBuffer} The result array buffer.\n   */\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var arrayBuffer = new ArrayBuffer(binary.length);\n    var uint8 = new Uint8Array(arrayBuffer);\n    forEach(uint8, function (value, i) {\n      uint8[i] = binary.charCodeAt(i);\n    });\n    return arrayBuffer;\n  }\n  /**\n   * Transform array buffer to Data URL.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n   * @param {string} mimeType - The mime type of the Data URL.\n   * @returns {string} The result Data URL.\n   */\n\n  function arrayBufferToDataURL(arrayBuffer, mimeType) {\n    var chunks = []; // Chunk Typed Array for better performance (#435)\n\n    var chunkSize = 8192;\n    var uint8 = new Uint8Array(arrayBuffer);\n\n    while (uint8.length > 0) {\n      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n      // eslint-disable-next-line prefer-spread\n      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n      uint8 = uint8.subarray(chunkSize);\n    }\n\n    return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\n  }\n  /**\n   * Get orientation value from given array buffer.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n   * @returns {number} The read orientation value.\n   */\n\n  function resetAndGetOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var orientation; // Ignores range error when the image does not have correct Exif information\n\n    try {\n      var littleEndian;\n      var app1Start;\n      var ifdStart; // Only handle JPEG image (start by 0xFFD8)\n\n      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n        var length = dataView.byteLength;\n        var offset = 2;\n\n        while (offset + 1 < length) {\n          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n            app1Start = offset;\n            break;\n          }\n\n          offset += 1;\n        }\n      }\n\n      if (app1Start) {\n        var exifIDCode = app1Start + 4;\n        var tiffOffset = app1Start + 10;\n\n        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n          var endianness = dataView.getUint16(tiffOffset);\n          littleEndian = endianness === 0x4949;\n\n          if (littleEndian || endianness === 0x4D4D\n          /* bigEndian */\n          ) {\n              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n                if (firstIFDOffset >= 0x00000008) {\n                  ifdStart = tiffOffset + firstIFDOffset;\n                }\n              }\n            }\n        }\n      }\n\n      if (ifdStart) {\n        var _length = dataView.getUint16(ifdStart, littleEndian);\n\n        var _offset;\n\n        var i;\n\n        for (i = 0; i < _length; i += 1) {\n          _offset = ifdStart + i * 12 + 2;\n\n          if (dataView.getUint16(_offset, littleEndian) === 0x0112\n          /* Orientation */\n          ) {\n              // 8 is the offset of the current tag's value\n              _offset += 8; // Get the original orientation value\n\n              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value\n\n              dataView.setUint16(_offset, 1, littleEndian);\n              break;\n            }\n        }\n      }\n    } catch (error) {\n      orientation = 1;\n    }\n\n    return orientation;\n  }\n  /**\n   * Parse Exif Orientation value.\n   * @param {number} orientation - The orientation to parse.\n   * @returns {Object} The parsed result.\n   */\n\n  function parseOrientation(orientation) {\n    var rotate = 0;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    switch (orientation) {\n      // Flip horizontal\n      case 2:\n        scaleX = -1;\n        break;\n      // Rotate left 180\n\n      case 3:\n        rotate = -180;\n        break;\n      // Flip vertical\n\n      case 4:\n        scaleY = -1;\n        break;\n      // Flip vertical and rotate right 90\n\n      case 5:\n        rotate = 90;\n        scaleY = -1;\n        break;\n      // Rotate right 90\n\n      case 6:\n        rotate = 90;\n        break;\n      // Flip horizontal and rotate right 90\n\n      case 7:\n        rotate = 90;\n        scaleX = -1;\n        break;\n      // Rotate left 90\n\n      case 8:\n        rotate = -90;\n        break;\n\n      default:\n    }\n\n    return {\n      rotate: rotate,\n      scaleX: scaleX,\n      scaleY: scaleY\n    };\n  }\n\n  var render = {\n    render: function render() {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n      this.renderCanvas();\n\n      if (this.cropped) {\n        this.renderCropBox();\n      }\n    },\n    initContainer: function initContainer() {\n      var element = this.element,\n          options = this.options,\n          container = this.container,\n          cropper = this.cropper;\n      addClass(cropper, CLASS_HIDDEN);\n      removeClass(element, CLASS_HIDDEN);\n      var containerData = {\n        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),\n        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)\n      };\n      this.containerData = containerData;\n      setStyle(cropper, {\n        width: containerData.width,\n        height: containerData.height\n      });\n      addClass(element, CLASS_HIDDEN);\n      removeClass(cropper, CLASS_HIDDEN);\n    },\n    // Canvas (image wrapper)\n    initCanvas: function initCanvas() {\n      var containerData = this.containerData,\n          imageData = this.imageData;\n      var viewMode = this.options.viewMode;\n      var rotated = Math.abs(imageData.rotate) % 180 === 90;\n      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\n      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerData.width;\n      var canvasHeight = containerData.height;\n\n      if (containerData.height * aspectRatio > containerData.width) {\n        if (viewMode === 3) {\n          canvasWidth = containerData.height * aspectRatio;\n        } else {\n          canvasHeight = containerData.width / aspectRatio;\n        }\n      } else if (viewMode === 3) {\n        canvasHeight = containerData.width / aspectRatio;\n      } else {\n        canvasWidth = containerData.height * aspectRatio;\n      }\n\n      var canvasData = {\n        aspectRatio: aspectRatio,\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n      canvasData.left = (containerData.width - canvasWidth) / 2;\n      canvasData.top = (containerData.height - canvasHeight) / 2;\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      this.canvasData = canvasData;\n      this.limited = viewMode === 1 || viewMode === 2;\n      this.limitCanvas(true, true);\n      this.initialImageData = assign({}, imageData);\n      this.initialCanvasData = assign({}, canvasData);\n    },\n    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\n      var options = this.options,\n          containerData = this.containerData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var viewMode = options.viewMode;\n      var aspectRatio = canvasData.aspectRatio;\n      var cropped = this.cropped && cropBoxData;\n\n      if (sizeLimited) {\n        var minCanvasWidth = Number(options.minCanvasWidth) || 0;\n        var minCanvasHeight = Number(options.minCanvasHeight) || 0;\n\n        if (viewMode > 1) {\n          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\n          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\n\n          if (viewMode === 3) {\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        } else if (viewMode > 0) {\n          if (minCanvasWidth) {\n            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\n          } else if (minCanvasHeight) {\n            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\n          } else if (cropped) {\n            minCanvasWidth = cropBoxData.width;\n            minCanvasHeight = cropBoxData.height;\n\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        }\n\n        var _getAdjustedSizes = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: minCanvasWidth,\n          height: minCanvasHeight\n        });\n\n        minCanvasWidth = _getAdjustedSizes.width;\n        minCanvasHeight = _getAdjustedSizes.height;\n        canvasData.minWidth = minCanvasWidth;\n        canvasData.minHeight = minCanvasHeight;\n        canvasData.maxWidth = Infinity;\n        canvasData.maxHeight = Infinity;\n      }\n\n      if (positionLimited) {\n        if (viewMode > (cropped ? 0 : 1)) {\n          var newCanvasLeft = containerData.width - canvasData.width;\n          var newCanvasTop = containerData.height - canvasData.height;\n          canvasData.minLeft = Math.min(0, newCanvasLeft);\n          canvasData.minTop = Math.min(0, newCanvasTop);\n          canvasData.maxLeft = Math.max(0, newCanvasLeft);\n          canvasData.maxTop = Math.max(0, newCanvasTop);\n\n          if (cropped && this.limited) {\n            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\n            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\n            canvasData.maxLeft = cropBoxData.left;\n            canvasData.maxTop = cropBoxData.top;\n\n            if (viewMode === 2) {\n              if (canvasData.width >= containerData.width) {\n                canvasData.minLeft = Math.min(0, newCanvasLeft);\n                canvasData.maxLeft = Math.max(0, newCanvasLeft);\n              }\n\n              if (canvasData.height >= containerData.height) {\n                canvasData.minTop = Math.min(0, newCanvasTop);\n                canvasData.maxTop = Math.max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvasData.minLeft = -canvasData.width;\n          canvasData.minTop = -canvasData.height;\n          canvasData.maxLeft = containerData.width;\n          canvasData.maxTop = containerData.height;\n        }\n      }\n    },\n    renderCanvas: function renderCanvas(changed, transformed) {\n      var canvasData = this.canvasData,\n          imageData = this.imageData;\n\n      if (transformed) {\n        var _getRotatedSizes = getRotatedSizes({\n          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\n          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\n          degree: imageData.rotate || 0\n        }),\n            naturalWidth = _getRotatedSizes.width,\n            naturalHeight = _getRotatedSizes.height;\n\n        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\n        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\n        canvasData.left -= (width - canvasData.width) / 2;\n        canvasData.top -= (height - canvasData.height) / 2;\n        canvasData.width = width;\n        canvasData.height = height;\n        canvasData.aspectRatio = naturalWidth / naturalHeight;\n        canvasData.naturalWidth = naturalWidth;\n        canvasData.naturalHeight = naturalHeight;\n        this.limitCanvas(true, false);\n      }\n\n      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\n        canvasData.left = canvasData.oldLeft;\n      }\n\n      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\n        canvasData.top = canvasData.oldTop;\n      }\n\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n      this.limitCanvas(false, true);\n      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\n      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      setStyle(this.canvas, assign({\n        width: canvasData.width,\n        height: canvasData.height\n      }, getTransforms({\n        translateX: canvasData.left,\n        translateY: canvasData.top\n      })));\n      this.renderImage(changed);\n\n      if (this.cropped && this.limited) {\n        this.limitCropBox(true, true);\n      }\n    },\n    renderImage: function renderImage(changed) {\n      var canvasData = this.canvasData,\n          imageData = this.imageData;\n      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\n      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\n      assign(imageData, {\n        width: width,\n        height: height,\n        left: (canvasData.width - width) / 2,\n        top: (canvasData.height - height) / 2\n      });\n      setStyle(this.image, assign({\n        width: imageData.width,\n        height: imageData.height\n      }, getTransforms(assign({\n        translateX: imageData.left,\n        translateY: imageData.top\n      }, imageData))));\n\n      if (changed) {\n        this.output();\n      }\n    },\n    initCropBox: function initCropBox() {\n      var options = this.options,\n          canvasData = this.canvasData;\n      var aspectRatio = options.aspectRatio || options.initialAspectRatio;\n      var autoCropArea = Number(options.autoCropArea) || 0.8;\n      var cropBoxData = {\n        width: canvasData.width,\n        height: canvasData.height\n      };\n\n      if (aspectRatio) {\n        if (canvasData.height * aspectRatio > canvasData.width) {\n          cropBoxData.height = cropBoxData.width / aspectRatio;\n        } else {\n          cropBoxData.width = cropBoxData.height * aspectRatio;\n        }\n      }\n\n      this.cropBoxData = cropBoxData;\n      this.limitCropBox(true, true); // Initialize auto crop area\n\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than \"minWidth/Height\"\n\n      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\n      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\n      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\n      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n      this.initialCropBoxData = assign({}, cropBoxData);\n    },\n    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\n      var options = this.options,\n          containerData = this.containerData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData,\n          limited = this.limited;\n      var aspectRatio = options.aspectRatio;\n\n      if (sizeLimited) {\n        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\n        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\n        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\n        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height\n\n        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\n        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        } // The minWidth/Height must be less than maxWidth/Height\n\n\n        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\n        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\n        cropBoxData.maxWidth = maxCropBoxWidth;\n        cropBoxData.maxHeight = maxCropBoxHeight;\n      }\n\n      if (positionLimited) {\n        if (limited) {\n          cropBoxData.minLeft = Math.max(0, canvasData.left);\n          cropBoxData.minTop = Math.max(0, canvasData.top);\n          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\n          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\n        } else {\n          cropBoxData.minLeft = 0;\n          cropBoxData.minTop = 0;\n          cropBoxData.maxLeft = containerData.width - cropBoxData.width;\n          cropBoxData.maxTop = containerData.height - cropBoxData.height;\n        }\n      }\n    },\n    renderCropBox: function renderCropBox() {\n      var options = this.options,\n          containerData = this.containerData,\n          cropBoxData = this.cropBoxData;\n\n      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\n        cropBoxData.left = cropBoxData.oldLeft;\n      }\n\n      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\n        cropBoxData.top = cropBoxData.oldTop;\n      }\n\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n      this.limitCropBox(false, true);\n      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\n      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n\n      if (options.movable && options.cropBoxMovable) {\n        // Turn to move the canvas when the crop box is equal to the container\n        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      setStyle(this.cropBox, assign({\n        width: cropBoxData.width,\n        height: cropBoxData.height\n      }, getTransforms({\n        translateX: cropBoxData.left,\n        translateY: cropBoxData.top\n      })));\n\n      if (this.cropped && this.limited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.disabled) {\n        this.output();\n      }\n    },\n    output: function output() {\n      this.preview();\n      dispatchEvent(this.element, EVENT_CROP, this.getData());\n    }\n  };\n\n  var preview = {\n    initPreview: function initPreview() {\n      var element = this.element,\n          crossOrigin = this.crossOrigin;\n      var preview = this.options.preview;\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var alt = element.alt || 'The image to preview';\n      var image = document.createElement('img');\n\n      if (crossOrigin) {\n        image.crossOrigin = crossOrigin;\n      }\n\n      image.src = url;\n      image.alt = alt;\n      this.viewBox.appendChild(image);\n      this.viewBoxImage = image;\n\n      if (!preview) {\n        return;\n      }\n\n      var previews = preview;\n\n      if (typeof preview === 'string') {\n        previews = element.ownerDocument.querySelectorAll(preview);\n      } else if (preview.querySelector) {\n        previews = [preview];\n      }\n\n      this.previews = previews;\n      forEach(previews, function (el) {\n        var img = document.createElement('img'); // Save the original size for recover\n\n        setData(el, DATA_PREVIEW, {\n          width: el.offsetWidth,\n          height: el.offsetHeight,\n          html: el.innerHTML\n        });\n\n        if (crossOrigin) {\n          img.crossOrigin = crossOrigin;\n        }\n\n        img.src = url;\n        img.alt = alt;\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * Add `height:auto` to override `height` attribute on IE8\n         * (Occur only when margin-top <= -height)\n         */\n\n        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;\"';\n        el.innerHTML = '';\n        el.appendChild(img);\n      });\n    },\n    resetPreview: function resetPreview() {\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        setStyle(element, {\n          width: data.width,\n          height: data.height\n        });\n        element.innerHTML = data.html;\n        removeData(element, DATA_PREVIEW);\n      });\n    },\n    preview: function preview() {\n      var imageData = this.imageData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var cropBoxWidth = cropBoxData.width,\n          cropBoxHeight = cropBoxData.height;\n      var width = imageData.width,\n          height = imageData.height;\n      var left = cropBoxData.left - canvasData.left - imageData.left;\n      var top = cropBoxData.top - canvasData.top - imageData.top;\n\n      if (!this.cropped || this.disabled) {\n        return;\n      }\n\n      setStyle(this.viewBoxImage, assign({\n        width: width,\n        height: height\n      }, getTransforms(assign({\n        translateX: -left,\n        translateY: -top\n      }, imageData))));\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        setStyle(element, {\n          width: newWidth,\n          height: newHeight\n        });\n        setStyle(element.getElementsByTagName('img')[0], assign({\n          width: width * ratio,\n          height: height * ratio\n        }, getTransforms(assign({\n          translateX: -left * ratio,\n          translateY: -top * ratio\n        }, imageData))));\n      });\n    }\n  };\n\n  var events = {\n    bind: function bind() {\n      var element = this.element,\n          options = this.options,\n          cropper = this.cropper;\n\n      if (isFunction(options.cropstart)) {\n        addListener(element, EVENT_CROP_START, options.cropstart);\n      }\n\n      if (isFunction(options.cropmove)) {\n        addListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if (isFunction(options.cropend)) {\n        addListener(element, EVENT_CROP_END, options.cropend);\n      }\n\n      if (isFunction(options.crop)) {\n        addListener(element, EVENT_CROP, options.crop);\n      }\n\n      if (isFunction(options.zoom)) {\n        addListener(element, EVENT_ZOOM, options.zoom);\n      }\n\n      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n          passive: false,\n          capture: true\n        });\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n      }\n\n      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\n      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\n\n      if (options.responsive) {\n        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n      }\n    },\n    unbind: function unbind() {\n      var element = this.element,\n          options = this.options,\n          cropper = this.cropper;\n\n      if (isFunction(options.cropstart)) {\n        removeListener(element, EVENT_CROP_START, options.cropstart);\n      }\n\n      if (isFunction(options.cropmove)) {\n        removeListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if (isFunction(options.cropend)) {\n        removeListener(element, EVENT_CROP_END, options.cropend);\n      }\n\n      if (isFunction(options.crop)) {\n        removeListener(element, EVENT_CROP, options.crop);\n      }\n\n      if (isFunction(options.zoom)) {\n        removeListener(element, EVENT_ZOOM, options.zoom);\n      }\n\n      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        removeListener(cropper, EVENT_WHEEL, this.onWheel, {\n          passive: false,\n          capture: true\n        });\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\n      }\n\n      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\n      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\n\n      if (options.responsive) {\n        removeListener(window, EVENT_RESIZE, this.onResize);\n      }\n    }\n  };\n\n  var handlers = {\n    resize: function resize() {\n      var options = this.options,\n          container = this.container,\n          containerData = this.containerData;\n      var minContainerWidth = Number(options.minContainerWidth) || MIN_CONTAINER_WIDTH;\n      var minContainerHeight = Number(options.minContainerHeight) || MIN_CONTAINER_HEIGHT;\n\n      if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {\n        return;\n      }\n\n      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed\n\n      if (ratio !== 1 || container.offsetHeight !== containerData.height) {\n        var canvasData;\n        var cropBoxData;\n\n        if (options.restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (options.restore) {\n          this.setCanvasData(forEach(canvasData, function (n, i) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData(forEach(cropBoxData, function (n, i) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n    dblclick: function dblclick() {\n      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\n        return;\n      }\n\n      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\n    },\n    wheel: function wheel(event) {\n      var _this = this;\n\n      var ratio = Number(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.disabled) {\n        return;\n      }\n\n      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)\n\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n      setTimeout(function () {\n        _this.wheeling = false;\n      }, 50);\n\n      if (event.deltaY) {\n        delta = event.deltaY > 0 ? 1 : -1;\n      } else if (event.wheelDelta) {\n        delta = -event.wheelDelta / 120;\n      } else if (event.detail) {\n        delta = event.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n    cropStart: function cropStart(event) {\n      var buttons = event.buttons,\n          button = event.button;\n\n      if (this.disabled // Handle mouse event and pointer event and ignore touch event\n      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)\n      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu\n      || event.ctrlKey)) {\n        return;\n      }\n\n      var options = this.options,\n          pointers = this.pointers;\n      var action;\n\n      if (event.changedTouches) {\n        // Handle touch event\n        forEach(event.changedTouches, function (touch) {\n          pointers[touch.identifier] = getPointer(touch);\n        });\n      } else {\n        // Handle mouse event and pointer event\n        pointers[event.pointerId || 0] = getPointer(event);\n      }\n\n      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n        action = ACTION_ZOOM;\n      } else {\n        action = getData(event.target, DATA_ACTION);\n      }\n\n      if (!REGEXP_ACTIONS.test(action)) {\n        return;\n      }\n\n      if (dispatchEvent(this.element, EVENT_CROP_START, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      } // This line is required for preventing page zooming in iOS browsers\n\n\n      event.preventDefault();\n      this.action = action;\n      this.cropping = false;\n\n      if (action === ACTION_CROP) {\n        this.cropping = true;\n        addClass(this.dragBox, CLASS_MODAL);\n      }\n    },\n    cropMove: function cropMove(event) {\n      var action = this.action;\n\n      if (this.disabled || !action) {\n        return;\n      }\n\n      var pointers = this.pointers;\n      event.preventDefault();\n\n      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      }\n\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          // The first parameter should not be undefined (#432)\n          assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n        });\n      } else {\n        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n      }\n\n      this.change(event);\n    },\n    cropEnd: function cropEnd(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      var action = this.action,\n          pointers = this.pointers;\n\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          delete pointers[touch.identifier];\n        });\n      } else {\n        delete pointers[event.pointerId || 0];\n      }\n\n      if (!action) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (!Object.keys(pointers).length) {\n        this.action = '';\n      }\n\n      if (this.cropping) {\n        this.cropping = false;\n        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\n      }\n\n      dispatchEvent(this.element, EVENT_CROP_END, {\n        originalEvent: event,\n        action: action\n      });\n    }\n  };\n\n  var change = {\n    change: function change(event) {\n      var options = this.options,\n          canvasData = this.canvasData,\n          containerData = this.containerData,\n          cropBoxData = this.cropBoxData,\n          pointers = this.pointers;\n      var action = this.action;\n      var aspectRatio = options.aspectRatio;\n      var left = cropBoxData.left,\n          top = cropBoxData.top,\n          width = cropBoxData.width,\n          height = cropBoxData.height;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = containerData.width;\n      var maxHeight = containerData.height;\n      var renderable = true;\n      var offset; // Locking aspect ratio in \"free mode\" by holding shift key\n\n      if (!aspectRatio && event.shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBoxData.minLeft;\n        minTop = cropBoxData.minTop;\n        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\n        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\n      }\n\n      var pointer = pointers[Object.keys(pointers)[0]];\n      var range = {\n        x: pointer.endX - pointer.startX,\n        y: pointer.endY - pointer.startY\n      };\n\n      var check = function check(side) {\n        switch (side) {\n          case ACTION_EAST:\n            if (right + range.x > maxWidth) {\n              range.x = maxWidth - right;\n            }\n\n            break;\n\n          case ACTION_WEST:\n            if (left + range.x < minLeft) {\n              range.x = minLeft - left;\n            }\n\n            break;\n\n          case ACTION_NORTH:\n            if (top + range.y < minTop) {\n              range.y = minTop - top;\n            }\n\n            break;\n\n          case ACTION_SOUTH:\n            if (bottom + range.y > maxHeight) {\n              range.y = maxHeight - bottom;\n            }\n\n            break;\n\n          default:\n        }\n      };\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n        // Resize crop box\n\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_EAST);\n          width += range.x;\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = -width;\n            left -= width;\n          }\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_NORTH);\n          height -= range.y;\n          top += range.y;\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = -height;\n            top -= height;\n          }\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_WEST);\n          width -= range.x;\n          left += range.x;\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = -width;\n            left -= width;\n          }\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_SOUTH);\n          height += range.y;\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = -height;\n            top -= height;\n          }\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_EAST);\n\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += cropBoxData.width - width;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_WEST);\n\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_WEST);\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_WEST);\n\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            check(ACTION_EAST);\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_EAST);\n\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            top -= height;\n          }\n\n          break;\n        // Move canvas\n\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n        // Zoom canvas\n\n        case ACTION_ZOOM:\n          this.zoom(getMaxZoomRatio(pointers), event);\n          renderable = false;\n          break;\n        // Create crop box\n\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = getOffset(this.cropper);\n          left = pointer.startX - offset.left;\n          top = pointer.startY - offset.top;\n          width = cropBoxData.minWidth;\n          height = cropBoxData.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          } // Show the crop box if is hidden\n\n\n          if (!this.cropped) {\n            removeClass(this.cropBox, CLASS_HIDDEN);\n            this.cropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        default:\n      }\n\n      if (renderable) {\n        cropBoxData.width = width;\n        cropBoxData.height = height;\n        cropBoxData.left = left;\n        cropBoxData.top = top;\n        this.action = action;\n        this.renderCropBox();\n      } // Override\n\n\n      forEach(pointers, function (p) {\n        p.startX = p.endX;\n        p.startY = p.endY;\n      });\n    }\n  };\n\n  var methods = {\n    // Show the crop box manually\n    crop: function crop() {\n      if (this.ready && !this.cropped && !this.disabled) {\n        this.cropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          addClass(this.dragBox, CLASS_MODAL);\n        }\n\n        removeClass(this.cropBox, CLASS_HIDDEN);\n        this.setCropBoxData(this.initialCropBoxData);\n      }\n\n      return this;\n    },\n    // Reset the image and crop box to their initial states\n    reset: function reset() {\n      if (this.ready && !this.disabled) {\n        this.imageData = assign({}, this.initialImageData);\n        this.canvasData = assign({}, this.initialCanvasData);\n        this.cropBoxData = assign({}, this.initialCropBoxData);\n        this.renderCanvas();\n\n        if (this.cropped) {\n          this.renderCropBox();\n        }\n      }\n\n      return this;\n    },\n    // Clear the crop box\n    clear: function clear() {\n      if (this.cropped && !this.disabled) {\n        assign(this.cropBoxData, {\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        });\n        this.cropped = false;\n        this.renderCropBox();\n        this.limitCanvas(true, true); // Render canvas after crop box rendered\n\n        this.renderCanvas();\n        removeClass(this.dragBox, CLASS_MODAL);\n        addClass(this.cropBox, CLASS_HIDDEN);\n      }\n\n      return this;\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     * @param {string} url - The new URL.\n     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\n     * @returns {Cropper} this\n     */\n    replace: function replace(url) {\n      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!this.disabled && url) {\n        if (this.isImg) {\n          this.element.src = url;\n        }\n\n        if (hasSameSize) {\n          this.url = url;\n          this.image.src = url;\n\n          if (this.ready) {\n            this.viewBoxImage.src = url;\n            forEach(this.previews, function (element) {\n              element.getElementsByTagName('img')[0].src = url;\n            });\n          }\n        } else {\n          if (this.isImg) {\n            this.replaced = true;\n          }\n\n          this.options.data = null;\n          this.uncreate();\n          this.load(url);\n        }\n      }\n\n      return this;\n    },\n    // Enable (unfreeze) the cropper\n    enable: function enable() {\n      if (this.ready && this.disabled) {\n        this.disabled = false;\n        removeClass(this.cropper, CLASS_DISABLED);\n      }\n\n      return this;\n    },\n    // Disable (freeze) the cropper\n    disable: function disable() {\n      if (this.ready && !this.disabled) {\n        this.disabled = true;\n        addClass(this.cropper, CLASS_DISABLED);\n      }\n\n      return this;\n    },\n\n    /**\n     * Destroy the cropper and remove the instance from the image\n     * @returns {Cropper} this\n     */\n    destroy: function destroy() {\n      var element = this.element;\n\n      if (!element[NAMESPACE]) {\n        return this;\n      }\n\n      element[NAMESPACE] = undefined;\n\n      if (this.isImg && this.replaced) {\n        element.src = this.originalUrl;\n      }\n\n      this.uncreate();\n      return this;\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     * @param {number} offsetX - The relative offset distance on the x-axis.\n     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\n     * @returns {Cropper} this\n     */\n    move: function move(offsetX) {\n      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\n      var _this$canvasData = this.canvasData,\n          left = _this$canvasData.left,\n          top = _this$canvasData.top;\n      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     * @param {number} x - The x-axis coordinate.\n     * @param {number} [y=x] - The y-axis coordinate.\n     * @returns {Cropper} this\n     */\n    moveTo: function moveTo(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      var canvasData = this.canvasData;\n      var changed = false;\n      x = Number(x);\n      y = Number(y);\n\n      if (this.ready && !this.disabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvasData.left = x;\n          changed = true;\n        }\n\n        if (isNumber(y)) {\n          canvasData.top = y;\n          changed = true;\n        }\n\n        if (changed) {\n          this.renderCanvas(true);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoom: function zoom(ratio, _originalEvent) {\n      var canvasData = this.canvasData;\n      ratio = Number(ratio);\n\n      if (ratio < 0) {\n        ratio = 1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Object} pivot - The zoom pivot point coordinate.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\n      var options = this.options,\n          canvasData = this.canvasData;\n      var width = canvasData.width,\n          height = canvasData.height,\n          naturalWidth = canvasData.naturalWidth,\n          naturalHeight = canvasData.naturalHeight;\n      ratio = Number(ratio);\n\n      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\n        var newWidth = naturalWidth * ratio;\n        var newHeight = naturalHeight * ratio;\n\n        if (dispatchEvent(this.element, EVENT_ZOOM, {\n          ratio: ratio,\n          oldRatio: width / naturalWidth,\n          originalEvent: _originalEvent\n        }) === false) {\n          return this;\n        }\n\n        if (_originalEvent) {\n          var pointers = this.pointers;\n          var offset = getOffset(this.cropper);\n          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n            pageX: _originalEvent.pageX,\n            pageY: _originalEvent.pageY\n          }; // Zoom from the triggering point of the event\n\n          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\n        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\n        } else {\n          // Zoom from the center of the canvas\n          canvasData.left -= (newWidth - width) / 2;\n          canvasData.top -= (newHeight - height) / 2;\n        }\n\n        canvasData.width = newWidth;\n        canvasData.height = newHeight;\n        this.renderCanvas(true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotate: function rotate(degree) {\n      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotateTo: function rotateTo(degree) {\n      degree = Number(degree);\n\n      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\n        this.imageData.rotate = degree % 360;\n        this.renderCanvas(true, true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Scale the image on the x-axis.\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @returns {Cropper} this\n     */\n    scaleX: function scaleX(_scaleX) {\n      var scaleY = this.imageData.scaleY;\n      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the image on the y-axis.\n     * @param {number} scaleY - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scaleY: function scaleY(_scaleY) {\n      var scaleX = this.imageData.scaleX;\n      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\n    },\n\n    /**\n     * Scale the image\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scale: function scale(scaleX) {\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n      var imageData = this.imageData;\n      var transformed = false;\n      scaleX = Number(scaleX);\n      scaleY = Number(scaleY);\n\n      if (this.ready && !this.disabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          imageData.scaleX = scaleX;\n          transformed = true;\n        }\n\n        if (isNumber(scaleY)) {\n          imageData.scaleY = scaleY;\n          transformed = true;\n        }\n\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     * @param {boolean} [rounded=false] - Indicate if round the data values or not.\n     * @returns {Object} The result cropped data.\n     */\n    getData: function getData() {\n      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var options = this.options,\n          imageData = this.imageData,\n          canvasData = this.canvasData,\n          cropBoxData = this.cropBoxData;\n      var data;\n\n      if (this.ready && this.cropped) {\n        data = {\n          x: cropBoxData.left - canvasData.left,\n          y: cropBoxData.top - canvasData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n        var ratio = imageData.width / imageData.naturalWidth;\n        forEach(data, function (n, i) {\n          data[i] = n / ratio;\n        });\n\n        if (rounded) {\n          // In case rounding off leads to extra 1px in right or bottom border\n          // we should round the top-left corner and the dimension (#343).\n          var bottom = Math.round(data.y + data.height);\n          var right = Math.round(data.x + data.width);\n          data.x = Math.round(data.x);\n          data.y = Math.round(data.y);\n          data.width = right - data.x;\n          data.height = bottom - data.y;\n        }\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = imageData.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = imageData.scaleX || 1;\n        data.scaleY = imageData.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     * @param {Object} data - The new data.\n     * @returns {Cropper} this\n     */\n    setData: function setData(data) {\n      var options = this.options,\n          imageData = this.imageData,\n          canvasData = this.canvasData;\n      var cropBoxData = {};\n\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        var transformed = false;\n\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\n            imageData.rotate = data.rotate;\n            transformed = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\n            imageData.scaleX = data.scaleX;\n            transformed = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\n            imageData.scaleY = data.scaleY;\n            transformed = true;\n          }\n        }\n\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n\n        var ratio = imageData.width / imageData.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvasData.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvasData.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the container size data.\n     * @returns {Object} The result container data.\n     */\n    getContainerData: function getContainerData() {\n      return this.ready ? assign({}, this.containerData) : {};\n    },\n\n    /**\n     * Get the image position and size data.\n     * @returns {Object} The result image data.\n     */\n    getImageData: function getImageData() {\n      return this.sized ? assign({}, this.imageData) : {};\n    },\n\n    /**\n     * Get the canvas position and size data.\n     * @returns {Object} The result canvas data.\n     */\n    getCanvasData: function getCanvasData() {\n      var canvasData = this.canvasData;\n      var data = {};\n\n      if (this.ready) {\n        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {\n          data[n] = canvasData[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data.\n     * @param {Object} data - The new canvas data.\n     * @returns {Cropper} this\n     */\n    setCanvasData: function setCanvasData(data) {\n      var canvasData = this.canvasData;\n      var aspectRatio = canvasData.aspectRatio;\n\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvasData.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvasData.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvasData.width = data.width;\n          canvasData.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvasData.height = data.height;\n          canvasData.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the crop box position and size data.\n     * @returns {Object} The result crop box data.\n     */\n    getCropBoxData: function getCropBoxData() {\n      var cropBoxData = this.cropBoxData;\n      var data;\n\n      if (this.ready && this.cropped) {\n        data = {\n          left: cropBoxData.left,\n          top: cropBoxData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data.\n     * @param {Object} data - The new crop box data.\n     * @returns {Cropper} this\n     */\n    setCropBoxData: function setCropBoxData(data) {\n      var cropBoxData = this.cropBoxData;\n      var aspectRatio = this.options.aspectRatio;\n      var widthChanged;\n      var heightChanged;\n\n      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          cropBoxData.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBoxData.top = data.top;\n        }\n\n        if (isNumber(data.width) && data.width !== cropBoxData.width) {\n          widthChanged = true;\n          cropBoxData.width = data.width;\n        }\n\n        if (isNumber(data.height) && data.height !== cropBoxData.height) {\n          heightChanged = true;\n          cropBoxData.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (widthChanged) {\n            cropBoxData.height = cropBoxData.width / aspectRatio;\n          } else if (heightChanged) {\n            cropBoxData.width = cropBoxData.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n\n      return this;\n    },\n\n    /**\n     * Get a canvas drawn the cropped image.\n     * @param {Object} [options={}] - The config options.\n     * @returns {HTMLCanvasElement} - The result canvas.\n     */\n    getCroppedCanvas: function getCroppedCanvas() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.ready || !window.HTMLCanvasElement) {\n        return null;\n      }\n\n      var canvasData = this.canvasData;\n      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.\n\n      if (!this.cropped) {\n        return source;\n      }\n\n      var _this$getData = this.getData(),\n          initialX = _this$getData.x,\n          initialY = _this$getData.y,\n          initialWidth = _this$getData.width,\n          initialHeight = _this$getData.height;\n\n      var ratio = source.width / Math.floor(canvasData.naturalWidth);\n\n      if (ratio !== 1) {\n        initialX *= ratio;\n        initialY *= ratio;\n        initialWidth *= ratio;\n        initialHeight *= ratio;\n      }\n\n      var aspectRatio = initialWidth / initialHeight;\n      var maxSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.maxWidth || Infinity,\n        height: options.maxHeight || Infinity\n      });\n      var minSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.minWidth || 0,\n        height: options.minHeight || 0\n      }, 'cover');\n\n      var _getAdjustedSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.width || (ratio !== 1 ? source.width : initialWidth),\n        height: options.height || (ratio !== 1 ? source.height : initialHeight)\n      }),\n          width = _getAdjustedSizes.width,\n          height = _getAdjustedSizes.height;\n\n      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      canvas.width = normalizeDecimalNumber(width);\n      canvas.height = normalizeDecimalNumber(height);\n      context.fillStyle = options.fillColor || 'transparent';\n      context.fillRect(0, 0, width, height);\n      var _options$imageSmoothi = options.imageSmoothingEnabled,\n          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,\n          imageSmoothingQuality = options.imageSmoothingQuality;\n      context.imageSmoothingEnabled = imageSmoothingEnabled;\n\n      if (imageSmoothingQuality) {\n        context.imageSmoothingQuality = imageSmoothingQuality;\n      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n\n\n      var sourceWidth = source.width;\n      var sourceHeight = source.height; // Source canvas parameters\n\n      var srcX = initialX;\n      var srcY = initialY;\n      var srcWidth;\n      var srcHeight; // Destination canvas parameters\n\n      var dstX;\n      var dstY;\n      var dstWidth;\n      var dstHeight;\n\n      if (srcX <= -initialWidth || srcX > sourceWidth) {\n        srcX = 0;\n        srcWidth = 0;\n        dstX = 0;\n        dstWidth = 0;\n      } else if (srcX <= 0) {\n        dstX = -srcX;\n        srcX = 0;\n        srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n        dstWidth = srcWidth;\n      } else if (srcX <= sourceWidth) {\n        dstX = 0;\n        srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n        dstWidth = srcWidth;\n      }\n\n      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n        srcY = 0;\n        srcHeight = 0;\n        dstY = 0;\n        dstHeight = 0;\n      } else if (srcY <= 0) {\n        dstY = -srcY;\n        srcY = 0;\n        srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n        dstHeight = srcHeight;\n      } else if (srcY <= sourceHeight) {\n        dstY = 0;\n        srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n        dstHeight = srcHeight;\n      }\n\n      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid \"IndexSizeError\"\n\n      if (dstWidth > 0 && dstHeight > 0) {\n        var scale = width / initialWidth;\n        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n      } // All the numerical parameters should be integer for `drawImage`\n      // https://github.com/fengyuanchen/cropper/issues/476\n\n\n      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {\n        return Math.floor(normalizeDecimalNumber(param));\n      }))));\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box.\n     * @param {number} aspectRatio - The new aspect ratio.\n     * @returns {Cropper} this\n     */\n    setAspectRatio: function setAspectRatio(aspectRatio) {\n      var options = this.options;\n\n      if (!this.disabled && !isUndefined(aspectRatio)) {\n        // 0 -> NaN\n        options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n\n        if (this.ready) {\n          this.initCropBox();\n\n          if (this.cropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Change the drag mode.\n     * @param {string} mode - The new drag mode.\n     * @returns {Cropper} this\n     */\n    setDragMode: function setDragMode(mode) {\n      var options = this.options,\n          dragBox = this.dragBox,\n          face = this.face;\n\n      if (this.ready && !this.disabled) {\n        var croppable = mode === DRAG_MODE_CROP;\n        var movable = options.movable && mode === DRAG_MODE_MOVE;\n        mode = croppable || movable ? mode : DRAG_MODE_NONE;\n        options.dragMode = mode;\n        setData(dragBox, DATA_ACTION, mode);\n        toggleClass(dragBox, CLASS_CROP, croppable);\n        toggleClass(dragBox, CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n          // Sync drag mode to crop box when it is not movable\n          setData(face, DATA_ACTION, mode);\n          toggleClass(face, CLASS_CROP, croppable);\n          toggleClass(face, CLASS_MOVE, movable);\n        }\n      }\n\n      return this;\n    }\n  };\n\n  var AnotherCropper = WINDOW.Cropper;\n\n  var Cropper =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Create a new Cropper.\n     * @param {Element} element - The target element for cropping.\n     * @param {Object} [options={}] - The configuration options.\n     */\n    function Cropper(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Cropper);\n\n      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\n        throw new Error('The first argument is required and must be an <img> or <canvas> element.');\n      }\n\n      this.element = element;\n      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n      this.cropped = false;\n      this.disabled = false;\n      this.pointers = {};\n      this.ready = false;\n      this.reloading = false;\n      this.replaced = false;\n      this.sized = false;\n      this.sizing = false;\n      this.init();\n    }\n\n    _createClass(Cropper, [{\n      key: \"init\",\n      value: function init() {\n        var element = this.element;\n        var tagName = element.tagName.toLowerCase();\n        var url;\n\n        if (element[NAMESPACE]) {\n          return;\n        }\n\n        element[NAMESPACE] = this;\n\n        if (tagName === 'img') {\n          this.isImg = true; // e.g.: \"img/picture.jpg\"\n\n          url = element.getAttribute('src') || '';\n          this.originalUrl = url; // Stop when it's a blank image\n\n          if (!url) {\n            return;\n          } // e.g.: \"http://example.com/img/picture.jpg\"\n\n\n          url = element.src;\n        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {\n          url = element.toDataURL();\n        }\n\n        this.load(url);\n      }\n    }, {\n      key: \"load\",\n      value: function load(url) {\n        var _this = this;\n\n        if (!url) {\n          return;\n        }\n\n        this.url = url;\n        this.imageData = {};\n        var element = this.element,\n            options = this.options;\n\n        if (!options.rotatable && !options.scalable) {\n          options.checkOrientation = false;\n        } // Only IE10+ supports Typed Arrays\n\n\n        if (!options.checkOrientation || !window.ArrayBuffer) {\n          this.clone();\n          return;\n        } // Detect the mime type of the image directly if it is a Data URL\n\n\n        if (REGEXP_DATA_URL.test(url)) {\n          // Read ArrayBuffer from Data URL of JPEG images directly for better performance\n          if (REGEXP_DATA_URL_JPEG.test(url)) {\n            this.read(dataURLToArrayBuffer(url));\n          } else {\n            // Only a JPEG image may contains Exif Orientation information,\n            // the rest types of Data URLs are not necessary to check orientation at all.\n            this.clone();\n          }\n\n          return;\n        } // 1. Detect the mime type of the image by a XMLHttpRequest.\n        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.\n\n\n        var xhr = new XMLHttpRequest();\n        var clone = this.clone.bind(this);\n        this.reloading = true;\n        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:\n        // http, https, data, chrome, chrome-extension.\n        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy\n        // in some browsers as IE11 and Safari.\n\n        xhr.onabort = clone;\n        xhr.onerror = clone;\n        xhr.ontimeout = clone;\n\n        xhr.onprogress = function () {\n          // Abort the request directly if it not a JPEG image for better performance\n          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {\n            xhr.abort();\n          }\n        };\n\n        xhr.onload = function () {\n          _this.read(xhr.response);\n        };\n\n        xhr.onloadend = function () {\n          _this.reloading = false;\n          _this.xhr = null;\n        }; // Bust cache when there is a \"crossOrigin\" property to avoid browser cache error\n\n\n        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\n          url = addTimestamp(url);\n        }\n\n        xhr.open('GET', url);\n        xhr.responseType = 'arraybuffer';\n        xhr.withCredentials = element.crossOrigin === 'use-credentials';\n        xhr.send();\n      }\n    }, {\n      key: \"read\",\n      value: function read(arrayBuffer) {\n        var options = this.options,\n            imageData = this.imageData; // Reset the orientation value to its default value 1\n        // as some iOS browsers will render image with its orientation\n\n        var orientation = resetAndGetOrientation(arrayBuffer);\n        var rotate = 0;\n        var scaleX = 1;\n        var scaleY = 1;\n\n        if (orientation > 1) {\n          // Generate a new URL which has the default orientation value\n          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);\n\n          var _parseOrientation = parseOrientation(orientation);\n\n          rotate = _parseOrientation.rotate;\n          scaleX = _parseOrientation.scaleX;\n          scaleY = _parseOrientation.scaleY;\n        }\n\n        if (options.rotatable) {\n          imageData.rotate = rotate;\n        }\n\n        if (options.scalable) {\n          imageData.scaleX = scaleX;\n          imageData.scaleY = scaleY;\n        }\n\n        this.clone();\n      }\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var element = this.element,\n            url = this.url;\n        var crossOrigin = element.crossOrigin;\n        var crossOriginUrl = url;\n\n        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\n          if (!crossOrigin) {\n            crossOrigin = 'anonymous';\n          } // Bust cache when there is not a \"crossOrigin\" property (#519)\n\n\n          crossOriginUrl = addTimestamp(url);\n        }\n\n        this.crossOrigin = crossOrigin;\n        this.crossOriginUrl = crossOriginUrl;\n        var image = document.createElement('img');\n\n        if (crossOrigin) {\n          image.crossOrigin = crossOrigin;\n        }\n\n        image.src = crossOriginUrl || url;\n        image.alt = element.alt || 'The image to crop';\n        this.image = image;\n        image.onload = this.start.bind(this);\n        image.onerror = this.stop.bind(this);\n        addClass(image, CLASS_HIDE);\n        element.parentNode.insertBefore(image, element.nextSibling);\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,\n        // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n\n        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);\n\n        var done = function done(naturalWidth, naturalHeight) {\n          assign(_this2.imageData, {\n            naturalWidth: naturalWidth,\n            naturalHeight: naturalHeight,\n            aspectRatio: naturalWidth / naturalHeight\n          });\n          _this2.sizing = false;\n          _this2.sized = true;\n\n          _this2.build();\n        }; // Most modern browsers (excepts iOS WebKit)\n\n\n        if (image.naturalWidth && !isIOSWebKit) {\n          done(image.naturalWidth, image.naturalHeight);\n          return;\n        }\n\n        var sizingImage = document.createElement('img');\n        var body = document.body || document.documentElement;\n        this.sizingImage = sizingImage;\n\n        sizingImage.onload = function () {\n          done(sizingImage.width, sizingImage.height);\n\n          if (!isIOSWebKit) {\n            body.removeChild(sizingImage);\n          }\n        };\n\n        sizingImage.src = image.src; // iOS WebKit will convert the image automatically\n        // with its orientation once append it into DOM (#279)\n\n        if (!isIOSWebKit) {\n          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n          body.appendChild(sizingImage);\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        image.parentNode.removeChild(image);\n        this.image = null;\n      }\n    }, {\n      key: \"build\",\n      value: function build() {\n        if (!this.sized || this.ready) {\n          return;\n        }\n\n        var element = this.element,\n            options = this.options,\n            image = this.image; // Create cropper elements\n\n        var container = element.parentNode;\n        var template = document.createElement('div');\n        template.innerHTML = TEMPLATE;\n        var cropper = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n        var canvas = cropper.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n        var dragBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-drag-box\"));\n        var cropBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-crop-box\"));\n        var face = cropBox.querySelector(\".\".concat(NAMESPACE, \"-face\"));\n        this.container = container;\n        this.cropper = cropper;\n        this.canvas = canvas;\n        this.dragBox = dragBox;\n        this.cropBox = cropBox;\n        this.viewBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-view-box\"));\n        this.face = face;\n        canvas.appendChild(image); // Hide the original image\n\n        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image\n\n        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden\n\n        if (!this.isImg) {\n          removeClass(image, CLASS_HIDE);\n        }\n\n        this.initPreview();\n        this.bind();\n        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\n        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\n        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\n        addClass(cropBox, CLASS_HIDDEN);\n\n        if (!options.guides) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-dashed\")), CLASS_HIDDEN);\n        }\n\n        if (!options.center) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-center\")), CLASS_HIDDEN);\n        }\n\n        if (options.background) {\n          addClass(cropper, \"\".concat(NAMESPACE, \"-bg\"));\n        }\n\n        if (!options.highlight) {\n          addClass(face, CLASS_INVISIBLE);\n        }\n\n        if (options.cropBoxMovable) {\n          addClass(face, CLASS_MOVE);\n          setData(face, DATA_ACTION, ACTION_ALL);\n        }\n\n        if (!options.cropBoxResizable) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-line\")), CLASS_HIDDEN);\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-point\")), CLASS_HIDDEN);\n        }\n\n        this.render();\n        this.ready = true;\n        this.setDragMode(options.dragMode);\n\n        if (options.autoCrop) {\n          this.crop();\n        }\n\n        this.setData(options.data);\n\n        if (isFunction(options.ready)) {\n          addListener(element, EVENT_READY, options.ready, {\n            once: true\n          });\n        }\n\n        dispatchEvent(element, EVENT_READY);\n      }\n    }, {\n      key: \"unbuild\",\n      value: function unbuild() {\n        if (!this.ready) {\n          return;\n        }\n\n        this.ready = false;\n        this.unbind();\n        this.resetPreview();\n        this.cropper.parentNode.removeChild(this.cropper);\n        removeClass(this.element, CLASS_HIDDEN);\n      }\n    }, {\n      key: \"uncreate\",\n      value: function uncreate() {\n        if (this.ready) {\n          this.unbuild();\n          this.ready = false;\n          this.cropped = false;\n        } else if (this.sizing) {\n          this.sizingImage.onload = null;\n          this.sizing = false;\n          this.sized = false;\n        } else if (this.reloading) {\n          this.xhr.onabort = null;\n          this.xhr.abort();\n        } else if (this.image) {\n          this.stop();\n        }\n      }\n      /**\n       * Get the no conflict cropper class.\n       * @returns {Cropper} The cropper class.\n       */\n\n    }], [{\n      key: \"noConflict\",\n      value: function noConflict() {\n        window.Cropper = AnotherCropper;\n        return Cropper;\n      }\n      /**\n       * Change the default options.\n       * @param {Object} options - The new default options.\n       */\n\n    }, {\n      key: \"setDefaults\",\n      value: function setDefaults(options) {\n        assign(DEFAULTS, isPlainObject(options) && options);\n      }\n    }]);\n\n    return Cropper;\n  }();\n\n  assign(Cropper.prototype, render, preview, events, handlers, change, methods);\n\n  return Cropper;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/cropperjs/dist/cropper.js\n// module id = 11\n// module chunks = 0","/*!\n * Fuse.js v3.3.1 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    // console.log('score', score, finalScore)\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // console.log('FINAL SCORE', finalScore)\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { limit: false };\n\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      if (opts.limit && typeof opts.limit === 'number') {\n        results = results.slice(0, opts.limit);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var currScore = 1;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            currScore *= nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? currScore : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      if (this.options.verbose) {\n        var cache = [];\n        this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results, function (key, value) {\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {\n            if (cache.indexOf(value) !== -1) {\n              // Circular reference found, discard key\n              return;\n            }\n            // Store value in our collection\n            cache.push(value);\n          }\n          return value;\n        }));\n        cache = null; // Enable garbage collection\n      }\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fuse.js/dist/fuse.js\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}