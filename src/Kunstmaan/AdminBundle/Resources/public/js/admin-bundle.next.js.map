{"version":3,"sources":["webpack:///src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","webpack:///webpack/bootstrap ba5a65f4fbc986a12549","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser.js","webpack:///./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","webpack:///./~/fuse.js/dist/fuse.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","updateSearch","searchItems","searchResults","forEach","item","ppName","getAttribute","ATTRIBUTES","PP_NAME","includes","classList","remove","CLASSES","PP_SEARCH_ITEM_HIDDEN","add","resetSearch","__WEBPACK_IMPORTED_MODULE_0_fuse_js__","__WEBPACK_IMPORTED_MODULE_0_fuse_js___default","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","SELECTORS","PP_CHOOSER","PP_SEARCH_FIELD","PP_SEARCH_ITEM","PP_SEARCH_RESET","PP_TYPES","ppList","PagePartChooser","this","container","arguments","undefined","window","document","ppChooser","querySelector","initSearch","ppTypes","JSON","parse","type","ppClass","index","lastIndexOf","substring","replace","searchField","Array","slice","querySelectorAll","fuse","a","keys","weight","id","threshold","shouldSort","searchHandler","trim","search","addEventListener","searchReset","resetHandler","init","__WEBPACK_IMPORTED_MODULE_0__PagePartChooser__","readyState","root","factory","obj","toString","bitapRegexSearch","bitapSearch","patternAlphabet","Bitap","pattern","_ref","_ref$location","location","_ref$distance","distance","_ref$threshold","_ref$maxPatternLength","maxPatternLength","_ref$isCaseSensitive","isCaseSensitive","_ref$tokenSeparator","tokenSeparator","_ref$findAllMatches","findAllMatches","_ref$minMatchCharLeng","minMatchCharLength","options","toLowerCase","text","isMatch","score","matchedIndices","_options","_options2","isArray","deepValue","path","list","dotIndex","indexOf","firstSegment","remaining","len","push","matchmask","start","end","match","mask","charAt","_i","SPECIAL_CHARS_REGEX","regex","RegExp","matches","matchesLen","_ref$errors","errors","_ref$currentLocation","currentLocation","_ref$expectedLocation","expectedLocation","accuracy","proximity","Math","abs","bitapScore","textLen","currentThreshold","bestLocation","patternLen","matchMask","min","_score","lastBitArr","finalScore","binMax","binMin","binMid","floor","max","finish","bitArr","j","charMatch","Fuse","_ref$caseSensitive","caseSensitive","_ref$id","_ref$keys","_ref$shouldSort","_ref$getFn","getFn","_ref$sortFn","sortFn","b","_ref$tokenize","tokenize","_ref$matchAllTokens","matchAllTokens","_ref$includeMatches","includeMatches","_ref$includeScore","includeScore","_ref$verbose","verbose","setCollection","_log","_prepareSearchers2","_prepareSearchers","tokenSearchers","fullSearcher","_search2","_search","weights","results","_computeScore","_sort","_format","tokens","split","resultMap","_analyze","record","_len","keysLen","Error","_ref2","_ref3","_ref2$arrayIndex","arrayIndex","_ref3$tokenSearchers","_ref3$fullSearcher","_ref3$resultMap","_ref3$results","exists","averageScore","numTextMatches","mainSearchResult","words","scores","tokenSearcher","hasMatchInText","word","tokenSearchResult","scoresLen","_i2","checkTextMatches","existingResult","output","_i3","scoreLen","totalScore","bestScore","nScore","sort","finalOutput","stringify","transformers","result","data","indices","_len2","_console","console","log","apply"],"mappings":"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","file":"./src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fuse_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fuse_js__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nvar CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nvar ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n};\n\nvar ppList = void 0;\n\nvar PagePartChooser = function () {\n    function PagePartChooser() {\n        _classCallCheck(this, PagePartChooser);\n    }\n\n    _createClass(PagePartChooser, null, [{\n        key: 'init',\n        value: function init() {\n            var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;\n\n            var ppChooser = container.querySelector(SELECTORS.PP_CHOOSER);\n\n            if (ppChooser) {\n                initSearch(ppChooser);\n            }\n        }\n    }]);\n\n    return PagePartChooser;\n}();\n// TODO Refactor to a separate PagePartSearch class?\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PagePartChooser);\nvar initSearch = function initSearch(ppChooser) {\n    var ppTypes = JSON.parse(ppChooser.getAttribute(ATTRIBUTES.PP_TYPES));\n\n    //Clean up the dataset\n    ppTypes.forEach(function (type) {\n        var ppClass = type['class'];\n        var index = ppClass.lastIndexOf('\\\\');\n\n        if (-1 !== index) {\n            // We also search by class name because PageParts can be renamed\n            // Remove the namespace / 'PagePart' from the classname\n            type['class'] = ppClass.substring(index + 1).replace('PagePart', '');\n        }\n    });\n\n    var searchField = ppChooser.querySelector(SELECTORS.PP_SEARCH_FIELD);\n    ppList = Array.prototype.slice.call(ppChooser.querySelectorAll(SELECTORS.PP_SEARCH_ITEM));\n\n    var fuse = new __WEBPACK_IMPORTED_MODULE_0_fuse_js___default.a(ppTypes, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'class',\n            weight: 0.3 //The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n\n    var searchHandler = function searchHandler() {\n        if (searchField.value.trim().length > 0) {\n            var searchResults = fuse.search(searchField.value);\n            updateSearch(ppList, searchResults);\n        } else {\n            resetSearch(ppList);\n        }\n    };\n\n    searchField.addEventListener('keyup', searchHandler);\n\n    var searchReset = ppChooser.querySelector(SELECTORS.PP_SEARCH_RESET);\n\n    var resetHandler = function resetHandler() {\n        searchField.value = '';\n        resetSearch(ppList);\n    };\n\n    searchReset.addEventListener('click', resetHandler);\n};\n\nfunction updateSearch(searchItems, searchResults) {\n    searchItems.forEach(function (item) {\n        var ppName = item.getAttribute(ATTRIBUTES.PP_NAME);\n\n        //TODO include a polyfill for [].includes()\n        if (searchResults.includes(ppName)) {\n            item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n}\n\nfunction resetSearch(searchItems) {\n    searchItems.forEach(function (item) {\n        item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PagePartChooser__ = __webpack_require__(0);\n\n\nfunction init() {\n    __WEBPACK_IMPORTED_MODULE_0__PagePartChooser__[\"a\" /* default */].init();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        init();\n    });\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Fuse.js v3.2.0 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var totalScore = 0;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            totalScore += nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? totalScore / scoreLen : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results));\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// src/Kunstmaan/AdminBundle/Resources/public/js/admin-bundle.next.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ba5a65f4fbc986a12549","import Fuse from 'fuse.js';\n\nconst SELECTORS = {\n    PP_CHOOSER: '.js-pp-chooser',\n    PP_SEARCH_FIELD: '.js-pp-search',\n    PP_SEARCH_ITEM: '.js-pp-search-item',\n    PP_SEARCH_RESET: '.js-pp-search__reset'\n};\n\nconst CLASSES = {\n    PP_SEARCH_ITEM_HIDDEN: 'pp-search-item--hidden'\n};\n\nconst ATTRIBUTES = {\n    PP_TYPES: 'data-pp-types',\n    PP_NAME: 'data-pp-name'\n}\n\nlet ppList;\n\nexport default class PagePartChooser {\n    static init(container = window.document) {\n        const ppChooser = container.querySelector(SELECTORS.PP_CHOOSER);\n\n        if(ppChooser) {\n            initSearch(ppChooser);\n        }\n    }\n}\n// TODO Refactor to a separate PagePartSearch class?\nconst initSearch = (ppChooser) => {\n    const ppTypes = JSON.parse(ppChooser.getAttribute(ATTRIBUTES.PP_TYPES));\n\n    //Clean up the dataset\n    ppTypes.forEach((type) => {\n        const ppClass = type['class'];\n        const index = ppClass.lastIndexOf('\\\\');\n\n        if(-1 !== index) {\n            // We also search by class name because PageParts can be renamed\n            // Remove the namespace / 'PagePart' from the classname\n            type['class'] = ppClass.substring(index + 1).replace('PagePart', '');\n        }\n    });\n\n    const searchField = ppChooser.querySelector(SELECTORS.PP_SEARCH_FIELD);\n    ppList = Array.prototype.slice.call(ppChooser.querySelectorAll(SELECTORS.PP_SEARCH_ITEM));\n\n    const fuse = new Fuse(ppTypes, {\n        keys: [{\n            name: 'name',\n            weight: 0.7\n        }, {\n            name: 'class',\n            weight: 0.3 //The internal name is less important\n        }],\n        id: 'name',\n        threshold: 0.4,\n        shouldSort: true\n    });\n\n    const searchHandler = () => {\n        if(searchField.value.trim().length > 0) {\n            const searchResults = fuse.search(searchField.value);\n            updateSearch(ppList, searchResults);\n        } else {\n            resetSearch(ppList);\n        }\n    };\n\n    searchField.addEventListener('keyup', searchHandler);\n\n    const searchReset = ppChooser.querySelector(SELECTORS.PP_SEARCH_RESET);\n\n    const resetHandler = () => {\n        searchField.value = '';\n        resetSearch(ppList);\n    };\n\n    searchReset.addEventListener('click', resetHandler);\n\n};\n\nfunction updateSearch(searchItems, searchResults) {\n    searchItems.forEach((item) => {\n        const ppName = item.getAttribute(ATTRIBUTES.PP_NAME);\n\n        //TODO include a polyfill for [].includes()\n        if(searchResults.includes(ppName)) {\n            item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        } else {\n            item.classList.add(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n        }\n    });\n\n}\n\nfunction resetSearch(searchItems) {\n    searchItems.forEach((item) => {\n        item.classList.remove(CLASSES.PP_SEARCH_ITEM_HIDDEN);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/PagePartChooser.js","import PagePartChooser from './PagePartChooser';\n\nfunction init() {\n    PagePartChooser.init();\n}\n\n// This script is loaded dynamically, so it could be that DOMContentLoaded was already fired when this script is executed\nif (document.readyState !== 'loading') {\n    init();\n} else {\n    document.addEventListener('DOMContentLoaded', () => {\n        init();\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kunstmaan/AdminBundle/Resources/ui/jsnext/app.js","/*!\n * Fuse.js v3.2.0 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var totalScore = 0;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            totalScore += nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? totalScore / scoreLen : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results));\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fuse.js/dist/fuse.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}